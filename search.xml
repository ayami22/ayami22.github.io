<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>日语学校语法体系与教育语法体系</title>
      <link href="/2025/06/01/Japanese/%E6%97%A5%E8%AF%AD%E5%AD%A6%E6%A0%A1%E8%AF%AD%E6%B3%95%E4%BD%93%E7%B3%BB%E4%B8%8E%E6%95%99%E8%82%B2%E8%AF%AD%E6%B3%95%E4%BD%93%E7%B3%BB/"/>
      <url>/2025/06/01/Japanese/%E6%97%A5%E8%AF%AD%E5%AD%A6%E6%A0%A1%E8%AF%AD%E6%B3%95%E4%BD%93%E7%B3%BB%E4%B8%8E%E6%95%99%E8%82%B2%E8%AF%AD%E6%B3%95%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<p><strong>一、单词（単語）</strong></p><p>（単語是单词的日语原文，为方便读者以后进阶学习，这里涉及到的概念都会给出日语原文，下同。）</p><p>单词是把句子进行分解后可以得到的最小的有意义的单位，是句子里可以自由运用的最小单位。</p><p><strong>二、句节（文節）</strong></p><p>在不影响对句子的意义的理解下，尽可能地把句子划分成最小的段落，这种段落叫做“句节”。</p><p> 例：太郎と &#x2F; 二郎が &#x2F; ボールを&#x2F; 投げて&#x2F;  いる。（五个句节）</p><p>三、<strong>学校语法的词类划分：（独立词与附属词）详细请看</strong>日语里的词类划分</p><p><img src="/../../assets/image-20240621162238-p6gzztw.png" alt="image">​</p><p>‍</p><p><strong>四、用语对照</strong></p><p>动词形容词分类：</p><p><img src="/../../assets/net-img-69f80eb9cc8b2dff607aeb7af7e107a83291c439.png@1256w_494h_web-article-pic-20240622105925-934j9yk.avif" alt="69f80eb9cc8b2dff607aeb7af7e107a83291c439.png@1256w_494h_web-article-pic">​</p><p>活用形对比：</p><p><img src="/../../assets/net-img-6dae1b04d0f46dcdd0a8a445044be5e938465ce8.png@1256w_908h_web-article-pic-20240622105926-h6gucs1.avif" alt="6dae1b04d0f46dcdd0a8a445044be5e938465ce8.png@1256w_908h_web-article-pic">​</p><p>学校语法的动词活用：未然形，连用形，终止形，连体形，假定形，命令形和推量形。</p><p>教育语法的动词活用：ます形、ない形，て形，辞书形，ない形，意向形，命令形，ば形等。</p>]]></content>
      
      
      <categories>
          
          <category> 日语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
            <tag> 日语语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Csharp学习档案</title>
      <link href="/2025/05/29/CoddingStore/csharp%E5%AD%A6%E4%B9%A0%E6%A1%A3%E6%A1%88/"/>
      <url>/2025/05/29/CoddingStore/csharp%E5%AD%A6%E4%B9%A0%E6%A1%A3%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="学习手册："><a href="#学习手册：" class="headerlink" title="学习手册："></a>学习手册：</h1><p><a href="https://www.w3ccoo.com/">w3schools 教程</a>从前端到后端到数据库，各种语言教程一应俱全</p><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="（1）枚举的申明"><a href="#（1）枚举的申明" class="headerlink" title="（1）枚举的申明"></a>（1）枚举的申明</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> E_ZiDan</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">a,<span class="comment">//自定义枚举项的名字，</span></span><br><span class="line"></span><br><span class="line">b=<span class="number">100</span>,</span><br><span class="line"></span><br><span class="line">c,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举项未赋值时，从0开始自动赋值，往后依次累加，给某个枚举项命名后，从这个项往后依次累加。申明枚举时要在namesapce中命名。</p><p>例子：</p><p>申明一个怪物类型的枚举项</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> E_MonsterType</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Normal,</span><br><span class="line"></span><br><span class="line">Boss,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申明一个玩家类型的枚举项</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> E_Player</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">main,</span><br><span class="line"></span><br><span class="line">other,</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（2）枚举变量的申明初始化和使用"><a href="#（2）枚举变量的申明初始化和使用" class="headerlink" title="（2）枚举变量的申明初始化和使用"></a>（2）枚举变量的申明初始化和使用</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="built_in">enum</span> E_Player</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">main,</span><br><span class="line"></span><br><span class="line">other,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">E_Player e_Player = E_Player.main;</span><br></pre></td></tr></table></figure><h1 id="变量的类型及转换（显隐转换）"><a href="#变量的类型及转换（显隐转换）" class="headerlink" title="变量的类型及转换（显隐转换）"></a>变量的类型及转换（显隐转换）</h1><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有符号</span></span><br><span class="line"><span class="built_in">sbyte</span></span><br><span class="line"><span class="built_in">int</span></span><br><span class="line"><span class="built_in">short</span></span><br><span class="line"><span class="built_in">long</span></span><br><span class="line"><span class="built_in">float</span>      <span class="comment">//c#中初始化：float=数值f，f用于区别于double类型 例： float f = 123.45f</span></span><br><span class="line"><span class="built_in">double</span></span><br><span class="line"><span class="comment">//无符号</span></span><br><span class="line"><span class="built_in">byte</span></span><br><span class="line"><span class="built_in">uint</span></span><br><span class="line"><span class="built_in">ushort</span></span><br><span class="line"><span class="built_in">ulong</span></span><br><span class="line"><span class="comment">//特殊类型</span></span><br><span class="line"><span class="built_in">bool</span> <span class="comment">//装true 或 false</span></span><br><span class="line"><span class="built_in">char</span> <span class="comment">//字符 只能存一个字符</span></span><br><span class="line"><span class="built_in">string</span> <span class="comment">//字符串</span></span><br></pre></td></tr></table></figure><p><strong>隐式转换（直接等号转换）</strong></p><p>大范围包含小范围，基本相同大类型互相转换，特使类型中，char可以转换为int以外，bool和string都不能隐式转换</p><p><strong>显示转换</strong></p><h3 id="括号转换"><a href="#括号转换" class="headerlink" title="括号转换"></a><strong>括号转换</strong></h3><p><strong>1.变量名&#x3D;（转换类型）变量名；</strong></p><p>2 <strong>.bool</strong>和<strong>string</strong>不能通过括号转换强转</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x；</span><br><span class="line"><span class="built_in">long</span> y；</span><br><span class="line">x=（<span class="built_in">int</span>）y</span><br></pre></td></tr></table></figure><h3 id="Parse法-（把字符串类型转换为相应的类型）"><a href="#Parse法-（把字符串类型转换为相应的类型）" class="headerlink" title="Parse法 （把字符串类型转换为相应的类型）"></a><strong>Parse法</strong> （把字符串类型转换为相应的类型）</h3><p>（例如接受用户输入的字符串，将用户输入的字符串转换为相应的可以进行运算的数值）</p><p><strong>语法</strong>：<strong>变量类型.parse(“字符串”)</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="built_in">int</span>.parse(“<span class="number">123</span>”);</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> f = <span class="built_in">float</span>.parse(“<span class="number">123.45</span>”);</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> b = <span class="built_in">bool</span>.parse(“<span class="literal">true</span>”);</span><br><span class="line"></span><br><span class="line">console.write(<span class="built_in">int</span>.parse(“<span class="number">123</span>”));</span><br></pre></td></tr></table></figure><p>‍</p><p>注意：字符串必须能够转换成相应类型否则报错</p><h3 id="Convert法（更准确地将各个类型之间进行转换）"><a href="#Convert法（更准确地将各个类型之间进行转换）" class="headerlink" title="Convert法（更准确地将各个类型之间进行转换）"></a>Convert法（更准确地将各个类型之间进行转换）</h3><p><strong>语法： convert.To目标类型（变量或者常量）</strong></p><p><strong>例如：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = convert.ToInt32(“<span class="number">123</span>”); <span class="comment">//结果： 123</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> a = convert.ToInt32(<span class="number">1.692f</span>); <span class="comment">//(遵循四舍五入) 结果： 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> a = convert.ToInt32(<span class="literal">true</span>); <span class="comment">//（bool类型转int ）结果： 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> a = convert.ToInt32(“A”); <span class="comment">//字符类型转int 结果： 65</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">short</span> a = convert.ToInt16(“<span class="number">1</span>”);<span class="comment">//字符串类型转short，short对应的是int16</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">long</span> a = convert.ToInt64(“<span class="number">12</span>”); <span class="comment">//字符串类型转long型，long对应int64</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">byte</span> a = convert.ToByte(“<span class="number">3</span>”);</span><br><span class="line"></span><br><span class="line"><span class="built_in">uint</span> a = convert.ToUint32(“<span class="number">4</span>”); <span class="comment">//无符号类型的转换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> a = convert.ToSingle(“<span class="number">123.45</span>”); <span class="comment">//float对应single（单精度）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> a = convert.ToDouble(“<span class="number">123.45</span>”);<span class="comment">// double对应double（双精度）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> b = convert.ToBoolean(“<span class="literal">true</span>”); <span class="comment">//bool 对应 Boolean</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">char</span> a =convert.ToChar(“A”);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = convert.ToString(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><h3 id="其他类型转string"><a href="#其他类型转string" class="headerlink" title="其他类型转string"></a>其他类型转string</h3><p><strong>1.convert法：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">123</span>；</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = Convert.ToString(a);</span><br></pre></td></tr></table></figure><p><strong>2.toString法：</strong></p><p><strong>语法： 变量.toString();</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="number">1.</span>toString(); <span class="comment">//整型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = <span class="literal">true</span>.toString(); <span class="comment">//bool类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = <span class="number">123.45f</span>.toString(); <span class="comment">//浮点</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = “A”.toString(); <span class="comment">//字符</span></span><br></pre></td></tr></table></figure><p><strong>另一种写法</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Int a = <span class="number">6</span>；</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = a.toString();</span><br></pre></td></tr></table></figure><p><strong>在下面例子中，计算机用到了此方法进行转换</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(“<span class="number">12345</span>” + <span class="number">1</span> + <span class="literal">true</span> );</span><br></pre></td></tr></table></figure><h3 id="数组与数组之间的转换"><a href="#数组与数组之间的转换" class="headerlink" title="数组与数组之间的转换"></a>数组与数组之间的转换</h3><p>Array.ConvertAll&lt;转换的对象的元素类型，要转换为的元素类型&gt;(转换对象，转换方法)</p><p>语法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TInput 和 TOutput 分别是源数组和目标数组。</span></span><br><span class="line"><span class="comment">//array:一个从零开始的一维数组，用于转换为目标类型。</span></span><br><span class="line"><span class="comment">//converter:一个转换器，用于将每个元素从一种类型转换为另一种类型。 </span></span><br><span class="line"><span class="comment">//简单理解：ConvertAll方法就是遍历源数组中的每一个元素，执行一个转换函数（括号里的第二个参数），并返回新的数组。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TOutput[] <span class="title">ConvertAll</span>&lt;<span class="title">TInput</span>,<span class="title">TOutput</span>&gt; (<span class="params">TInput[] array, Converter&lt;TInput,TOutput&gt; converter</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//括号里面的第二个参数使用的lamda表达式。</span></span><br><span class="line"><span class="comment">//将int数组转换为字符数组</span></span><br><span class="line">  <span class="built_in">int</span>[] a = &#123; <span class="number">5</span>, <span class="number">4</span> &#125;;          </span><br><span class="line">  <span class="built_in">string</span>[] b = Array.ConvertAll&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;(a,num=&gt;num.ToString());</span><br><span class="line"><span class="comment">//将string数组转为int数组</span></span><br><span class="line">  <span class="built_in">string</span>[] str = &#123; <span class="string">&quot;123&quot;</span>, <span class="string">&quot;456&quot;</span> &#125;;</span><br><span class="line">  <span class="built_in">int</span>[] array = Array.ConvertAll&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt;(str, str =&gt; <span class="built_in">int</span>.Parse(str));</span><br><span class="line"><span class="comment">//遍历提取出自定义类型的属性值：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> &#123;</span><br><span class="line">      Person[] people = &#123;</span><br><span class="line">         <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;Aman&quot;</span> &#125;,</span><br><span class="line">         <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;Kumar&quot;</span> &#125;,</span><br><span class="line">         <span class="keyword">new</span> Person &#123; Name = <span class="string">&quot;Gupta&quot;</span> &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="comment">//遍历people源数组，执行person =&gt; person.Name函数，并返回一个string数组</span></span><br><span class="line">      <span class="built_in">string</span>[] names = Array.ConvertAll(people, person =&gt; person.Name);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Converted to names:&quot;</span>);</span><br><span class="line">      <span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> names) &#123;</span><br><span class="line">         Console.WriteLine(name);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h1><p><strong>作用</strong>：避免代码报错时出现的程序卡死。</p><p><strong>语法</strong>：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//必备部分</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//放需要进行异常捕获的代码块</span></span><br><span class="line"><span class="comment">//如果try中的代码块出错，会跳转到catch中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//必备部分</span></span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果出错，会执行catch中的代码来进行移除捕获</span></span><br><span class="line"><span class="comment">//catch后还可写为catch（Exception e）具体报错跟踪通过e得到具体的错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可选部分</span></span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//最后执行的代码块 不管出没出错都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(“请输入数字”)；</span><br><span class="line">String str = console,ReadLine();</span><br><span class="line">Int i = <span class="built_in">int</span>.parse(str);</span><br><span class="line">Console.WriteLine( i );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(“请输入合法数字”);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串拼接（非打印拼接）"><a href="#字符串拼接（非打印拼接）" class="headerlink" title="字符串拼接（非打印拼接）"></a>字符串拼接（非打印拼接）</h1><h3 id="1-字符串用＋号拼接"><a href="#1-字符串用＋号拼接" class="headerlink" title="1.字符串用＋号拼接"></a>1.字符串用＋号拼接</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="built_in">string</span> str = “<span class="number">123</span>”;</span><br><span class="line">str=str + “<span class="number">456</span>”;</span><br><span class="line">str=str + <span class="number">456</span>;       <span class="comment">//（456是整形，但是在这里默认调用了toString，将456转换为了字符串）</span></span><br><span class="line">str += “<span class="number">456</span>”+<span class="number">789</span>; 结果为<span class="number">123456789</span>  <span class="comment">//结果为123456789</span></span><br><span class="line"><span class="comment">//注意</span></span><br><span class="line">str += <span class="number">4</span>+<span class="number">5</span>+<span class="number">6</span>；   <span class="comment">//先算右侧结果，整型相加为15，接着再拼接，结果为12315</span></span><br><span class="line">str += “<span class="number">4</span>”+<span class="number">5</span>+<span class="number">6</span>；  <span class="comment">// 右侧式子从左到右运算，结果为123456，先将字符4和5进行拼接，然后依次进行拼接。</span></span><br><span class="line">Str += <span class="number">4</span>+<span class="number">5</span>+“”+<span class="number">6</span>； <span class="comment">//右侧式子为4+5=9，“”为空字符串，9+“”相当于将9转换为字符串，接着与6进行拼接，结果为12396</span></span><br><span class="line">Str = <span class="number">4</span>+<span class="number">5</span>+“”+（<span class="number">6</span>+<span class="number">7</span>） <span class="comment">//结果为123913</span></span><br></pre></td></tr></table></figure><h3 id="2-字符串占位拼接"><a href="#2-字符串占位拼接" class="headerlink" title="2.字符串占位拼接"></a>2.字符串占位拼接</h3><p><strong>语法： string.Format(“带拼接的内容{0}，带拼接的内容{1}，”，内容0，内容1);</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此句中，18是整型，但是调用了toString，也可填写true，123.45f等其他类型</span></span><br><span class="line">sring str = <span class="built_in">string</span>.Format(“我是&#123;<span class="number">0</span>&#125;，我今年&#123;<span class="number">1</span>&#125;，我想要&#123;<span class="number">2</span>&#125;”，“李明”，<span class="number">18</span>，“好好学习”)；</span><br></pre></td></tr></table></figure><h1 id="位运算符和三目运算符"><a href="#位运算符和三目运算符" class="headerlink" title="位运算符和三目运算符"></a>位运算符和三目运算符</h1><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位与 &amp; 两个位都为1时，结果才为1</p><p>位或 | 两个位都为0时，结果才为0</p><p>异或 ^ 两个位相同为0，相异为1</p><p>取反 ~ 0变1，1变0</p><p>左移 &lt;&lt; 各二进位全部左移若干位，高位丢弃，低位补0</p><p>右移 &gt;&gt; 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）</p><p>‍</p><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>‍</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  condition ? expression1 : expression2;</span></span><br><span class="line"><span class="comment">//  条件       ？ 为真返回值   ： 为假返回值</span></span><br><span class="line"> <span class="built_in">string</span> str = <span class="built_in">int</span> a&gt; <span class="built_in">int</span> b ? “大于” ：“小于”；</span><br><span class="line"> <span class="keyword">return</span> a&gt;b ? <span class="number">1</span> : <span class="number">-1</span> ;</span><br></pre></td></tr></table></figure><h1 id="C-中的数组"><a href="#C-中的数组" class="headerlink" title="C#中的数组"></a>C#中的数组</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//语法： 变量类型 [] 变量名</span></span><br><span class="line"><span class="comment">//写法1：</span></span><br><span class="line"><span class="built_in">int</span>[] arr1;</span><br><span class="line">arr1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//写法2：</span></span><br><span class="line"><span class="built_in">int</span>[] arr1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//写法3：</span></span><br><span class="line"><span class="built_in">int</span>[] arr1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//写法4：</span></span><br><span class="line"><span class="built_in">int</span>[] arr1 = <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,……&#125;；</span><br><span class="line"><span class="comment">//写法5：</span></span><br><span class="line"><span class="built_in">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,……&#125;；</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="built_in">int</span> arr[] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];<span class="comment">//申明了数组 </span></span><br><span class="line"> arr[<span class="number">1</span>]=<span class="number">1</span>; <span class="comment">//赋值</span></span><br><span class="line"> arr.Length<span class="comment">//获取数组长度：数组名 . Length </span></span><br><span class="line">console.WriteLine(arr.Length);<span class="comment">//打印数组长度 </span></span><br><span class="line"><span class="comment">//遍历数组：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt; arr1.Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组扩容：</span></span><br><span class="line"><span class="built_in">int</span>[] arr1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">int</span>[] arr2 = <span class="keyword">new</span> <span class="built_in">int</span> [<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;I&lt;arr1.Length;i++)</span><br><span class="line">&#123;</span><br><span class="line">arr2[i]=arr1[i];</span><br><span class="line">&#125;</span><br><span class="line">arr1=arr2; <span class="comment">//(将将arr1指向arr2数组，实现了arr1数组的扩容)</span></span><br><span class="line"><span class="comment">//缩容的话申请个较小的数组然后赋值后改指针指向</span></span><br></pre></td></tr></table></figure><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>语法： int[,] arr &#x3D; new int[2,3]{1,2,3,4,5,6};</p><p>写法和一维数组相同</p><p>使用：</p><p>获取数组长度</p><p>获取行长： arr1.GetLength（0）</p><p>获取列长： arr1.GetLength（1）</p><p>遍历二维数组：for（int i&#x3D;0；i&lt;arr1,GetLength(0);i++） &#x2F;&#x2F;行</p><p>{</p><p>For(int j&#x3D;0;j&lt;arr1.GetLength(1);j++) &#x2F;&#x2F;列</p><p>{</p><p>}</p><p>}</p><p>扩容二维数组：（和一维数组同一思想）</p><p>交错数组：</p><p>概念：装数组的数组，类似于指针数组；相当于二维数组，但是列长可以不一样</p><p>申明： 变量类型[][] <strong>变量名</strong>&#x3D; new 变量类型[交错数组长度][]{一维数组1，2，……}；</p><p>举例： int[][] array &#x3D; new int[3][]{ new int[]{1,2,3},</p><p>new int[]{4,5},</p><p>new int[]{7,8,9,10}};</p><p>获取长度 array.GetLength(0); 获取行长</p><p>array[i].GetLength(1); 获取某一列的长度</p><p>获取其中的元素 array[0][1] 获取第一行第二列的元素</p><p>遍历交错数组：</p><p>for (int i &#x3D; 0; i &lt;array.GetLength(0); i++)</p><p>{</p><p>for (int j &#x3D; 0; j &lt; array[i].Length; j++)</p><p>{</p><p>Console.Write(array3[i][j]+” “);</p><p>}</p><p>}</p><p>扩容交错数组：</p><p>和数组扩容同一原理</p><h1 id="值和引用（相当于c语言中的指针和值类型）"><a href="#值和引用（相当于c语言中的指针和值类型）" class="headerlink" title="值和引用（相当于c语言中的指针和值类型）"></a>值和引用（相当于c语言中的指针和值类型）</h1><ul><li><p><strong>引用类型：</strong></p><ul><li>string 、数组 、Class（类）</li><li><strong>在堆里申请的内存，在栈里存放的是地址）</strong></li><li>当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时<strong>并没有为其分配堆上的内存空间</strong>。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。</li></ul></li><li><p><strong>值类型：</strong></p><ul><li>除以上三种类型的其他类型( byte，short，int，long，float，double，decimal，char，bool 和 struct )</li><li><strong>（在栈里申请内存）</strong></li></ul></li></ul><p>由此可知</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//example 1</span></span><br><span class="line"><span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//arr存放的只是内存的地址</span></span><br><span class="line">arr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;   <span class="comment">// new代表新开辟的一个内存空间,初始化一块新的内存</span></span><br><span class="line"><span class="comment">//example 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>‍</p><h1 id="特殊的引用类型string"><a href="#特殊的引用类型string" class="headerlink" title="特殊的引用类型string"></a>特殊的引用类型string</h1><p>‍</p><p>​<code>string</code>​类型是不可变的字符串，一旦创建不能修改。<code>string</code>​类型在多次赋值时，会产生新的内存，将新的内容放在新的内存中，然后string存放新内存的地址，但是旧的内容的内存不会被回收，这样，多次给<code>string</code>​重新赋值时，会产生内存垃圾。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str1= “<span class="number">12345</span>”；</span><br><span class="line">str1=“<span class="number">123</span>”； <span class="comment">//重新赋值后，“12345”所占内存不会被回收。</span></span><br><span class="line"><span class="built_in">string</span> str2=str1； <span class="comment">// str2指向str1的内存</span></span><br><span class="line">Str2=“<span class="number">123456</span>”； <span class="comment">//str2重新赋值会重新开辟内存空间，不会修改str1的内容。</span></span><br></pre></td></tr></table></figure><p>所以当我们对string需要非常频繁地拼接或修改字符串时，会产生非常大的内存消耗。这时候我们可以选用 <code>StringBuilder</code>​ 类来进行操作。（需要引用命名空间 <code>using System.Text;</code>​ ）</p><p><code>StringBuilder</code>​ 是可变的字符串缓冲区，适合频繁拼接或修改字符串的情况。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="comment">//频繁地拼接或修改字符串时，用StringBuilder可以减少GC压力。</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    sb.Append(<span class="string">&quot;Item&quot;</span>).Append(i).Append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>‍</p><table><thead><tr><th>比较项</th><th>​<code>string</code>​</th><th>​<code>StringBuilder</code>​</th></tr></thead><tbody><tr><td><strong>是否可变</strong></td><td>❌ 不可变，每次修改都会创建新字符串</td><td>✅ 可变，修改不会创建新对象</td></tr><tr><td><strong>性能（频繁操作）</strong></td><td>❌ 较差：每次拼接都会生成新对象</td><td>✅ 较好：内部使用字符数组动态扩容</td></tr><tr><td><strong>内存效率</strong></td><td>❌ 差（频繁拼接会产生很多临时字符串）</td><td>✅ 高效（在原有缓存上操作）</td></tr><tr><td><strong>适用场景</strong></td><td>小量拼接、只读操作、配置读取、UI显示等</td><td>循环拼接、日志记录、大量字符串拼接场景</td></tr><tr><td><strong>线程安全</strong></td><td>✅ 线程安全（不可变）</td><td>❌ 默认不是线程安全的</td></tr><tr><td><strong>常用操作</strong></td><td>​<code>+</code>​、<code>Replace</code>​、<code>Substring</code>​等</td><td>​<code>Append</code>​、<code>Insert</code>​、<code>Replace</code>​、<code>Remove</code>​等</td></tr></tbody></table><p>‍</p><table><thead><tr><th>你要做的事<br /></th><th>推荐使用类型</th></tr></thead><tbody><tr><td>拼接几段字符串</td><td>​<code>string</code>​</td></tr><tr><td>循环中拼接字符串（如生成代码、日志）</td><td>​<code>StringBuilder</code>​</td></tr><tr><td>替换、截取少量字符串内容</td><td>​<code>string</code>​</td></tr><tr><td>对性能要求高的字符串处理</td><td>​<code>StringBuilder</code>​</td></tr></tbody></table><p>‍</p><h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><h2 id="深拷贝和浅拷贝详解"><a href="#深拷贝和浅拷贝详解" class="headerlink" title="深拷贝和浅拷贝详解"></a>深拷贝和浅拷贝详解</h2><ul><li>对于所有面向对象的语言，复制永远是一个容易引发讨论的题目，C#中也不例外。</li><li>深拷贝：指的是拷贝一个对象时，不仅仅把对象的引用进行复制，还把该对象引用的值也一起拷贝。这样进行深拷贝后的拷贝对象就和源对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。 <strong>（拷贝整个对象的内容，包括其内部引用指向的对象也会新建一份）</strong></li><li>浅拷贝：指的是拷贝一个对象时，仅仅拷贝对象的引用进行拷贝，但是拷贝对象和源对象还是引用同一份实体。 <strong>（拷贝对象的“引用”地址，新对象和原对象指向同一块内存。）</strong></li></ul><p>学习过上面的值类型和引用类型后，我们可以知道，<strong>值类型是深拷贝</strong>，是<strong>开辟了新的内存并复制了值</strong>。而<strong>引用类型存储的是值所在内存的地址</strong>，所以引用类型的复制只是复制了值所在的地址，<strong>并没有再新开辟一个内存把值复制进去</strong>。（要注意C#里的string类型是一个特殊的引用类型）</p><p>‍</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Person A = <span class="keyword">new</span> Person() &#123; Name = <span class="string">&quot;小李&quot;</span> &#125;;</span><br><span class="line">            Person B = A; <span class="comment">// 浅拷贝</span></span><br><span class="line">            B.Name = <span class="string">&quot;小黄&quot;</span>; <span class="comment">// 拷贝对象改变Name值</span></span><br><span class="line">            <span class="comment">// 结果都是&quot;小李&quot;,因为是浅拷贝，只是将A的值内存地址传递给了B，所以无论对B还是A进行修改，修改的都是同一个内存的值。</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Person.Name: [A: &#123;0&#125;] [B:&#123;1&#125;]&quot;</span>, A.Name, B.Name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>‍</p><h2 id="C-实现自定义对象或数据集合的深拷贝"><a href="#C-实现自定义对象或数据集合的深拷贝" class="headerlink" title="C#实现自定义对象或数据集合的深拷贝"></a>C#实现自定义对象或数据集合的深拷贝</h2><p>有时候我们需要创建一个对象副本，且修改对象副本不会改变源对象的数据，这就需要使用深拷贝。那么我们在C#如何让引用类型也能实现深拷贝呢？</p><h3 id="1-使用序列化和反序列化"><a href="#1-使用序列化和反序列化" class="headerlink" title="1.使用序列化和反序列化"></a>1.使用序列化和反序列化</h3><p>网上有许多使用 <code>BinaryFormatter</code>​ 进行序列化的方法，但是这个方法在NET 5及以上已被标记为不安全和过时，且有安全风险。现在我们会用 <code>System.Text.Json</code>​ 序列化来替代。记得引入命名空间 <code>using System.Text.Json;</code>​</p><p>在<code>.NET Core 3.0及以上版本</code>​中，可以使用<code>System.Text.Json</code>​库进行深拷贝。原理是使用<code>JsonSerializer.Serialize()</code>​将对象转换为Json字符串，再使用<code>JsonSerializer.Deserialize()</code>​将Json字符串转换为新的对象。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意：在Unity老版本不支持System.Text.Json进行序列化和反序列化，因为Unity老版本使用的是老版本.NET。</span></span><br><span class="line"><span class="comment">//例如我的Unity版本使用的是2020.3.28f1，使用的是NET Standard 2.0。</span></span><br><span class="line"><span class="comment">//查看你的Unity 使用的NET版本请在Unity里点击：ProjectSetting -&gt; Player -&gt; Other Settings，在里面翻一翻，可以看到 NET XXX。</span></span><br><span class="line"><span class="comment">//所以如果想在Unity使用序列化，请了解使用: XML，JsonUtility，Newtonsoft.Json，LitJson等。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Text.Json;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用System.Text.Json不需要[Serializable] 特性，这一点和BinaryFormatter不同。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyComplexObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="comment">// 其他属性</span></span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对象深拷贝扩展方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DeepCopier</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//深拷贝方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">DeepCopy</span>&lt;<span class="title">T</span>&gt;(<span class="params">T obj</span>)</span></span><br><span class="line">&#123;<span class="comment">//序列化</span></span><br><span class="line">    <span class="built_in">string</span> json = JsonSerializer.Serialize(obj);</span><br><span class="line"><span class="comment">//反序列化</span></span><br><span class="line">    <span class="keyword">return</span> JsonSerializer.Deserialize&lt;T&gt;(json);</span><br><span class="line"><span class="comment">//原理：通过序列化源对象和反序列化创建了个新的副本对象返回。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用示例：</span></span><br><span class="line">MyComplexObject original = <span class="keyword">new</span> MyComplexObject &#123; Id = <span class="number">1</span>, Name = <span class="string">&quot;Test&quot;</span> &#125;;</span><br><span class="line">MyComplexObject copy = DeepCopier.DeepCopy(original);</span><br><span class="line"><span class="comment">// 修改原对象不会影响 copy</span></span><br><span class="line">original.Name = <span class="string">&quot;Changed&quot;</span>;</span><br><span class="line">Console.WriteLine(copy.Name); <span class="comment">// 输出 &quot;Test&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-使用Newtonsoft-Json"><a href="#2-使用Newtonsoft-Json" class="headerlink" title="2.使用Newtonsoft.Json"></a>2.使用Newtonsoft.Json</h3><p>‍</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">‍</span><br><span class="line"></span><br><span class="line"><span class="meta">### 3.实现 `ICloneable`​ 接口 + 自定义 `Clone()`​</span></span><br><span class="line"></span><br><span class="line">‍</span><br><span class="line"></span><br><span class="line"><span class="meta">### 4.使用 `MemberwiseClone()`​</span></span><br><span class="line"></span><br><span class="line">‍</span><br><span class="line"></span><br><span class="line"><span class="meta">### 5.使用第三方库（推荐 AutoMapper）</span></span><br><span class="line"></span><br><span class="line">‍</span><br><span class="line"></span><br><span class="line"><span class="meta">### 6.使用表达树</span></span><br><span class="line"></span><br><span class="line">‍</span><br><span class="line"></span><br><span class="line">**为什么要使用深拷贝？**   </span><br><span class="line">​`深拷贝是一种保持数据独立性和完整性的重要手段，在许多场景下都是不可或缺的操作。 `​使用深拷贝的原因主要有以下几点：</span><br><span class="line"></span><br><span class="line">- 独立性：深拷贝创建的是一个完全独立的副本，对副本的操作不会影响原始数据，这在一些场景中非常重要，比如数据备份、多线程编程等。</span><br><span class="line">- 安全性：通过深拷贝，可以避免意外修改原始数据，从而提高代码的安全性和稳定性。</span><br><span class="line">- 可复用性：深拷贝后的副本可以独立使用和修改，方便代码的复用和模块化开发。</span><br><span class="line">- 隔离性：在一些复杂的数据结构中，深拷贝可以确保不同部分的数据相互隔离，避免不必要的关联和影响。</span><br><span class="line">- 性能优化：对于一些需要频繁修改数据的场景，使用深拷贝可以避免不必要的共享和同步操作，提高程序的性能。</span><br><span class="line"></span><br><span class="line">应用场景：</span><br><span class="line"></span><br><span class="line">无论是浅拷贝还是深拷贝，一般都用于操作Object 或 Array之类的复合类型。</span><br><span class="line"></span><br><span class="line">- **数据备份和恢复**：在进行数据备份时，使用深拷贝可以创建数据的完整副本，以便在需要时进行恢复。</span><br><span class="line"></span><br><span class="line">- **对象复制和克隆**：当需要创建一个对象的副本时，深拷贝可以确保副本与原始对象完全独立，不会相互影响。</span><br><span class="line"></span><br><span class="line">- **多线程编程**：在多线程环境下，深拷贝可以避免多个线程同时修改同一个对象导致的竞态条件。</span><br><span class="line">- **数据传递和共享**：将数据通过深拷贝传递给其他模块或进程，可以确保数据的独立性和完整性。</span><br><span class="line">- **缓存和数据持久化**：深拷贝可以用于缓存数据或将数据持久化到存储介质中，以提高性能和数据的可用性。</span><br><span class="line">- **测试和模拟**：在测试代码中，深拷贝可以用于创建测试数据的副本，以便进行各种测试和模拟。</span><br><span class="line"></span><br><span class="line">其他参考：</span><br><span class="line"></span><br><span class="line">[<span class="meta">C#|.net core 基础 - 深拷贝的五大类N种实现方式</span>](https:<span class="comment">//blog.csdn.net/zhulianfang1991/article/details/142421562#:~:text=C%23%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%A4%8D%E6%9D%82%EF%BC%8C%E6%96%87%E4%B8%AD%E4%BB%8B%E7%BB%8D%E4%BA%86%E4%BA%94%E5%A4%A7%E7%B1%BBN%E7%A7%8D%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95%EF%BC%8C%E5%8C%85%E6%8B%AC%E7%AE%80%E5%8D%95%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E3%80%81%E6%89%8B%E5%8A%A8%E6%96%B9%E5%BC%8F%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F%E3%80%81%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%96%B9%E5%BC%8F%E5%92%8C%E6%89%A9%E5%B1%95%E8%A7%86%E9%87%8E%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%B9%B6%E5%AF%B9%E6%AF%94%E4%BA%86%E6%80%A7%E8%83%BD%E3%80%82%20%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8AutoMapper%E5%92%8CDeepCloner%E7%AD%89%E6%88%90%E7%86%9F%E5%BA%93%E6%88%96%E6%A0%B9%E6%8D%AE%E6%80%A7%E8%83%BD%E9%9C%80%E6%B1%82%E9%80%89%E6%8B%A9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E5%92%8CEmit%E3%80%82,_c%23%20%E6%B7%B1%E6%8B%B7%E8%B4%9D)</span></span><br><span class="line"></span><br><span class="line">[深拷贝：概念、使用原因、应用场景、<span class="number">3</span>种常用方法](https:<span class="comment">//blog.csdn.net/cuclife/article/details/136453132)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># C#函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">### 函数的基本知识</span></span><br><span class="line"></span><br><span class="line">- 函数名使用帕斯卡写法，即每个单词首字母大写</span><br><span class="line"></span><br><span class="line">- 函数的调用： 函数名（参数）； 有返回值则用可用返回类型接收</span><br><span class="line"></span><br><span class="line">- 返回多个值：用数组类型</span><br><span class="line"></span><br><span class="line">函数写在<span class="keyword">class</span>、<span class="title">struct</span>语句块中写法：</span><br><span class="line"></span><br><span class="line">```<span class="title">C</span>#</span><br><span class="line"><span class="title">Static</span> <span class="title">void</span>/其他类型 函数名（变量类型参数1，2，……）</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//函数代码逻辑</span></span><br><span class="line"><span class="keyword">return</span> 返回值（如有返回值才返回）</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayhello</span>(<span class="params"><span class="built_in">string</span> str</span>) <span class="comment">//无返回类型有参数</span></span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">sayhello</span>(<span class="params"><span class="built_in">string</span> str</span>) <span class="comment">//有返回有参数</span></span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">sayhello</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数举例：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span>[] <span class="title">sayhello</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> sum = a + b;</span><br><span class="line"><span class="built_in">int</span> avg = (a + b) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">int</span>[] arr = &#123; sum,avg &#125;;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>return</code>​：</p><ul><li><p>对于有返回值的函数，return需要返回函数声明的返回值类型的值。</p></li><li><p>对于无返回值函数，单独一个 <code>return </code>​可以直接返回函数外部，后面的代码不执行。</p></li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">speak</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a+b&gt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">//注意：当返回类型为void时才可以使用return直接返回中止。</span></span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(a + b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">speak</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a+b&gt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> c = a+b;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;和为：&quot;</span> + c;</span><br><span class="line"><span class="keyword">return</span> str; <span class="comment">//注意：当返回类型为void时才可以使用return直接返回中止。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ref和out（用于函数形参和实参的传递）"><a href="#ref和out（用于函数形参和实参的传递）" class="headerlink" title="ref和out（用于函数形参和实参的传递）"></a>ref和out（用于函数形参和实参的传递）</h3><p><strong>作用：</strong></p><ul><li>当传入函数参数时，如果为值类型，在函数内修改形参不会改变实参。</li><li>若使用 <code>ref</code>​ 或 <code>out</code>​，则<strong>函数内的修改会影响函数外的实参</strong>。</li></ul><p><strong>语法：</strong>  在传入参数前加<code>ref</code>​或<code>out</code>​</p><p><strong>例子：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeVertex</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> a, <span class="keyword">ref</span> <span class="built_in">int</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> c;</span><br><span class="line">    c = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">int</span> b = <span class="number">4</span>;</span><br><span class="line">    ChangeVertex(<span class="keyword">ref</span> a, <span class="keyword">ref</span> b);</span><br><span class="line">    Console.WriteLine(a + <span class="string">&quot; &quot;</span> + b);  <span class="comment">// 输出：4 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>Ref和out的区别</strong></p><table><thead><tr><th>区别点</th><th>​<code>ref</code>​</th><th>​<code>out</code>​</th></tr></thead><tbody><tr><td>调用前是否必须赋值</td><td>✅ 必须在调用前初始化</td><td>❌ 不需要在调用前初始化</td></tr><tr><td>方法内是否必须赋值</td><td>❌ 不强制赋值</td><td>✅ 方法内部<strong>必须赋值</strong>，否则编译错误</td></tr><tr><td>场景</td><td>双向传值</td><td>单向输出结果</td></tr></tbody></table><p>‍</p><p>​<strong>​<code>Out</code>​</strong>​<strong>示例：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeVertexO</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> a, <span class="keyword">out</span> <span class="built_in">int</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    a = <span class="number">5</span>;  <span class="comment">// 内部必须赋值</span></span><br><span class="line">    b = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a;</span><br><span class="line">    <span class="built_in">int</span> b;</span><br><span class="line">    ChangeVertexO(<span class="keyword">out</span> a, <span class="keyword">out</span> b);</span><br><span class="line">    Console.WriteLine(a + <span class="string">&quot; &quot;</span> + b);  <span class="comment">// 输出：5 6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​<strong>​<code>ref</code>​</strong>​ <strong>示例</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeVertex</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> a, <span class="keyword">ref</span> <span class="built_in">int</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> c;</span><br><span class="line">    c = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">int</span> b = <span class="number">4</span>;</span><br><span class="line">    ChangeVertex(<span class="keyword">ref</span> a, <span class="keyword">ref</span> b);</span><br><span class="line">    Console.WriteLine(a + <span class="string">&quot; &quot;</span> + b);  <span class="comment">// 输出：4 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变长和参数默认值："><a href="#变长和参数默认值：" class="headerlink" title="变长和参数默认值："></a>变长和参数默认值：</h3><h4 id="变长参数（可变参数）"><a href="#变长参数（可变参数）" class="headerlink" title="变长参数（可变参数）"></a>变长参数（可变参数）</h4><ul><li><strong>关键字：</strong>  <code>params</code>​</li><li><strong>语法：</strong></li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> 返回类型 函数名(<span class="keyword">params</span> 类型[] 数组名)</span><br></pre></td></tr></table></figure><ul><li><p><strong>注意事项：</strong></p><ul><li>​<code>params</code>​ 修饰的参数<strong>必须是最后一个参数</strong>。</li><li>它前面<strong>可以有其他参数</strong>，但<strong>后面不能再有其他参数</strong>，否则编译报错。</li></ul></li></ul><p>示例：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Text</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[] a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; a.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用示例：</strong></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> result = Text(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure><p>‍</p><h4 id="参数默认值（可选参数）"><a href="#参数默认值（可选参数）" class="headerlink" title="参数默认值（可选参数）"></a>参数默认值（可选参数）</h4><p><strong>什么是参数默认值？</strong></p><p>当函数参数设置了默认值，即可在调用函数时<strong>选择是否传入对应实参</strong>，如果不传入，则会使用默认值。</p><p><strong>示例代码：</strong></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">string</span> str = <span class="string">&quot;我什么也不想说&quot;</span></span>) <span class="comment">// 设置默认值</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用方式：</strong></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Speak();                      <span class="comment">// 输出：我什么也不想说</span></span><br><span class="line">Speak(<span class="string">&quot;那我就说几句&quot;</span>);        <span class="comment">// 输出：那我就说几句</span></span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li><strong>可选参数必须放在参数列表的最前面。</strong></li><li>因为如果默认值参数在前，调用函数时会发生<strong>实参与形参匹配不明确的问题</strong>。</li></ul><p><strong>示例代码：</strong></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Text</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b =<span class="number">1</span>,<span class="built_in">int</span> c=<span class="number">5</span>;<span class="built_in">int</span> d=<span class="number">6</span></span>)<span class="comment">//可选参数放后面</span></span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//错误示例：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Text</span>(<span class="params"><span class="built_in">int</span> a =<span class="number">1</span>, <span class="built_in">int</span> b = <span class="number">2</span>, <span class="built_in">int</span> c</span>)<span class="comment">//未将可选参数都放后面</span></span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>函数重载：</p><ul><li><p>重载允许在同一作用域内定义多个同名函数。</p></li><li><p>具有相同函数名的函数，但是参数的类型、个数或者顺序不同的函数，叫做函数重载。</p></li><li><p>返回值与函数重载无关，即返回值可相同可不同，但是传入参数的类型、个数或者顺序要有一个不同。</p></li><li><p>函数重载注意用于处理不同参数同一类型的逻辑处理</p></li></ul><p>举例：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这三个函数的函数名相同，但是参数的个数和顺序或者类型不同，所以这三个函数重载。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b, <span class="built_in">int</span> c=<span class="number">5</span>,<span class="built_in">int</span> d=<span class="number">3</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">float</span> <span class="title">Test</span>(<span class="params"><span class="built_in">float</span> a,<span class="built_in">int</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">float</span> c = a + b;</span><br><span class="line"><span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">float</span> <span class="title">Test</span>(<span class="params"><span class="built_in">float</span> a, <span class="built_in">float</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//params（变长参数）也可用于函数重载</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CompareVertex</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[] a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; a.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;a[index])</span><br><span class="line">&#123;</span><br><span class="line">index = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">float</span> <span class="title">CompareVertex</span>(<span class="params"><span class="built_in">float</span> a, <span class="built_in">float</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>递归函数：就是让函数自己调用自己。</p><p>条件：一个正确的递归函数，必须有结束条件，这个条件必须是根据循环的次数改变而改变的，否则就会陷入无限循环。</p><p><strong>普通举例：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test_DiGui</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;二哈！！！过来&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">Test_DiGui(a - <span class="number">1</span>); <span class="comment">//递归函数自我调用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">//打印a次字符串</span></span><br></pre></td></tr></table></figure><p><strong>遍历目录示例：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> rootPath = <span class="string">@&quot;C:\Example\MyFolder&quot;</span>; <span class="comment">// 设置你要遍历的根目录</span></span><br><span class="line">        TraverseDirectory(rootPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TraverseDirectory</span>(<span class="params"><span class="built_in">string</span> path</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印当前目录路径</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;目录：&quot;</span> + path);</span><br><span class="line">        <span class="comment">// 遍历文件</span></span><br><span class="line">        <span class="built_in">string</span>[] files = Directory.GetFiles(path);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> <span class="keyword">file</span> <span class="keyword">in</span> files)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;文件：&quot;</span> + Path.GetFileName(<span class="keyword">file</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历子目录（并递归调用）</span></span><br><span class="line">        <span class="built_in">string</span>[] directories = Directory.GetDirectories(path);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> dir <span class="keyword">in</span> directories)</span><br><span class="line">        &#123;</span><br><span class="line">            TraverseDirectory(dir); <span class="comment">// 递归调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="C-结构体"><a href="#C-结构体" class="headerlink" title="C#结构体"></a>C#结构体</h1><p>结构体是一种<code>自定义的变量类型</code>​，他是<code>数据和函数的集合</code>​，在结构体中可以申明各种变量和方法（函数）</p><p><strong>作用：</strong> 用来表现存在关系的数据集合，比如结构体表现学生、怪物、动物等</p><p><strong>基本语法：</strong></p><ul><li>结构体一般写在<code>namespace</code>​空间里，且里面的变量和函数默认为<code>private</code>​类型</li><li>如果想要外部调用，要在前加<code>public</code>​。函数在结构体里不用加<code>static</code>​。结构体里还可以写构造函数。</li></ul><p>}</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Struct 结构体名</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> age；</span><br><span class="line"><span class="comment">//…… ……</span></span><br><span class="line"><span class="keyword">void</span> 函数名（）</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//…… ……</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">bool</span> sex;</span><br><span class="line"><span class="built_in">enum</span> E_sex</span><br><span class="line">&#123;</span><br><span class="line">男生,</span><br><span class="line">女生</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> name,<span class="built_in">int</span> age,<span class="built_in">bool</span> sex</span>) <span class="comment">//构造函数，其中this表示自己的参数</span></span></span><br><span class="line">&#123; <span class="comment">//因为传入参数名称和外部变量名称相 同，所以用this来表示这个变量为 结构体自己的参数。</span></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;我是&#123;0&#125;,我今年&#123;1&#125;岁，我是&#123;2&#125;&quot;</span>,name,age,(E_sex) Convert.ToInt32(sex));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//结构体初始化方法一:</span></span><br><span class="line">Student s1;</span><br><span class="line">s1.age = <span class="number">18</span>;</span><br><span class="line">s1.name = <span class="string">&quot;林语馨&quot;</span>;</span><br><span class="line">s1.sex = <span class="literal">true</span>;</span><br><span class="line">s1.speak();</span><br><span class="line"><span class="comment">//方法二:</span></span><br><span class="line">Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;林雨馨&quot;</span>,<span class="number">18</span>,<span class="literal">true</span>); <span class="comment">//对结构体内的变量统一赋值。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubble Sort）是一种简单的排序算法，它通过重复地遍历待排序的列表，比较相邻的元素并交换它们的位置来实现排序。该算法的名称来源于较小的元素会像”气泡”一样逐渐”浮”到列表的顶端。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li><strong>比较相邻元素</strong>：从列表的第一个元素开始，比较相邻的两个元素。</li><li><strong>交换位置</strong>：如果前一个元素比后一个元素大，则交换它们的位置。</li><li><strong>重复遍历</strong>：对列表中的每一对相邻元素重复上述步骤，直到列表的末尾。这样，最大的元素会被”冒泡”到列表的最后。</li><li><strong>缩小范围</strong>：忽略已经排序好的最后一个元素，重复上述步骤，直到整个列表排序完成。</li></ol><h3 id="原理说明："><a href="#原理说明：" class="headerlink" title="原理说明："></a>原理说明：</h3><p>设数组元素个数为 <code>n</code>​，从数组下标为 0 的元素开始，每次<strong>两两比较相邻元素</strong>，把较大的（或较小的）元素“冒泡”移动到后面。</p><ul><li><strong>第一轮比较 n-1 次</strong></li><li><strong>第二轮比较 n-2 次</strong></li><li>……</li><li><strong>第 n-1 轮比较 1 次</strong></li></ul><p>在第 <code>x</code>​ 轮中，后面的元素已经排好，无需再次比较，因此每轮的比较次数会逐渐减少。</p><table><thead><tr><th>第几轮（x）</th><th>比较次数（m-x）</th></tr></thead><tbody><tr><td>第 1 轮</td><td>m - 1</td></tr><tr><td>第 2 轮</td><td>m - 2</td></tr><tr><td>第 3 轮</td><td>m - 3</td></tr><tr><td>…</td><td>…</td></tr><tr><td>第 n 轮</td><td>m - n = 0</td></tr></tbody></table><p>说明：<strong>m</strong>  <strong>&#x3D;</strong>  <strong>数组长度</strong></p><h3 id="循环结构说明："><a href="#循环结构说明：" class="headerlink" title="循环结构说明："></a>循环结构说明：</h3><p>冒泡排序中包含两层 <code>for</code>​ 循环：</p><h4 id="外层循环：控制“轮数”"><a href="#外层循环：控制“轮数”" class="headerlink" title="外层循环：控制“轮数”"></a>外层循环：控制“轮数”</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length - <span class="number">1</span>; i++)</span><br></pre></td></tr></table></figure><ul><li>从第 0 轮开始</li><li>共进行 <code>n - 1</code>​ 轮</li></ul><h4 id="内层循环：每轮中的“两两比较”"><a href="#内层循环：每轮中的“两两比较”" class="headerlink" title="内层循环：每轮中的“两两比较”"></a>内层循环：每轮中的“两两比较”</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; arr.Length - <span class="number">1</span> - i; j++)</span><br></pre></td></tr></table></figure><ul><li>比较相邻两个元素 <code>arr[j]</code>​ 和 <code>arr[j+1]</code>​</li><li>若顺序不对则交换</li></ul><h3 id="C-实现冒泡排序："><a href="#C-实现冒泡排序：" class="headerlink" title="C#实现冒泡排序："></a>C#<strong>实现冒泡排序：</strong></h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//降序排序（从大到小）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; arr.Length - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j + <span class="number">1</span>] &gt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> temp;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//升序排序（从小到大）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; arr.Length - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> temp;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p><strong>优点</strong>：</p><ul><li>实现简单，代码易于理解。</li><li>原地排序，不需要额外的存储空间。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>效率较低，尤其是对于大规模数据集。</li><li>不适合处理几乎已经有序的列表，因为仍然需要进行多次遍历。</li></ul></li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="什么是选择排序"><a href="#什么是选择排序" class="headerlink" title="什么是选择排序"></a>什么是选择排序</h3><p>选择排序基本思想是每次从待排序的数据中选择最小（或最大）的元素，放到已排序序列的末尾，直到全部数据排序完成。</p><h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li><strong>初始化</strong>：将列表分为已排序部分和未排序部分。初始时，已排序部分为空，未排序部分为整个列表。</li><li><strong>查找最小值</strong>：在未排序部分中查找最小的元素。</li><li><strong>交换位置</strong>：将找到的最小元素与未排序部分的第一个元素交换位置。</li><li><strong>更新范围</strong>：将未排序部分的起始位置向后移动一位，扩大已排序部分的范围。</li><li><strong>重复步骤</strong>：重复上述步骤，直到未排序部分为空，列表完全有序。</li></ol><p>‍</p><p>设数组长度为 <code>n</code>​，排序过程如下：</p><ol><li>第1轮：从下标 <code>0~n-1</code>​ 中找到最小值，放到第0位；</li><li>第2轮：从下标 <code>1~n-1</code>​ 中找到最小值，放到第1位；</li><li>…</li><li>第n-1轮：只剩一个元素，已自动排好。</li></ol><p>‍</p><p>假设原数组为：[<strong>64, 25, 12, 22, 11</strong>]</p><table><thead><tr><th>轮次</th><th>当前数组状态</th><th>操作说明</th></tr></thead><tbody><tr><td>第1轮</td><td>[64, 25, 12, 22,<strong>11</strong>]</td><td>找到最小值11，和64交换</td></tr><tr><td></td><td>[11, 25, 12, 22, 64]</td><td></td></tr><tr><td>第2轮</td><td>[11, 25,<strong>12</strong>, 22, 64]</td><td>找到12，和25交换</td></tr><tr><td></td><td>[11, 12, 25, 22, 64]</td><td></td></tr><tr><td>第3轮</td><td>[11, 12, 25,<strong>22</strong>, 64]</td><td>找到22，和25交换</td></tr><tr><td></td><td>[11, 12, 22, 25, 64]</td><td></td></tr><tr><td>第4轮</td><td>[11, 12, 22, 25, 64]</td><td>已排好</td></tr></tbody></table><p>‍</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序（从小到大）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectionSort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> n = arr.Length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 假设当前位置 i 是最小值索引</span></span><br><span class="line">            <span class="built_in">int</span> minIndex = i;</span><br><span class="line">            <span class="comment">// 遍历后面的元素，寻找更小值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[minIndex])</span><br><span class="line">                &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果找到更小值，进行交换</span></span><br><span class="line">            <span class="keyword">if</span> (minIndex != i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[minIndex];</span><br><span class="line">                arr[minIndex] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] data = &#123; <span class="number">64</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span> &#125;;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;原始数组： &quot;</span> + <span class="built_in">string</span>.Join(<span class="string">&quot;, &quot;</span>, data));</span><br><span class="line">        SelectionSort(data);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;排序后：   &quot;</span> + <span class="built_in">string</span>.Join(<span class="string">&quot;, &quot;</span>, data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>‍</p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li><p><strong>优点</strong>：</p><ul><li>实现简单，代码易于理解。</li><li>原地排序，不需要额外的存储空间。</li><li>对于小规模数据集，性能尚可接受。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>时间复杂度较高，不适合大规模数据集。</li><li>不稳定排序算法（如果存在相同元素，可能会改变它们的相对顺序）。</li></ul></li></ul><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>面向对象关键知识：</p><ul><li>类（class）</li></ul><p>面向对象三大特征</p><ul><li>​<code>封装：</code>​用程序语言来形容对象</li><li>​<code>继承：</code>​复用封装对象的代码：儿子继承父亲，复用现成代码。</li><li>​<code>多态：</code>​同样行为的不同表现，儿子继承父亲但是有不同的行为表现。</li></ul><p>面向对象七大原则</p><ul><li>开闭原则</li><li>依赖倒转原则</li><li>里氏替换原则</li><li>第一职责原则</li><li>接口隔离原则</li><li>合成复用原则</li><li>迪米特法则</li></ul><h2 id="类和（类）对象"><a href="#类和（类）对象" class="headerlink" title="类和（类）对象"></a>类和（类）对象</h2><h3 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h3><ul><li><p><strong>类的定义：</strong> 具有相同特性和行为的对象组成的集合就是类。<strong>类是对象的抽象，对象是类的具体实例。</strong> 比如你要买一辆车，车有品牌，排量，颜色，款式，这时车就是类，而当你看中了一个品牌，排列，颜色，款式确定的一款车时，这个车就是类的实例。</p></li><li><p>类是一个引用类型；</p></li><li><p>类的声明一般声明在<code>namespace</code>​空间中，而不是定义在 <code>class Program</code>​ 里。在类中申明类是类的内部类。</p></li></ul><h3 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">访问修饰符 Class 类名</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//特征——成员变量</span></span><br><span class="line"><span class="comment">//行为——成员方法</span></span><br><span class="line"><span class="comment">//保护特征——成员属性</span></span><br><span class="line"><span class="comment">//构造函数和析构函数</span></span><br><span class="line"><span class="comment">//索引器</span></span><br><span class="line"><span class="comment">//运算符重载</span></span><br><span class="line"><span class="comment">//静态成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类声明实例"><a href="#类声明实例" class="headerlink" title="类声明实例"></a>类声明实例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Class Person <span class="comment">//人类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">int</span> age;</span><br><span class="line"><span class="built_in">int</span> sex;<span class="comment">//假设0为女,1为男</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Class Machine <span class="comment">//机器类</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（类）对象"><a href="#（类）对象" class="headerlink" title="（类）对象"></a><strong>（类）对象</strong></h3><ul><li><p>类的申明相当于申明了一个自定义变量类型。</p></li><li><p>（类）对象的申明是相当于申明了一个指定类的对象。</p></li><li><p>类创建对象的过程，一般称为实例化对象。</p></li><li><p>（类）对象是引用类型。</p></li><li><p>引用类型是在栈上申请了一个内存，存放地址，new后在堆上申请空间，将地址存在栈上。</p></li></ul><h3 id="对象的申明："><a href="#对象的申明：" class="headerlink" title="对象的申明："></a><strong>对象的申明：</strong></h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">类名 变量名;<span class="comment">//声明变量但不初始化。类成员的引用类型变量如果没初始化，会自动是 null。</span></span><br><span class="line">类名 变量名=<span class="literal">null</span>;<span class="comment">//声明变量，并显式赋值为 null。</span></span><br><span class="line">类名 变量名=<span class="keyword">new</span> 类名();<span class="comment">//声明变量并创建一个新的对象实例。</span></span><br></pre></td></tr></table></figure><p>三种声明方法对比</p><table><thead><tr><th>写法</th><th>是否赋值</th><th>是否可以使用变量</th><th>是否分配内存</th></tr></thead><tbody><tr><td>​<code>Person p;</code>​</td><td>❌</td><td>❌ 编译错误</td><td>❌</td></tr><tr><td>​<code>Person p = null;</code>​</td><td>✅ null</td><td>❌ 运行时错误</td><td>❌</td></tr><tr><td>​<code>Person p = new Person();</code>​</td><td>✅ 实例</td><td>✅ 正常使用</td><td>✅</td></tr></tbody></table><p>实践建议</p><table><thead><tr><th>场景</th><th>推荐写法</th></tr></thead><tbody><tr><td>延迟初始化</td><td>​<code>Person p = null;</code>​</td></tr><tr><td>立即使用</td><td>​<code>Person p = new Person();</code>​</td></tr><tr><td>先声明，后赋值（临时变量）</td><td>​<code>Person p;</code>​，但马上赋值</td></tr></tbody></table><h3 id="实例化对象："><a href="#实例化对象：" class="headerlink" title="实例化对象："></a><strong>实例化对象：</strong></h3><p><strong>假设申明了一个Person类。</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line">Person P1;</span><br><span class="line">P1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">Person P2=<span class="literal">null</span>;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">Person P3=<span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><h2 id="成员变量和访问修饰符"><a href="#成员变量和访问修饰符" class="headerlink" title="成员变量和访问修饰符"></a>成员变量和访问修饰符</h2><h3 id="C-访问修饰符："><a href="#C-访问修饰符：" class="headerlink" title="C#访问修饰符："></a>C#访问修饰符：</h3><table><thead><tr><th>修饰符</th><th>可访问范围</th><th>应用场景常用位置</th><th>示例</th></tr></thead><tbody><tr><td>​<code>public</code>​</td><td>任何地方都可访问</td><td>类、成员、属性、方法</td><td>​<code>public class Person &#123; public string Name; &#125;</code>​</td></tr><tr><td>​<code>private</code>​</td><td>仅在<strong>当前类内部</strong>可访问</td><td>类内部成员、字段</td><td>​<code>private int age;</code>​</td></tr><tr><td>​<code>protected</code>​</td><td><strong>当前类</strong>及其<strong>派生类（子类）</strong> 中可访问</td><td>继承场景的成员字段</td><td>​<code>protected string password;</code>​</td></tr><tr><td>​<code>internal</code>​</td><td>当前项目（程序集）中可访问</td><td>库组件、模块间通讯</td><td>​<code>internal class Utils &#123; ... &#125;</code>​</td></tr><tr><td>​<code>protected internal</code>​</td><td>当前<strong>程序集</strong>或子类（无论在不在当前程序集）中可访问</td><td>跨项目但需要继承支持时使用</td><td>​<code>protected internal void Log() &#123;&#125;</code>​</td></tr></tbody></table><h3 id="类里的成员变量："><a href="#类里的成员变量：" class="headerlink" title="类里的成员变量："></a>类里的成员变量：</h3><p>‍</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注：成员变量声明后可赋值，与结构体不同。</span></span><br><span class="line">访问修饰符 Class 类名</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//特征——成员变量</span></span><br><span class="line"><span class="comment">//行为——成员方法</span></span><br><span class="line"><span class="comment">//保护特征——成员属性</span></span><br><span class="line"><span class="comment">//构造函数和析构函数</span></span><br><span class="line"><span class="comment">//索引器</span></span><br><span class="line"><span class="comment">//运算符重载</span></span><br><span class="line"><span class="comment">//静态成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>‍</p><p>类里面可以声明自己类的对象（变量），例如：</p><p>‍</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> Int age;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> Bool sex;</span><br><span class="line"><span class="keyword">public</span> Person girlfriend; <span class="comment">//在类中申明类变量，注意不要用new创建实例。</span></span><br><span class="line"><span class="keyword">public</span> Person[] friend=<span class="literal">null</span>;<span class="comment">//可赋值null，但是不能new；否则循环。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例化一个对象语法： Person p1=new Person();</span></span><br></pre></td></tr></table></figure><p>注：</p><ol><li>如果在类中对（类）对象进行new（构造成员变量）—— Public Person girlfriend&#x3D;new Person（）；则会使类进行无限递归，而爆掉内存。</li><li>类中的成员变量会有默认值，例如，值类型默认值：int默认值为0；，bool为false等。引用类型都是空（NULL）</li><li>看默认值小技巧Console.WriteLine(default(变量))</li></ol><p>‍</p><h2 id="成员方法（函数）："><a href="#成员方法（函数）：" class="headerlink" title="成员方法（函数）："></a>成员方法（函数）：</h2><p><strong>成员方法</strong>（函数），用来表现对象行为，申明在类语句块中，规则和函数申明规则一致，可受访问修饰符影响，</p><p><strong>1.成员方法不要加static</strong></p><p><strong>2.成员方法必须实例化出对象，再通过对象来使用，相当于该对象执行了某个行为，</strong></p><p><strong>3.成员方法受访问修饰符影响</strong></p><p><strong>如果成员方法前加staic：</strong></p><p>在C#程序中，当你在一个类中将方法声明为静态（static）时，意味着该方法不属于任何特定的实例对象，而是属于整个类本身。这意味着你可以直接通过类名来访问该静态方法，而不需要实例化类对象。</p><p>例如Person类中的Eat()方法，如果你将其前缀声明为static，那么就可以通过Person.Eat()的方式直接调用该方法，而不需要先创建Person类的实例。</p><p>如果你在代码中定义了一个静态的Eat()方法，它可以直接执行一些与吃饭相关的操作，而不需要依赖于Person类的实例。这样的静态方法可以在不创建实例对象的情况下被调用，使得代码更加简洁和高效。</p><p>静态方法只能访问静态成员（如静态字段或其他静态方法），不能访问实例成员（如实例字段或实例方法），因为静态方法没有与特定对象实例相关联。</p><p>如果你需要执行某个与类相关，但是不依赖于类的实例对象的操作，那么可以将该操作声明为静态方法。例如，用于计算数字之间的某个关系，或者用于管理一个公共资源池等。</p><p><strong>举例</strong>：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Class Person</span><br><span class="line">&#123;</span><br><span class="line">Public <span class="built_in">string</span> name；</span><br><span class="line">Public <span class="built_in">int</span> age；</span><br><span class="line"><span class="comment">//说话的方法</span></span><br><span class="line"><span class="function">Public <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Console.WriteLine(“&#123;<span class="number">0</span>&#125;说：&#123;<span class="number">1</span>&#125;”,name,str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否成年的方法</span></span><br><span class="line"><span class="function">Public <span class="built_in">bool</span> <span class="title">ISAdult</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">Return age&gt;=<span class="number">18</span>; <span class="comment">//如果大于等于返回true，否则返回false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例2：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">Person[] friends;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Addfriend</span>(<span class="params">Person friend</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(friends==<span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">friends = <span class="keyword">new</span> Person[] &#123; friend &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">Person[] newFriend = <span class="keyword">new</span> Person[friends.Length + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; friends.Length; i++)</span><br><span class="line">&#123;</span><br><span class="line">newFriend[i] = friends[i];</span><br><span class="line">&#125;</span><br><span class="line">friends = newFriend;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125;添加了一个新朋友：&#123;1&#125;&quot;</span>, name,friend.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectionSort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Person p1=<span class="keyword">new</span> Person();</span><br><span class="line">p1.name = <span class="string">&quot;小可乐&quot;</span>;</span><br><span class="line">p1.age = <span class="number">18</span>;</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">p2.age = <span class="number">17</span>;</span><br><span class="line">p2.name = <span class="string">&quot;小辣椒&quot;</span>;</span><br><span class="line">p1.Addfriend(p2);</span><br><span class="line"><span class="comment">//运行结果：小可乐添加了一个新朋友：小辣椒</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构造函数（初始化调用）、析构、垃圾回收"><a href="#构造函数（初始化调用）、析构、垃圾回收" class="headerlink" title="构造函数（初始化调用）、析构、垃圾回收"></a>构造函数（初始化调用）、析构、垃圾回收</h2><h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h3><p>‍</p><p><strong>构造函数只能在类中声明</strong>，默认有一个0参的（无传入参数）构造函数（用于对变量成员的初始化）。</p><p>构造函数用于给类的成员属性进行赋值并初始化一个新的对象。</p><p>例如类的实例化：<code> Person p1 = new Person()；</code>​这句的 <code>new Person()</code>​ 就相当于调用了无参的构造函数初始化一个空对象。当在类中重新申明一个构造函数时，默认的0参构造函数就会被回收。</p><p>构造函数可以重载，如果想要0参的构造函数，可以手动再次申明。</p><p><strong>构造函数申明语法</strong>：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Class 你的类&#123;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">int</span> count;</span><br><span class="line">访问修饰符 类名（传入参数）</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造函数声明示例：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//举例：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span> Person[] friends;</span><br><span class="line"></span><br><span class="line"><span class="function">Public <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age,<span class="built_in">string</span> name</span>) <span class="comment">//构造函数</span></span></span><br><span class="line">&#123;</span><br><span class="line">This.age=age;</span><br><span class="line">This.name =name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Public <span class="title">Person</span>()<span class="comment">//0参构造函数，两构造函数重载</span></span></span><br><span class="line">&#123;</span><br><span class="line">age=<span class="number">0</span>;</span><br><span class="line">name =””;</span><br><span class="line">friends=<span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数的特殊写法</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">Public <span class="title">Perosn</span>(<span class="params">参数</span>)：<span class="title">this</span>(<span class="params">参数</span>)</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法的作用是，当调用这个构造函数时，会先调用<code>this（参数）构造函数</code>​，<code>this（参数）</code>​相当于调用<code>public Person （参数）;</code>​</p><p>这种构造函数的运行逻辑是</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">public</span> Person[] friends;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">age = <span class="number">0</span>;</span><br><span class="line">friends = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//如果在无参构造函数后面加:this(参数)时，由于此构造函数无传入参数，所以无参数传入this（参数）里。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age</span>):<span class="title">this</span>() <span class="comment">//调用此构造函数时会先调用this()，也就是先调用public Person()构造函数</span></span></span><br><span class="line">&#123;</span><br><span class="line">age = <span class="number">18</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age,<span class="built_in">string</span> name</span>):<span class="title">this</span>(<span class="params">age</span>)</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//当调用此构造函数时，传入的参数age和name，其中age会被传入this(age)这个函数里，然后调用public Person(int age)这个构造函数。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="析构"><a href="#析构" class="headerlink" title="析构"></a>析构</h3><p><strong>当引用类型的堆内存被回收时，会调用该函数</strong></p><p>C#存在自动垃圾回收机制GC，所以不怎么用析构函数。</p><p>只做了解即可。</p><p>如果想要在GC回收时执行一些自定义逻辑可以写里面。</p><p><strong>基本语法：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">~类名（）</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>举例</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line">&#125;</span><br><span class="line">~Person()</span><br><span class="line"> &#123;</span><br><span class="line"><span class="comment">//逻辑</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="垃圾回收机制（Garbage-collector）"><a href="#垃圾回收机制（Garbage-collector）" class="headerlink" title="垃圾回收机制（Garbage collector）"></a>垃圾回收机制（Garbage collector）</h3><p><strong>GC只负责堆里面的内存的垃圾回收。</strong></p><p>值类型在栈中分配的内存，他们有自己的生命周期，会自动分配和释放。</p><p>Heap：堆</p><p>Stack：栈</p><p>垃圾回收主要算法：</p><ol><li>标记-清除算法</li><li>压缩算法</li><li>分代清除算法</li></ol><p>手动调用GC：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">GC.collect(); <span class="comment">//手动触发垃圾回收|在Unity里面一般都是在加载场景（进度条）时使用，不会频繁调用</span></span><br></pre></td></tr></table></figure><h2 id="成员属性（包裹成员变量）"><a href="#成员属性（包裹成员变量）" class="headerlink" title="成员属性（包裹成员变量）"></a>成员属性（包裹成员变量）</h2><p><strong>基本概念：</strong></p><ol><li>用于保护成员变量</li><li>为成员属性的获取和赋值添加逻辑处理</li><li>解决3p的局限性（private——内部访问、public——内外、protected——内部和子类）</li><li>属性可以让成员变量在外部 只能获取，不能修改，或者只能修改，不能获取</li><li>可以在里面执行一些自定义逻辑，比如对数据进行加密和解密</li></ol><p><strong>语法：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">访问修饰符 属性类型 属性名</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span>&#123;</span><br><span class="line"><span class="comment">//逻辑代码</span></span><br><span class="line"><span class="comment">//可以进行解密</span></span><br><span class="line"><span class="keyword">return</span> 属性类型变量</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span>&#123;</span><br><span class="line"><span class="comment">//逻辑代码</span></span><br><span class="line"><span class="comment">//可以进行加密</span></span><br><span class="line"><span class="comment">// 类中的变量=value（外部传入值）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line"><span class="comment">//1.成员属性中get和set可以加访问修饰符</span></span><br><span class="line"><span class="comment">//2.默认不加 会使用属性申明时的访问权限</span></span><br><span class="line"><span class="comment">//3.加的访问修饰符要低于属性的访问权限</span></span><br><span class="line"><span class="comment">//4.不能让get和set的访问权限都低于属性权限</span></span><br><span class="line"><span class="comment">//5.get和set可以只有一个，另一个不写</span></span><br><span class="line"><span class="comment">//6.成员属性对应一个成员变量，成员属性的名称一般为成员变量名称的大写</span></span><br></pre></td></tr></table></figure><p><strong>申明举例：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//在自定义类中声明使用成员属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员变量name</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line"><span class="comment">//成员属性Name</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span> &#123;<span class="keyword">return</span> name;&#125;<span class="comment">//返回成员变量name的值。</span></span><br><span class="line"><span class="keyword">set</span> &#123;name=<span class="keyword">value</span>; &#125;  <span class="comment">//将value值传入name变量。value 关键字，用于表示外部传入的量。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员属性Age</span></span><br><span class="line">Public <span class="built_in">int</span> Age</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">get</span>&#123;<span class="keyword">return</span> age+<span class="number">5</span>；&#125;<span class="comment">//get为私有属性，Age属性只能外部修改不能外部获取</span></span><br><span class="line"><span class="keyword">set</span>&#123;age = <span class="keyword">value</span><span class="number">-5</span>；&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员属性的调用</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.Name = <span class="string">&quot;哇哈啊&quot;</span>;<span class="comment">// 实际上调用的set语句块</span></span><br><span class="line">Console.WriteLine(p1.Name); <span class="comment">//实际上调用的get语句块</span></span><br></pre></td></tr></table></figure><h2 id="自动属性"><a href="#自动属性" class="headerlink" title="自动属性"></a>自动属性</h2><p>‍</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果类的成员属性没有什么特殊处理，那么可以用自动属性。</span></span><br><span class="line">Public <span class="built_in">float</span> Height <span class="comment">//申明了一个只能获取的Height成员属性</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span>;<span class="comment">//默认跟随成员属性的访问修饰符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">set</span>;<span class="comment">//外部获得不能外部修改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一种写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> str &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于以下代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Str</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span> &#123; <span class="keyword">return</span> str; &#125;</span><br><span class="line"><span class="keyword">set</span> &#123; str = <span class="keyword">value</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h2><p><strong>基本概念：</strong> 为类定义一个索引器，让对象可以像数组一样通过索引访问其中元素，使程序看起来更直观，更容易编写。</p><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a><strong>语法：</strong></h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明方式一：</span></span><br><span class="line"><span class="comment">//索引器可以有多个传入参数</span></span><br><span class="line">访问修饰符 返回值类型 <span class="keyword">this</span>[参数类型 参数名 ,参数类型 参数名, ……]</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span>&#123;</span><br><span class="line"><span class="comment">//返回参数值</span></span><br><span class="line"><span class="comment">// return 对象名[index];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span>&#123;</span><br><span class="line"><span class="comment">//设置赋值语句</span></span><br><span class="line"><span class="comment">//对象名[index] = value;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//声明方式二：</span></span><br><span class="line"><span class="comment">//索引类型不一定要用int型，也可以用string等其他类型。</span></span><br><span class="line">[访问修饰符] 数据类型 <span class="keyword">this</span>[索引参数类型 index]</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//返回参数值，往往跟索引的不同返回不同的字段，用选择语句Switch</span></span><br><span class="line"><span class="comment">// return 对象名[index];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设置赋值语句</span></span><br><span class="line"><span class="comment">//对象名[index] = value;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如何访问索引器：</span></span><br><span class="line"><span class="comment">//像数组那样通过对象名的索引来选择就行 ： 对象名[index] </span></span><br></pre></td></tr></table></figure><h3 id="声明方式一索引器使用举例："><a href="#声明方式一索引器使用举例：" class="headerlink" title="声明方式一索引器使用举例："></a>声明<strong>方式一索引器使用举例：</strong></h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">private</span> Student[] friends;</span><br><span class="line"><span class="comment">//成员属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> GetName </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"><span class="keyword">set</span> &#123; name = <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> GetAge </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span> &#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"><span class="keyword">set</span> &#123; age = <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//索引器</span></span><br><span class="line"><span class="keyword">public</span> Student <span class="keyword">this</span>[<span class="built_in">int</span> index] </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(friends==<span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">friends = <span class="keyword">new</span> Student[] &#123; <span class="keyword">value</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">friends[index] = <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(friends==<span class="literal">null</span>||friends.Length<span class="number">-1</span>&lt;index||index&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> friends[index];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params">Student s,<span class="built_in">int</span> age,<span class="built_in">string</span> name</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">s.GetAge = age;</span><br><span class="line">s.GetName = name;</span><br><span class="line">Console.WriteLine(s.GetName);</span><br><span class="line">Console.WriteLine(s.GetAge);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数重载</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> age,<span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">age = <span class="number">0</span>;</span><br><span class="line">name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主程序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">s1.Init(s1, <span class="number">18</span>, <span class="string">&quot;老黄&quot;</span>);</span><br><span class="line"><span class="comment">//索引器测试</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">s1[<span class="number">0</span>] = <span class="keyword">new</span> Student(<span class="number">18</span>, <span class="string">&quot;老黄的朋友[0]&quot;</span>); <span class="comment">//通过索引器访问s1的friends[]</span></span><br><span class="line">Student s2 = s1[<span class="number">0</span>]; <span class="comment">//实例化一个student s2，将刚生成的朋友放在s2</span></span><br><span class="line">Console.WriteLine(s2.GetName + <span class="string">&quot; &quot;</span> + s2.GetAge + <span class="string">&quot;岁了&quot;</span>); <span class="comment">//检查s2是否是生成的朋友</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>‍</p><h3 id="声明方式二索引器举例："><a href="#声明方式二索引器举例：" class="headerlink" title="声明方式二索引器举例："></a>声明方式二索引器<strong>举例：</strong></h3><p>‍</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> sex;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">string</span> tel;</span><br><span class="line"><span class="comment">//索引器</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]<span class="comment">//【访问修饰符】 数据类型 this【索引器类型 index】 语法格式</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//由于return就有返回功能和结束功能所以这里的break可以省略因为写了运行不到这句代码</span></span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span> sex;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">return</span> tel;</span><br><span class="line"><span class="literal">default</span>:</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="string">&quot;index&quot;</span>);<span class="comment">//抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//这里必须要有break结束语句，因为每个case的功能语句都是赋值且没有结束语句所以这里需要break</span></span><br><span class="line">name = <span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">sex = <span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">tel = <span class="keyword">value</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="literal">default</span>:</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="string">&quot;index&quot;</span>);<span class="comment">//抛出异常</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//this[] this表示的是索引器，this[]表示访问向对应的字段。</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;我叫&#123;0&#125;，我是&#123;1&#125;生，我的电话是&#123;2&#125;&quot;</span>, <span class="keyword">this</span>[<span class="number">1</span>], <span class="keyword">this</span>[<span class="number">2</span>], <span class="keyword">this</span>[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//主程序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">Student stu = <span class="keyword">new</span> Student();<span class="comment">//实例化对象</span></span><br><span class="line">stu[<span class="number">1</span>] = <span class="string">&quot;xxx&quot;</span>;<span class="comment">//给索引器以数组的方式赋值</span></span><br><span class="line">stu[<span class="number">2</span>] = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">stu[<span class="number">3</span>] = <span class="string">&quot;13122022202&quot;</span>;</span><br><span class="line">stu.Speak();</span><br><span class="line">Console.ReadKey();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>被 <code>static</code>​ 修饰的成员，叫做静态成员。静态成员是属于类的，通过类名直接访问。</p><ul><li>当类第一次被访问时，类下的所有静态成员就会被创建在内存中。</li><li>静态成员既不在栈中也不在堆中，而是创建在 <strong>静态存储区</strong>。</li><li>静态成员 <strong>只创建一次</strong>，直到程序结束前都不会被销毁。</li><li>静态成员函数 <strong>不能访问非静态成员</strong>。</li><li>静态成员 <strong>可以访问其他静态成员或函数</strong>。</li></ul><p>示例代码：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 静态成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 访问静态成员：通过类名</span></span><br><span class="line">        <span class="built_in">int</span> age = Person.Age;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问实例成员：通过对象</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.Name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="const-和-static-的区别"><a href="#const-和-static-的区别" class="headerlink" title="const 和 static 的区别"></a>const 和 static 的区别</h3><p><strong>相同点</strong>：</p><ul><li>都可以通过类名访问。</li></ul><p><strong>不同点</strong>：</p><ol><li>​<code>const</code>​ 必须初始化，且不可修改；<code>static</code>​ 没有此限制。</li><li>​<code>const</code>​ 只能修饰变量；<code>static</code>​ 可以修饰变量、方法、类、构造函数等。</li><li>​<code>const</code>​ 必须写在变量声明前面；<code>static</code>​ 没有此限制，通常可配合访问修饰符使用。</li></ol><hr><h3 id="静态成员实现单例模式（不安全示例）"><a href="#静态成员实现单例模式（不安全示例）" class="headerlink" title="静态成员实现单例模式（不安全示例）"></a>静态成员实现单例模式（不安全示例）</h3><p>这是一个不推荐在生产环境中使用的单例实现，因为它在多线程场景下不安全。</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题</strong>：</p><ul><li>如果两个线程同时执行 <code>if (instance == null)</code>​，就可能创建多个实例，违背了单例的设计初衷。</li></ul><h3 id="线程安全的单例实现方式"><a href="#线程安全的单例实现方式" class="headerlink" title="线程安全的单例实现方式"></a>线程安全的单例实现方式</h3><h4 id="方法一：使用-lock​-加锁（懒汉式，线程安全）"><a href="#方法一：使用-lock​-加锁（懒汉式，线程安全）" class="headerlink" title="方法一：使用 lock​ 加锁（懒汉式，线程安全）"></a>方法一：使用 <code>lock</code>​ 加锁（懒汉式，线程安全）</h4><p>这是最常见的一种线程安全实现方法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> lockObj = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 双重检查锁定（Double-Check Locking）</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">lock</span> (lockObj)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>​<code>lock</code>​ 保证线程互斥地访问实例创建逻辑。</li><li>“双重检查锁定”是为了避免每次访问都加锁，提高性能。</li><li>缺点是代码稍复杂，但性能和安全兼顾。</li></ul><h4 id="方法二：静态构造函数（饿汉式，线程安全，推荐）"><a href="#方法二：静态构造函数（饿汉式，线程安全，推荐）" class="headerlink" title="方法二：静态构造函数（饿汉式，线程安全，推荐）"></a>方法二：静态构造函数（饿汉式，线程安全，推荐）</h4><p>利用 C# 静态构造函数的特性：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态构造函数（自动线程安全）</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance =&gt; instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>静态构造函数只执行一次，CLR 保证其线程安全。</li><li>在类被首次使用前就完成实例初始化。</li><li>缺点是：实例会 <strong>在程序启动后就创建</strong>，即使永远不会被用到。</li></ul><h4 id="方法三：使用-Lazy​（懒汉式，线程安全，现代推荐方式）"><a href="#方法三：使用-Lazy​（懒汉式，线程安全，现代推荐方式）" class="headerlink" title="方法三：使用 Lazy&lt;T&gt;​（懒汉式，线程安全，现代推荐方式）"></a>方法三：使用 <code>Lazy&lt;T&gt;</code>​（懒汉式，线程安全，现代推荐方式）</h4><p>C# 提供了 <code>System.Lazy&lt;T&gt;</code>​ 类，专为延迟初始化设计：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//用到了lamda表达式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Lazy&lt;Singleton&gt; lazyInstance = <span class="keyword">new</span> Lazy&lt;Singleton&gt;(() =&gt; <span class="keyword">new</span> Singleton());</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance =&gt; lazyInstance.Value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>​<code>Lazy&lt;T&gt;</code>​ 默认采用 <code>LazyThreadSafetyMode.ExecutionAndPublication</code>​，线程安全。</li><li>实例在 <strong>首次访问时才创建</strong>，且线程安全，效率高。</li><li>是 C# 中实现单例的 <strong>现代推荐写法</strong>。</li></ul><table><thead><tr><th>实现方式</th><th>是否懒加载</th><th>是否线程安全</th><th>是否推荐</th></tr></thead><tbody><tr><td>简单懒汉式</td><td>✅ 是</td><td>❌ 否</td><td>❌ 不推荐</td></tr><tr><td>lock双重检查</td><td>✅ 是</td><td>✅ 是</td><td>✅ 推荐</td></tr><tr><td>静态构造函数</td><td>❌ 否</td><td>✅ 是</td><td>✅ 推荐</td></tr><tr><td>Lazy</td><td>✅ 是</td><td>✅ 是</td><td>✅ 最推荐</td></tr></tbody></table><p>‍</p><h2 id="静态类和静态构造函数"><a href="#静态类和静态构造函数" class="headerlink" title="静态类和静态构造函数"></a>静态类和静态构造函数</h2><h3 id="静态类（static-class​）"><a href="#静态类（static-class​）" class="headerlink" title="静态类（static class​）"></a>静态类（<code>static class</code>​）</h3><p><strong>特点：</strong></p><ul><li>只能包含 <strong>静态成员</strong></li><li><strong>不能被实例化</strong></li><li>不能继承或被继承</li></ul><p><strong>作用：</strong></p><ol><li>将静态成员集中放入静态类中，<strong>方便调用</strong></li><li>静态类不能实例化，更能体现其作为<strong>工具类的唯一性</strong></li><li>常用于存放工具方法（如：数学计算、字符串处理等）</li></ol><p>✅ 例如：<code>Console</code>​ 就是一个静态类</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello from static class!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方式：</p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Test.SayHello(); <span class="comment">// 不需要实例化</span></span><br></pre></td></tr></table></figure><hr><h3 id="静态构造函数（static-构造函数​）"><a href="#静态构造函数（static-构造函数​）" class="headerlink" title="静态构造函数（static 构造函数​）"></a>静态构造函数（<code>static 构造函数</code>​）</h3><p><strong>特点：</strong></p><ul><li>可存在于 <strong>普通类</strong> 和 <strong>静态类</strong></li><li><strong>没有访问修饰符</strong>（如 public、private 等）</li><li><strong>不能带参数</strong></li><li>系统自动调用：在第一次访问类的成员时自动执行</li><li>只会被调用 <strong>一次</strong></li></ul><p><strong>作用：</strong></p><p>用于 <strong>初始化静态字段或执行类级别的一次性任务</strong></p><p><strong>语法格式：</strong></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">MyClass</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 静态构造逻辑</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Static constructor executed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Number = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用示例：</strong></p><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(MyClass.Number); <span class="comment">// 首次访问类，静态构造函数被调用</span></span><br></pre></td></tr></table></figure><h2 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h2><p>可以在不修改某一个类的情况下，为该类扩展新的成员方法，实现方法的扩展。注意，不能为静态类扩展方法。</p><p>为一个类添加扩展方法需要满足三个要素：</p><ol><li>扩展方法所在的类必须是静态类。</li><li>扩展方法本身必须是静态方法。</li><li>扩展方法的第一个参数需要使用关键字 <code>this</code>​，指定要扩展的类。</li></ol><p>‍</p><p>示例语法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 静态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">TestExtensionM</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 静态扩展方法，扩展 int 类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">ExtensionInt</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">int</span> s</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> s + s;<span class="comment">//这个扩展方法是服务于int类型的，返回它自己的2倍；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用方法也很简单：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">9</span>;</span><br><span class="line">a = a.ExtensionInt();  <span class="comment">// 结果为 18</span></span><br></pre></td></tr></table></figure><p>扩展方法也可以带多个参数：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">TestExtensionM</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 静态扩展方法，带多个参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">ExtensionInt</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">int</span> s, <span class="built_in">int</span> m, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> s + m + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line">a = a.ExtensionInt(<span class="number">20</span>, <span class="number">30</span>);  <span class="comment">// 结果为 60</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>如果扩展的方法和类里面原有的方法重名，则调用该方法时运行类里面原有的方法</li></ul><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>​<code>运算符重载</code>​：允许自定义类型（类或结构体）重新定义标准运算符的行为，使得该类型的对象能够像内置类型一样，直接使用运算符进行操作。</p><p><strong>作用：</strong></p><ul><li>让自定义类型的对象更自然地使用 <code>+</code>​、<code>-</code>​、<code>*</code>​、<code>==</code>​ 等运算符。</li><li>提升代码的可读性和可维护性。</li><li>实现特定类型间的运算规则。</li></ul><p><strong>注意事项：</strong></p><ul><li>只能重载已有的运算符，不能创造新的运算符。</li><li>至少要重载一对相关运算符（比如 <code>==</code>​ 和 <code>!=</code>​）。</li><li>重载运算符必须是 <code>public static</code>​ 方法。</li><li>运算符重载不是必须的，只在需要时使用。</li></ul><p><strong>基本语法：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回类型 <span class="keyword">operator</span> 运算符(参数列表)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 实现运算符逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>C# 中运算符重载的能力：</strong></p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+, -, !, ~, ++, –</td><td>这些一元运算符只有一个操作数，且可以被重载。</td></tr><tr><td>+, -, *, &#x2F;, %</td><td>这些二元运算符带有两个操作数，且可以被重载。</td></tr><tr><td>==, !=, &lt;, &gt;, &lt;=, &gt;=</td><td>这些比较运算符可以被重载。</td></tr><tr><td>&amp;&amp;, ||</td><td>这些条件逻辑运算符不能被直接重载。</td></tr><tr><td>+=, -=, *=, &#x2F;=, %=</td><td>这些赋值运算符不能被重载。</td></tr><tr><td>=, ., ?:, -&gt;, new, is, sizeof, typeof</td><td>这些运算符不能被重载。</td></tr></tbody></table><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>继承是面向对象编程的基本特性。</p><p>继承允许一个类（子类）继承另一个类（父类）的<code>属性</code>​和<code>方法</code>​，从而实现代码复用和扩展。</p><p>语法： ：类名</p><p>举例：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello, my name is &quot;</span> + Name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span>()：<span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> StudentID;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.Name = <span class="string">&quot;Tom&quot;</span>;    <span class="comment">// 继承自Person</span></span><br><span class="line">        student.StudentID = <span class="number">123</span>;</span><br><span class="line">        student.SayHello();      <span class="comment">// 调用继承的方法</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Student ID: &quot;</span> + student.StudentID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承构造函数："><a href="#继承构造函数：" class="headerlink" title="继承构造函数："></a>继承构造函数：</h3><ul><li>初始化子类时，会先调用父类的默认构造函数，然后再调用子类的构造函数。</li><li>当父类或子类定义了构造函数时，默认的无参构造函数会被覆盖。</li><li>在子类声明构造函数时，如果想指定调用父类的某个构造函数，可以使用 <code>base(参数)</code>​。</li><li>如果想在一个类中用自己的构造函数调用该类的另一个构造函数，可以使用 <code>this(参数)</code>​。</li></ul><p>示例代码：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameObject</span>  <span class="comment">// 父类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">float</span> x;</span><br><span class="line">    <span class="built_in">float</span> y;</span><br><span class="line">    <span class="built_in">float</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">GameObject</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">int</span> m, <span class="built_in">int</span> k</span>)  <span class="comment">// 构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        x = i;</span><br><span class="line">        y = m;</span><br><span class="line">        z = k;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;GameObject构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">GameObject</span>()  <span class="comment">// 构造函数重载</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;GameObject构造函数重载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cube</span> : <span class="title">GameObject</span>  <span class="comment">// Cube类继承GameObject</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> vertex;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> edge;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ConstructCube</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> c = vertex + edge;</span><br><span class="line">        vertex = <span class="number">0</span>;</span><br><span class="line">        edge = <span class="number">0</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;您已创建正方体&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cube</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">int</span> m, <span class="built_in">int</span> k</span>) : <span class="title">base</span>(<span class="params">i, m, k</span>)  <span class="comment">// 使用Base()继承父类构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        vertex = <span class="number">8</span>;</span><br><span class="line">        edge = <span class="number">12</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cube继承子类构造函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cube</span>()  <span class="comment">// 构造函数重载</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cube构造函数继承子类重载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cube</span>(<span class="params"><span class="built_in">string</span> str</span>) : <span class="title">this</span>()  <span class="comment">// 调用自己的无参构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;我用构造函数调用自己类的构造函数说了：&quot;</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="万物之父（object）-装箱和拆箱"><a href="#万物之父（object）-装箱和拆箱" class="headerlink" title="万物之父（object）,装箱和拆箱"></a>万物之父（object）,装箱和拆箱</h1><p>​<code>object</code>​（System.Object）是所有类型的终极父类（基类），所有类型都可以向上转换为<code>object</code>​。</p><ol><li>可以用里氏替换原则，用object装所有对象</li><li>可以用来表示不确定型，作为函数参数类型</li></ol><h3 id="Object装引用类型："><a href="#Object装引用类型：" class="headerlink" title="Object装引用类型："></a>Object装引用类型：</h3><p>​<code>object</code>​ 是所有类型的基类，引用类型可以直接赋值给 <code>object</code>​ 类型变量。</p><h4 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h4><ul><li><strong>装箱</strong>：将值类型转换为引用类型（如object），将值从栈内存复制到堆内存，并封装成对象。</li><li><strong>拆箱</strong>：将引用类型中的值转换回对应的值类型，从堆内存复制回栈内存，必须显式强制转换。</li></ul><h4 id="装箱的作用"><a href="#装箱的作用" class="headerlink" title="装箱的作用"></a>装箱的作用</h4><ul><li>允许<strong>值类型</strong>以<strong>引用类型</strong>的形式存储和传递，方便在需要引用类型的场景（如集合）中使用值类型。</li></ul><h4 id="拆箱的作用"><a href="#拆箱的作用" class="headerlink" title="拆箱的作用"></a>拆箱的作用</h4><ul><li>将装箱后的引用类型恢复为原始值类型，方便进行值类型的操作。</li></ul><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><ul><li><strong>好处</strong>：方便不同类型的数据存储和传递，增强灵活性。</li><li><strong>坏处</strong>：装箱和拆箱涉及内存复制和堆分配，带来额外的性能开销，频繁使用会影响效率。</li></ul><h4 id="装类类型"><a href="#装类类型" class="headerlink" title="装类类型"></a>装类类型</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Person();  <span class="comment">// Person 对象赋值给 object</span></span><br><span class="line">Person s = <span class="keyword">new</span> Person();</span><br><span class="line">o = s;  <span class="comment">// object 可以引用 Person 对象（引用赋值）</span></span><br></pre></td></tr></table></figure><ul><li>使用时推荐<strong>里氏替换原则</strong>，即用父类（或基类）变量引用子类实例。</li><li>判断和转换：</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (o <span class="keyword">is</span> Person)  <span class="comment">// 判断 o 是否是 Person 类型或其子类实例</span></span><br><span class="line">&#123;</span><br><span class="line">    Person s2 = o <span class="keyword">as</span> Person;  <span class="comment">// 安全转换，失败时返回 null</span></span><br><span class="line">    <span class="comment">// 或者 Person s2 = (Person)o; // 强制转换，失败时抛异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="装字符串类型"><a href="#装字符串类型" class="headerlink" title="装字符串类型"></a>装字符串类型</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Object o = <span class="string">&quot;12342&quot;</span>;  <span class="comment">// 字符串是引用类型，直接赋值给 object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式：</span></span><br><span class="line"><span class="built_in">string</span> str1 = o.ToString();  <span class="comment">// 调用 ToString()，返回字符串表示</span></span><br><span class="line"><span class="built_in">string</span> str2 = o <span class="keyword">as</span> <span class="built_in">string</span>;   <span class="comment">// 使用 as 转换，成功返回字符串，失败返回 null</span></span><br></pre></td></tr></table></figure><h4 id="装数组类型"><a href="#装数组类型" class="headerlink" title="装数组类型"></a>装数组类型</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> o = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换方法1：使用 as（安全转换，失败返回 null）</span></span><br><span class="line"><span class="built_in">int</span>[] a = o <span class="keyword">as</span> <span class="built_in">int</span>[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换方法2：强制类型转换（失败抛异常）</span></span><br><span class="line"><span class="built_in">int</span>[] a2 = (<span class="built_in">int</span>[])o;</span><br></pre></td></tr></table></figure><h4 id="装值类型："><a href="#装值类型：" class="headerlink" title="装值类型："></a>装值类型：</h4><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> o = <span class="number">1</span>;   <span class="comment">// 将值类型装箱为引用类型</span></span><br><span class="line"><span class="comment">// 转换方法 强制类型转换</span></span><br><span class="line"><span class="built_in">int</span> i = (<span class="built_in">int</span>)o;  <span class="comment">// 将object类型拆箱回int类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>装箱</strong>：将值类型转换为引用类型（如object），将值从栈内存复制到堆内存，并封装成对象。</li><li><strong>拆箱</strong>：将引用类型中的值转换回对应的值类型，从堆内存复制回栈内存，必须显式强制转换。</li></ul><h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><ul><li><p>用sealed封装，不能被继承的类。</p></li><li><p>在面向对象的程序设计中，密封类的主要作用是不允许最底层的子类被继承，这样安全性更高。</p></li></ul><p><strong>语法：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ClassName</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>示例代码</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个密封类</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;动物叫声&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码会报错，因为Animal是sealed，不能被继承</span></span><br><span class="line"><span class="comment">// class Dog : Animal</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>补充说明</strong></p><ul><li><strong>sealed类</strong>可以继承自其他类，但不能被继承。</li><li><strong>sealed修饰方法</strong>：方法也可以被<code>sealed</code>​修饰（必须是重写方法），防止被进一步重写。</li><li>如果不希望其他类继承某个类，就可以将该类声明为<code>sealed</code>​。</li></ul><h1 id="多态vob"><a href="#多态vob" class="headerlink" title="多态vob"></a>多态vob</h1><h3 id="什么是多态（Polymorphism）？"><a href="#什么是多态（Polymorphism）？" class="headerlink" title="什么是多态（Polymorphism）？"></a><strong>什么是多态（Polymorphism）？</strong></h3><ul><li>多态是指<strong>相同的方法在不同的对象上有不同的表现形式</strong>。</li></ul><h3 id="多态的三要素：V-O-B"><a href="#多态的三要素：V-O-B" class="headerlink" title="多态的三要素：V.O.B"></a><strong>多态的三要素：V.O.B</strong></h3><ul><li><table><thead><tr><th>缩写</th><th>含义</th><th>关键词</th><th>作用</th></tr></thead><tbody><tr><td>V</td><td>Virtual</td><td>​<code>virtual</code>​</td><td>父类中声明<strong>虚方法</strong>，允许子类重写</td></tr><tr><td>O</td><td>Override</td><td>​<code>override</code>​</td><td>子类中重写父类的<strong>虚方法</strong></td></tr><tr><td>B</td><td>Base</td><td>​<code>base</code>​</td><td>子类中调用父类<strong>被重写的方法</strong></td></tr></tbody></table></li></ul><h3 id="多态的目的"><a href="#多态的目的" class="headerlink" title="多态的目的"></a><strong>多态的目的</strong></h3><ul><li><strong>让继承父类的子类对象</strong>在调用同一个方法时拥有<strong>各自不同的行为</strong></li><li><strong>统一接口，行为多样化</strong></li><li><strong>实现行为复用 + 灵活扩展</strong></li></ul><h3 id="示例说明（吃饭行为的多态）"><a href="#示例说明（吃饭行为的多态）" class="headerlink" title="示例说明（吃饭行为的多态）"></a><strong>示例说明（吃饭行为的多态）</strong></h3><ul><li><strong>父类：</strong>  父亲吃饭 → 坐着吃</li><li><strong>子类：</strong>  儿子吃饭 → 站着吃（但想先执行父亲的逻辑）</li></ul><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a><strong>原理：</strong></h3><ul><li><p>​<code>virtual</code>​ 修饰父类方法，可被重写</p></li><li><p>​<code>override</code>​ 用于子类方法的重写</p></li><li><p>​<code>base.方法()</code>​ 表示在子类中<strong>调用父类的实现</strong></p></li><li><p><strong>虚函数可以被子类重写，配合</strong>​<strong>​<code>override</code>​</strong>​<strong>使用</strong></p></li></ul><h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a><strong>举例：</strong></h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Animals</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Animals</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span>() <span class="comment">// V: virtual 虚方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I am an animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Duck</span> : <span class="title">Animals</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Duck</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>() <span class="comment">// O: override 重写方法</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果想继承父类部分逻辑可用 base.Speak();</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I am a duck, My name is &#123;0&#125;&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Turkey</span> : <span class="title">Animals</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Turkey</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;I am a turkey, My name is &#123;0&#125;&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Animals duck01 = <span class="keyword">new</span> Duck(<span class="string">&quot;Ducky&quot;</span>);</span><br><span class="line">        duck01.Speak(); <span class="comment">// 输出：I am a duck, My name is Ducky</span></span><br><span class="line"></span><br><span class="line">        Animals turkey02 = <span class="keyword">new</span> Turkey(<span class="string">&quot;Kidden&quot;</span>);</span><br><span class="line">        turkey02.Speak(); <span class="comment">// 输出：I am a turkey, My name is Kidden</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="C-抽象类与抽象方法（abstract​）"><a href="#C-抽象类与抽象方法（abstract​）" class="headerlink" title="C# 抽象类与抽象方法（abstract​）"></a>C# 抽象类与抽象方法（<code>abstract</code>​）</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>关键词：<code>abstract</code>​</p><h3 id="什么是抽象类？"><a href="#什么是抽象类？" class="headerlink" title="什么是抽象类？"></a>什么是抽象类？</h3><ul><li><p>‍</p></li><li><p>抽象类是用于<strong>被其他类继承</strong>的类，<strong>不能直接被实例化</strong></p></li><li><p>它通常用来定义一类对象的<strong>通用属性和行为</strong></p></li><li><p>抽象类的作用是作为<strong>父类模板</strong>，供子类实现具体逻辑</p></li></ul><p>例如：<code>Thing</code>​ 类是“物品”的统称，是一个抽象概念，不能单独存在，只能被继承。</p><h3 id="抽象方法的特点"><a href="#抽象方法的特点" class="headerlink" title="抽象方法的特点"></a>抽象方法的特点</h3><ul><li>抽象方法<strong>没有方法体</strong>（即不包含具体实现）</li><li>必须在子类中进行<strong>重写（override）</strong></li><li>抽象方法必须定义在抽象类中</li></ul><h3 id="示例说明：动物类"><a href="#示例说明：动物类" class="headerlink" title="示例说明：动物类"></a>示例说明：动物类</h3><ul><li>​<code>Animal</code>​ 是抽象类，不能实例化，只能作为父类存在</li><li><code>Shout()</code>​ 是抽象方法，所有子类必须重写此方法</li></ul><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span> <span class="comment">// 抽象类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法，无方法体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Shout</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Shout</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Meow!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Shout</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>‍</p><h3 id="抽象类使用规则总结"><a href="#抽象类使用规则总结" class="headerlink" title="抽象类使用规则总结"></a>抽象类使用规则总结</h3><table><thead><tr><th align="center">编号</th><th>规则描述</th></tr></thead><tbody><tr><td align="center">1</td><td>抽象方法只能出现在抽象类中</td></tr><tr><td align="center">2</td><td>抽象类中可以包含普通方法（可有方法体）</td></tr><tr><td align="center">3</td><td>抽象方法没有实现，必须被子类重写</td></tr><tr><td align="center">4</td><td>抽象类不能被实例化（不能<code>new</code>​）</td></tr><tr><td align="center">5</td><td>抽象类和抽象方法都需使用<code>abstract</code>​关键字</td></tr><tr><td align="center">6</td><td>子类重写抽象方法时，必须使用<code>override</code>​关键字</td></tr><tr><td align="center">7</td><td>如果子类不是抽象类，它<strong>必须实现</strong>父类的所有抽象方法</td></tr></tbody></table><h3 id="使用场景举例"><a href="#使用场景举例" class="headerlink" title="使用场景举例"></a>使用场景举例</h3><table><thead><tr><th>场景</th><th>示例</th></tr></thead><tbody><tr><td>动物种类抽象</td><td>​<code>Animal</code>​→<code>Dog</code>​、<code>Cat</code>​</td></tr><tr><td>形状抽象</td><td>​<code>Shape</code>​→<code>Circle</code>​、<code>Rectangle</code>​</td></tr><tr><td>员工类型抽象</td><td>​<code>Employee</code>​→<code>Manager</code>​、<code>Developer</code>​</td></tr></tbody></table><h3 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h3><ul><li>抽象类是一种<strong>模板设计方式</strong>，强制子类实现某些功能</li><li>如果不打算实例化一个类，而只是作为基类，优先使用 <code>abstract</code>​</li></ul><h2 id="抽象方法（函数）"><a href="#抽象方法（函数）" class="headerlink" title="抽象方法（函数）"></a>抽象方法（函数）</h2><h3 id="什么是抽象方法？"><a href="#什么是抽象方法？" class="headerlink" title="什么是抽象方法？"></a>什么是抽象方法？</h3><ul><li>抽象方法是<strong>没有方法体</strong>的方法。</li><li>它只能存在于<strong>抽象类</strong>中。</li><li>子类必须使用<code>override</code>​来<strong>重写实现</strong>该抽象方法，这表示不抽象方法能用<code>private</code>​修饰。</li></ul><h3 id="抽象方法的定义格式："><a href="#抽象方法的定义格式：" class="headerlink" title="抽象方法的定义格式："></a>抽象方法的定义格式：</h3><ul><li>​<code>abstract</code>​ 关键字放在方法定义前面</li><li>方法<strong>没有方法体</strong>（即没有 <code>&#123;&#125;</code>​，只以 <code>;</code>​ 结尾）</li></ul><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> 返回类型 方法名(参数列表);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类必须实现抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Woof!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="抽象方法与普通虚方法的区别"><a href="#抽象方法与普通虚方法的区别" class="headerlink" title="抽象方法与普通虚方法的区别"></a>抽象方法与普通虚方法的区别</h3><table><thead><tr><th>比较项</th><th>抽象方法 (<code>abstract</code>​)</th><th>虚方法 (<code>virtual</code>​)</th></tr></thead><tbody><tr><td>是否有方法体</td><td>❌ 没有</td><td>✅ 有默认实现</td></tr><tr><td>是否必须重写</td><td>✅ 是</td><td>❌ 可选</td></tr><tr><td>是否必须在抽象类中</td><td>✅ 是</td><td>❌ 否</td></tr></tbody></table><h3 id="抽象方法的优点"><a href="#抽象方法的优点" class="headerlink" title="抽象方法的优点"></a>抽象方法的优点</h3><ul><li>提供统一的接口规范</li><li>强制子类实现特定功能</li><li>有助于面向对象中的“<strong>多态性</strong>”设计</li></ul><h3 id="使用场景示例"><a href="#使用场景示例" class="headerlink" title="使用场景示例"></a>使用场景示例</h3><p>所有子类都必须实现某些功能时：</p><ul><li>比如：<code>Animal</code>​ 类中的 <code>MakeSound()</code>​ 方法</li><li>或 <code>Shape</code>​ 类中的 <code>CalculateArea()</code>​ 方法</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote><p>抽象方法是一种设计规范的体现。<br>希望所有子类都<strong>必须实现</strong>某个方法时，就使用抽象方法。</p></blockquote><p>‍</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="什么是接口？"><a href="#什么是接口？" class="headerlink" title="什么是接口？"></a>什么是接口？</h2><p>关键词：<code>Interface</code>​</p><ul><li><p>里面的成员不能实现，被类和接口继承，一个类可以继承多个接口，继承接口后必须实现其成员</p></li><li><p>接口不能被实例化，只能当作存储容器，遵循里氏替换原则</p></li><li><p>接口相当于抽象行为的基类，是行为的抽象规范，一般用来抽象行为</p></li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">Fly</span> <span class="comment">//接口</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Func_Fly</span>()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Bird</span> : <span class="title">Animals</span>, <span class="title">Fly</span> <span class="comment">//小鸟继承了接口</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bird</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>) <span class="comment">//构造函数</span></span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Func_Fly</span>() <span class="comment">//实现接口成员</span></span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;小鸟完成了飞行&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="显示实现接口"><a href="#显示实现接口" class="headerlink" title="显示实现接口"></a>显示实现接口</h2><h3 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h3><p>当一个类<strong>实现多个接口</strong>，而这些接口中有<strong>同名的方法或属性</strong>时，为了避免命名冲突，<strong>必须通过“显式实现”来区分它们</strong>。</p><h3 id="语法格式示例"><a href="#语法格式示例" class="headerlink" title="语法格式示例"></a>语法格式示例</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IOne</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">ITwo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IOne</span>, <span class="title">ITwo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 显式实现接口 IOne 的方法</span></span><br><span class="line">    <span class="keyword">void</span> IOne.DoSomething()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;IOne.DoSomething&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式实现接口 ITwo 的方法</span></span><br><span class="line">    <span class="keyword">void</span> ITwo.DoSomething()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;ITwo.DoSomething&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MyClass obj = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="comment">// 必须强制转换为接口类型，才能访问显式实现的方法</span></span><br><span class="line">((IOne)obj).DoSomething();     <span class="comment">// 输出：IOne.DoSomething</span></span><br><span class="line">((ITwo)obj).DoSomething();     <span class="comment">// 输出：ITwo.DoSomething</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li><p><strong>显式实现的方法不会在类实例中直接暴露</strong></p><ul><li>即：<code>obj.DoSomething();</code>​ ❌ 无法调用</li></ul></li><li><p>只能通过<strong>接口引用</strong>或者强制类型转换来访问</p></li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>实现多个接口中<strong>具有相同成员签名的方法</strong></li><li>防止接口方法被类实例直接访问（封装接口成员）</li><li>提高类的灵活性和接口解耦能力</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><table><thead><tr><th>项目</th><th>说明</th></tr></thead><tbody><tr><td>是否支持重载</td><td>支持，同名方法根据接口区分</td></tr><tr><td>调用方式</td><td>必须通过接口引用或强制类型转换</td></tr><tr><td>好处</td><td>避免命名冲突，增强封装性</td></tr><tr><td>限制</td><td>类中无法直接访问显式实现的方法</td></tr></tbody></table><p>‍</p><h1 id="密封函数"><a href="#密封函数" class="headerlink" title="密封函数"></a>密封函数</h1><p>当在<code>override</code>​前加上<code>sealed</code>​时，这个函数不能被子类重写，当在继承子类中，在重写的父类函数<code>override</code>​关键字前加<code>sealed</code>​，则不允许继承子类的子类再次进行重写。</p><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>命名空间是用来组织和重用代码的</p><p>命名空间就像是一个工具包，类就是一个个工具，都是在命名空间申明的</p><p>语法：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Namespace 空间名</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Namespace MyGame</span><br><span class="line">&#123;</span><br><span class="line">Class Player</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>命名空间可以同名分开写，相当于同一个命名空间</p></li><li><p>不同命名空间相互使用需要引用命名空间或指明出处</p></li></ul><p>引用：</p><ul><li><p>在命名空间上方<code>using system</code>​ 这相当于引用了<code>system</code>​命名空间</p></li><li><p>如果要用另一个命名空间，则要加<code> using 命名空间名</code>​</p></li></ul><p>调用某一命名空间的类的方法：</p><p>在另一个域里使用某个命名空间下的类时，语法如下</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> MyGame;<span class="comment">//1.引用命名空间</span></span><br><span class="line">Class MyfirstScript</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">newPlayer</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">MyGame.Player = <span class="keyword">new</span> MyGame.Player();<span class="comment">//2.  命名空间名 . 类名 来使用</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单例模式（singleton）"><a href="#单例模式（singleton）" class="headerlink" title="单例模式（singleton）"></a>单例模式（singleton）</h1><p><a href="https://www.cnblogs.com/zhili/p/SingletonPatterm.html">C#设计模式(1)——单例模式 </a></p><p><a href="https://www.cnblogs.com/xiaohanxixi/p/13197362.html" title="发布于 2020-06-27 09:23">C#实现单例模式的几种方法 </a></p><p><a href="https://www.cnblogs.com/willick/p/13399194.html">C#单例模式最佳实践 </a></p><p>单例模式的概念：<strong>确保一个类只有一个实例,并提供一个全局访问点。</strong></p><p>单例模式的多种实现方式：懒汉模式、饿汉模式</p><p>区别：懒汉：类在加载时不会实例化自己的对象，饿汉：类在加载时就实例化自己的对象</p><p>单例模式在多线程下涉及到线程同步问题，为此我们要设置双重锁定。</p><p>代码示例</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> _instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//懒汉模式，双重锁定的实现方式，解决了线程安全问题并优化了性能。非常经典的写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义一个静态变量来保存类的实例</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个标识确保线程同步</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> locker = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义私有构造函数，使外界不能创建该类实例</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当第一个线程运行到这里时，此时会对locker对象 &quot;加锁&quot;，</span></span><br><span class="line">            <span class="comment">// 当第二个线程运行该方法时，首先检测到locker对象为&quot;加锁&quot;状态，该线程就会挂起等待第一个线程解锁</span></span><br><span class="line">            <span class="comment">// lock语句运行完之后（即线程运行完之后）会对该对象&quot;解锁&quot;</span></span><br><span class="line">            <span class="comment">// 双重锁定只需要一句判断就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">lock</span> (locker)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 如果类的实例不存在则创建，否则直接返回</span></span><br><span class="line">                    <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用.NET 4 Lazy&lt;T&gt; type 特性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LazySingleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Lazy&lt;LazySingleton&gt; _instance =</span><br><span class="line">        <span class="keyword">new</span> Lazy&lt;LazySingleton&gt;(() =&gt; <span class="keyword">new</span> LazySingleton());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton Instance</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _instance.Value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> instance = LazySingleton.Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>‍</p><p>‍</p><h1 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h1><h2 id="字符串常用方法说明"><a href="#字符串常用方法说明" class="headerlink" title="字符串常用方法说明"></a>字符串常用方法说明</h2><table><thead><tr><th>功能类别</th><th>方法名&#x2F;属性</th><th>参数说明</th><th>示例代码</th></tr></thead><tbody><tr><td>获取长度</td><td>​<code>Length</code>​</td><td>无</td><td>​<code>int len = str.Length;</code>​</td></tr><tr><td>字符访问</td><td>​<code>[]</code>​（索引器）</td><td>​<code>int index</code>​：要访问的字符索引</td><td>​<code>char c = str[0];</code>​</td></tr><tr><td>转为字符数组</td><td>​<code>ToCharArray()</code>​</td><td>无</td><td>​<code>char[] arr = str.ToCharArray();</code>​</td></tr><tr><td>查找子串（正向）</td><td>​<code>IndexOf(string)</code>​</td><td>​<code>string value</code>​：要查找的子串</td><td>​<code>int i = str.IndexOf(&quot;鸭&quot;);</code>​</td></tr><tr><td>查找子串（反向）</td><td>​<code>LastIndexOf(string)</code>​</td><td>​<code>string value</code>​：要查找的子串</td><td>​<code>int i = str.LastIndexOf(&quot;达鸭&quot;);</code>​</td></tr><tr><td>截取子串</td><td>​<code>Substring(int)</code>​</td><td>​<code>startIndex</code>​：起始索引</td><td>​<code>string s = str.Substring(6);</code>​</td></tr><tr><td>截取子串</td><td>​<code>Substring(int, int)</code>​</td><td>​<code>startIndex</code>​：起始索引，<code>length</code>​：截取长度</td><td>​<code>string s = str.Substring(2, 3);</code>​</td></tr><tr><td>移除子串</td><td>​<code>Remove(int)</code>​</td><td>​<code>startIndex</code>​：从该位置开始移除到末尾</td><td>​<code>string s = str.Remove(2);</code>​</td></tr><tr><td>移除子串</td><td>​<code>Remove(int, int)</code>​</td><td>​<code>startIndex</code>​，<code>count</code>​：移除多少字符</td><td>​<code>string s = str.Remove(2, 1);</code>​</td></tr><tr><td>替换子串</td><td>​<code>Replace(old, new)</code>​</td><td>​<code>oldValue</code>​：原字符串，<code>newValue</code>​：替换成的新值</td><td>​<code>string s = str.Replace(&quot;可达鸭&quot;, &quot;小猫咪&quot;);</code>​</td></tr><tr><td>拼接字符串</td><td>​<code>+</code>​</td><td>其他字符串</td><td>​<code>string s = str + &quot;2333&quot;;</code>​</td></tr><tr><td>拼接格式化</td><td>​<code>string.Format()</code>​</td><td>格式字符串 + 参数</td><td>​<code>string s = string.Format(&quot;&#123;0&#125;呀&quot;, &quot;可达鸭&quot;);</code>​</td></tr><tr><td>转为大写</td><td>​<code>ToUpper()</code>​</td><td>无</td><td>​<code>string upper = str.ToUpper();</code>​</td></tr><tr><td>转为小写</td><td>​<code>ToLower()</code>​</td><td>无</td><td>​<code>string lower = str.ToLower();</code>​</td></tr><tr><td>字符串切割</td><td>​<code>Split(char[])</code>​</td><td>​<code>char[]</code>​：分隔符数组</td><td>​<code>string[] arr = str.Split(&#39;,&#39;);</code>​</td></tr></tbody></table><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">&quot;可达鸭呀&quot;</span>;</span><br><span class="line">        <span class="comment">// 1. 字符串指定位置获取（索引器）</span></span><br><span class="line">        Console.WriteLine(str[<span class="number">0</span>]);  <span class="comment">// 输出：可</span></span><br><span class="line">        <span class="comment">// 遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; str.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(str[i]);  <span class="comment">// 输出：可达鸭呀</span></span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        <span class="comment">// 转换为 char 数组</span></span><br><span class="line">        <span class="built_in">char</span>[] chars = str.ToCharArray();</span><br><span class="line">        Console.WriteLine(chars[<span class="number">0</span>]);  <span class="comment">// 输出：可</span></span><br><span class="line">        <span class="comment">// 2. 字符串拼接</span></span><br><span class="line">        <span class="built_in">string</span> st = <span class="built_in">string</span>.Format(str + <span class="string">&quot;233333&quot;</span>);</span><br><span class="line">        Console.WriteLine(st);  <span class="comment">// 输出：可达鸭呀233333</span></span><br><span class="line">        <span class="comment">// 3. 查找字符位置</span></span><br><span class="line">        <span class="built_in">int</span> index = str.IndexOf(<span class="string">&quot;鸭&quot;</span>);           <span class="comment">// 正向查找，找不到返回 -1</span></span><br><span class="line">        Console.WriteLine(index);                <span class="comment">// 输出：2</span></span><br><span class="line">        index = str.LastIndexOf(<span class="string">&quot;达鸭&quot;</span>);         <span class="comment">// 反向查找，查找的是“达鸭”的起始索引</span></span><br><span class="line">        Console.WriteLine(index);                <span class="comment">// 输出：1</span></span><br><span class="line">        <span class="comment">// 4. 移除字符</span></span><br><span class="line">        Console.WriteLine(str);                  <span class="comment">// 输出：可达鸭呀（原字符串未改变）</span></span><br><span class="line">        <span class="built_in">string</span> removed1 = str.Remove(<span class="number">2</span>);         <span class="comment">// 移除索引 2 及其后所有字符</span></span><br><span class="line">        Console.WriteLine(removed1);             <span class="comment">// 输出：可达</span></span><br><span class="line">        <span class="built_in">string</span> removed2 = str.Remove(<span class="number">2</span>, <span class="number">1</span>);      <span class="comment">// 从索引 2 移除 1 个字符</span></span><br><span class="line">        Console.WriteLine(removed2);             <span class="comment">// 输出：可达呀</span></span><br><span class="line">        <span class="comment">// 5. 替换字符串</span></span><br><span class="line">        <span class="built_in">string</span> replaced = str.Replace(<span class="string">&quot;可达鸭&quot;</span>, <span class="string">&quot;小猫咪&quot;</span>);</span><br><span class="line">        Console.WriteLine(replaced);             <span class="comment">// 输出：小猫咪呀</span></span><br><span class="line">        <span class="comment">// 6. 字母大小写转换</span></span><br><span class="line">        <span class="built_in">string</span> st4 = <span class="string">&quot;asdawdjwiao&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> upper = st4.ToUpper();            <span class="comment">// 转大写</span></span><br><span class="line">        Console.WriteLine(upper);                <span class="comment">// 输出：ASDAWDJWIAO</span></span><br><span class="line">        <span class="built_in">string</span> lower = upper.ToLower();          <span class="comment">// 转小写</span></span><br><span class="line">        Console.WriteLine(lower);                <span class="comment">// 输出：asdawdjwiao</span></span><br><span class="line">        <span class="comment">// 7. 字符串截取</span></span><br><span class="line">        str = <span class="string">&quot;我是宫崎英高desu&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span> substr1 = str.Substring(<span class="number">6</span>);       <span class="comment">// 从索引 6 开始截取到结尾</span></span><br><span class="line">        Console.WriteLine(substr1);              <span class="comment">// 输出：desu</span></span><br><span class="line">        <span class="built_in">string</span> substr2 = str.Substring(<span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// 从索引 2 开始截取 3 个字符</span></span><br><span class="line">        Console.WriteLine(substr2);              <span class="comment">// 输出：宫崎英</span></span><br><span class="line">        <span class="comment">// 8. 字符串切割</span></span><br><span class="line">        <span class="built_in">string</span> st6 = <span class="string">&quot;1,2,3,4,5,6,7,8&quot;</span>;</span><br><span class="line">        <span class="built_in">string</span>[] parts = st6.Split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> part <span class="keyword">in</span> parts)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(part);                 <span class="comment">// 输出：12345678</span></span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>‍</p><h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><h2 id="什么是StringBuilder​？"><a href="#什么是StringBuilder​？" class="headerlink" title="什么是StringBuilder​？"></a>什么是<code>StringBuilder</code>​？</h2><p>一个字符串经常被修改会很消耗内存空间，stringBuilder用于解决这一问题。</p><ul><li>​<code>StringBuilder</code>​ 是 <code>System.Text</code>​ 命名空间下的一个公共类。</li><li>作用：<strong>用于频繁修改或拼接字符串时，避免创建多个新字符串对象，提高性能并节省内存开销。</strong></li></ul><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>可变字符串</td><td>修改字符串内容不会生成新的字符串对象</td></tr><tr><td>自动扩容</td><td>默认初始容量为<strong>16</strong>，插入内容超出后会自动扩容</td></tr><tr><td>可指定初始容量</td><td>可以通过构造函数设置初始容量，避免频繁扩容带来的性能浪费</td></tr></tbody></table><p>使用命名空间：<code>using System.Text;</code>​</p><h2 id="构造方式："><a href="#构造方式：" class="headerlink" title="构造方式："></a>构造方式：</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量为16</span></span><br><span class="line">StringBuilder sb1 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;123123&quot;</span>);</span><br><span class="line"><span class="comment">// 指定初始容量为48</span></span><br><span class="line">StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;123123&quot;</span>, <span class="number">48</span>);</span><br></pre></td></tr></table></figure><h2 id="属性说明："><a href="#属性说明：" class="headerlink" title="属性说明："></a>属性说明：</h2><table><thead><tr><th>属性&#x2F;方法</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>​<code>Capacity</code>​</td><td>当前 StringBuilder 的容量</td><td>​<code>Console.WriteLine(sb1.Capacity);</code>​</td></tr><tr><td>​<code>Length</code>​</td><td>实际字符长度</td><td>​<code>Console.WriteLine(sb1.Length);</code>​</td></tr></tbody></table><h2 id="举例：-1"><a href="#举例：-1" class="headerlink" title="举例："></a>举例：</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params"><span class="built_in">string</span> arg[]</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">System.Text.StringBuilder SB01 = <span class="keyword">new</span> System.Text.StringBuilder(<span class="string">&quot;123123&quot;</span>);</span><br><span class="line"><span class="comment">//StringBuilder存在容量问题，每次往里面增加时，会自动扩容，默认初始容量为16</span></span><br><span class="line">System.Text.StringBuilder SB01 = <span class="keyword">new</span> System.Text.StringBuilder(<span class="string">&quot;123123&quot;</span>,<span class="number">48</span>);<span class="comment">//可以指定容量，也可不指定。</span></span><br><span class="line">Console.WriteLine(SB01.Capacity); <span class="comment">//获取容量</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="StringBuilder的增删查改："><a href="#StringBuilder的增删查改：" class="headerlink" title="StringBuilder的增删查改："></a>StringBuilder的增删查改：</h2><p><strong>增：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在末尾添加字符串</span></span><br><span class="line">sb.Append(<span class="string">&quot;追加内容&quot;</span>);</span><br><span class="line"><span class="comment">// 添加格式化字符串</span></span><br><span class="line">sb.AppendFormat(<span class="string">&quot;&#123;0&#125; + &#123;1&#125;&quot;</span>, <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>插入：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在指定位置插入字符串</span></span><br><span class="line">sb.Insert(<span class="number">2</span>, <span class="string">&quot;插入内容&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>删除：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从索引 3 开始删除 2 个字符</span></span><br><span class="line">sb.Remove(<span class="number">3</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>清空：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清空 StringBuilder 内容</span></span><br><span class="line">sb.Clear();</span><br></pre></td></tr></table></figure><p><strong>查找：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出指定位置字符</span></span><br><span class="line">Console.WriteLine(sb[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p><strong>改：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改指定索引位置字符</span></span><br><span class="line">sb[<span class="number">0</span>] = <span class="string">&#x27;新&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>替换：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 替换所有 &quot;旧&quot; 字符为 &quot;新&quot;</span></span><br><span class="line">sb.Replace(<span class="string">&quot;旧&quot;</span>, <span class="string">&quot;新&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>重新赋值：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清空再重新追加内容</span></span><br><span class="line">sb.Clear();</span><br><span class="line">sb.Append(<span class="string">&quot;新的内容&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>判断相等：</strong></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sb.ToString().Equals(<span class="string">&quot;目标字符串&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推荐使用场景"><a href="#推荐使用场景" class="headerlink" title="推荐使用场景"></a>推荐使用场景</h2><ul><li>在循环中频繁拼接字符串时（如日志生成、大批量字符串组合）。</li><li>替代 <code>string +=</code>​ 等不高效的字符串拼接方式。</li><li>实现动态内容构造，如 HTML、SQL 构建器等。</li></ul><h1 id="数据结构类"><a href="#数据结构类" class="headerlink" title="数据结构类"></a>数据结构类</h1><h2 id="Arraylist"><a href="#Arraylist" class="headerlink" title="Arraylist"></a>Arraylist</h2><h3 id="ArrayList-的本质"><a href="#ArrayList-的本质" class="headerlink" title="ArrayList 的本质"></a>ArrayList 的本质</h3><p><img src="/../../assets/image5-20231203171812-bk3gk8w.png"></p><p>​<code>ArrayList</code>​ 是 C# 提供的 <strong>非泛型集合类</strong>，属于 <code>System.Collections</code>​ 命名空间下的一个 <strong>动态数组</strong>，可以存储 <strong>任意类型的对象（object）</strong> ，容量可以动态扩展。</p><ul><li>本质上是一个支持自动扩容的 <code>object[]</code>​ 数组。</li><li>存储值类型会发生 <strong>装箱</strong>，读取时需要 <strong>拆箱</strong>，性能略低于泛型集合如 <code>List&lt;T&gt;</code>​。</li><li>在 .NET 泛型集合 (<code>System.Collections.Generic</code>​) 出现之前常用，现代开发建议使用 <code>List&lt;T&gt;</code>​ 替代。</li></ul><p>‍</p><h3 id="Arraylist引用命名空间与声明语法"><a href="#Arraylist引用命名空间与声明语法" class="headerlink" title="Arraylist引用命名空间与声明语法"></a>Arraylist引用命名空间与声明语法</h3><p>‍</p><p><img src="/../../assets/image6-20231203171812-2y47xjt.png"></p><p>‍</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用命名空间</span></span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的 ArrayList</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">// 创建并初始化</span></span><br><span class="line">ArrayList list2 = <span class="keyword">new</span> ArrayList() &#123; <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>, <span class="literal">true</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="ArrayList的增删查改"><a href="#ArrayList的增删查改" class="headerlink" title="ArrayList的增删查改"></a><strong>ArrayList的增删查改</strong></h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加（Add）</span></span><br><span class="line"><span class="comment">//由于arraylist是object类型，所以可以加任何类型</span></span><br><span class="line">list.Add(<span class="string">&quot;字符串&quot;</span>);</span><br><span class="line">list.Add(<span class="number">123</span>);     <span class="comment">// 装箱操作（int → object）</span></span><br><span class="line">list.Add(<span class="literal">true</span>);</span><br><span class="line">list.AddRange(list2)<span class="comment">//把list2所有元素添加到list的末尾</span></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">list.Remove(<span class="string">&quot;字符串&quot;</span>);   <span class="comment">// 删除第一个匹配项</span></span><br><span class="line">list.RemoveAt(<span class="number">0</span>);        <span class="comment">// 删除指定索引处元素</span></span><br><span class="line">list.Clear();            <span class="comment">// 清空所有元素</span></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="keyword">var</span> box = list[<span class="number">0</span>];  <span class="comment">//根据索引下标查找</span></span><br><span class="line"><span class="built_in">bool</span> exists = list.Contains(<span class="string">&quot;字符串&quot;</span>); <span class="comment">// 是否存在</span></span><br><span class="line"><span class="built_in">int</span> index = list.IndexOf(<span class="number">123</span>);        <span class="comment">// 查找索引（找不到返回 -1）</span></span><br><span class="line"><span class="built_in">int</span> index = list.LastIndexOf(<span class="number">123</span>);   <span class="comment">// 查找索引（找不到返回 -1）</span></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">list[<span class="number">1</span>] = <span class="string">&quot;新的值&quot;</span>;</span><br></pre></td></tr></table></figure><p>‍</p><p><img src="/../../assets/image7-20231203171812-jehtoji.png"></p><p><img src="/../../assets/image8-20231203171812-5o83tt0.png" alt="图形用户界面, 文本 描述已自动生成"></p><p><img src="/../../assets/image9-20231203171812-l1fmbmc.png"></p><p><img src="/../../assets/image10-20231203171812-g4jfcod.png" alt="文本 描述已自动生成"></p><p><img src="/../../assets/image11-20231203171812-6deacjc.png" alt="图形用户界面, 网站 描述已自动生成"></p><p><img src="/../../assets/image12-20231203171812-rsb0dmv.png" alt="图形用户界面 描述已自动生成"></p><p><img src="/../../assets/image13-20231203171812-5q5qx59.png" alt="图形用户界面, 文本 中度可信度描述已自动生成"></p><p><img src="/../../assets/image14-20231203171812-mbqioxn.png" alt="图片包含 文本 描述已自动生成"></p><p><img src="/../../assets/image15-20231203171812-ldkaqdn.png"></p><p><img src="/../../assets/image16-20231203171812-raq6j0b.png" alt="图形用户界面, 文本 描述已自动生成"></p><h3 id="插入与遍历"><a href="#插入与遍历" class="headerlink" title="插入与遍历"></a>插入与遍历</h3><p>插入：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.Insert(<span class="number">1</span>, <span class="string">&quot;中间插入&quot;</span>);</span><br></pre></td></tr></table></figure><p>第一个参数传索引位置，第二个传插入内容</p><p><img src="/../../assets/image17-20231203171812-85crm4w.png" alt="图形用户界面, 文本 中度可信度描述已自动生成"></p><p>它和stringBuilder一样会自己扩容。</p><p>Count是已存放的长度</p><p>Capacity是数组的总长</p><p><img src="/../../assets/image18-20231203171812-dt6vcs7.png" alt="文本 描述已自动生成"></p><h3 id="迭代器遍历："><a href="#迭代器遍历：" class="headerlink" title="迭代器遍历："></a>迭代器遍历：</h3><p>当你实现了迭代器，便可用此方法遍历</p><p><img src="/../../assets/image19-20231203171812-5lwx0x3.png"></p><p>Var是类型，item是变量名 collection是进行遍历的变量名，由于array是object类型，所以将var改成object，collection改为array，意思是，将array的内容依次遍历存放到object类型当中。</p><p><img src="/../../assets/image20-20231203171812-r3usy2r.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p><h3 id="装箱拆箱："><a href="#装箱拆箱：" class="headerlink" title="装箱拆箱："></a>装箱拆箱：</h3><p><img src="/../../assets/image21-20231203171812-7n89ssh.png"></p><p><img src="/../../assets/image22-20231203171812-uovkgpx.png"></p><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p><img src="/../../assets/image23-20231203171812-3vf1pqj.png"></p><p><img src="/../../assets/image24-20231203171812-d0kuwch.png" alt="图形用户界面, 文本 描述已自动生成"></p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p><img src="/../../assets/image25-20231203171812-bu10olc.png"></p><p>只能用push一个个放</p><h3 id="取"><a href="#取" class="headerlink" title="取"></a>取</h3><p><img src="/../../assets/image26-20231203171812-22tgxak.png"></p><p>用Pop来取</p><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p><img src="/../../assets/image27-20231203171812-qxn35bz.png"></p><p>Peek用来查看栈顶的内容但是不会弹出<img src="/../../assets/image28-20231203171812-xt59kia.png" alt="图形用户界面, 文本, 应用程序, 网站 描述已自动生成"></p><p>可以查看栈中是否有查找的内容，返回bool类型</p><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p><img src="/../../assets/image29-20231203171812-783d7aw.png" alt="图形用户界面, 应用程序 描述已自动生成"></p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>由于栈不提供索引器进行遍历，所以不能用for进行遍历</p><p><img src="/../../assets/image30-20231203171812-w5m74h8.png"></p><p><img src="/../../assets/image31-20231203171812-k24d5lb.png" alt="文本 描述已自动生成"></p><p><img src="/../../assets/image32-20231203171812-mdv7csp.png" alt="图形用户界面, 文本 描述已自动生成"></p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><img src="/../../assets/image33-20231203171812-26vce3l.png"></p><p><img src="/../../assets/image34-20231203171812-6xvx09k.png" alt="图形用户界面 描述已自动生成"></p><h3 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h3><p><img src="/../../assets/image35-20231203171812-6frz594.png"></p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p><img src="/../../assets/image36-20231203171812-398arcm.png" alt="文本 描述已自动生成"></p><h3 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h3><p><img src="/../../assets/image37-20231203171812-ncupopn.png" alt="文本 中度可信度描述已自动生成"></p><p><img src="/../../assets/image38-20231203171812-t3wmld4.png" alt="文本 描述已自动生成"></p><h3 id="改-1"><a href="#改-1" class="headerlink" title="改"></a>改</h3><p>清空或者一个个出队列</p><p><img src="/../../assets/image39-20231203171812-4a8c4wu.png" alt="文本 描述已自动生成"></p><h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><p>Foreach遍历</p><p><img src="/../../assets/image40-20231203171812-sbxkq60.png" alt="图形用户界面, 文本 描述已自动生成"></p><p>转换为object数组遍历</p><p><img src="/../../assets/image41-20231203171812-yujwq45.png" alt="文本 描述已自动生成"></p><p>循环出队列</p><p><img src="/../../assets/image42-20231203171812-zgibwpq.png" alt="图形用户界面, 文本, 应用程序, 网站 描述已自动生成"></p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p><img src="/../../assets/image43-20231203171812-zexq5gx.png"></p><p><img src="/../../assets/image44-20231203171812-1r5tpcw.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p><p>键不能重复，值可以相同</p><h3 id="增-2"><a href="#增-2" class="headerlink" title="增"></a>增</h3><p>第一个参数为键，第二个参数为值</p><p><img src="/../../assets/image45-20231203171812-6ntaevp.png"></p><h3 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h3><p><img src="/../../assets/image46-20231203171812-gmlw6jz.png" alt="文本 描述已自动生成"></p><h3 id="查-2"><a href="#查-2" class="headerlink" title="查"></a>查</h3><p><img src="/../../assets/image47-20231203171812-fp6a910.png"></p><p><img src="/../../assets/image48-20231203171812-8ar9qu8.png"></p><h3 id="改-2"><a href="#改-2" class="headerlink" title="改"></a>改</h3><p><img src="/../../assets/image49-20231203171812-fk6g0tg.png" alt="文本 中度可信度描述已自动生成"></p><h3 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h3><p><img src="/../../assets/image50-20231203171812-gi6qyjy.png"> <img src="/../../assets/image51-20231203171812-xg64w4w.png"></p><p><img src="/../../assets/image52-20231203171812-78xohu1.png" alt="图形用户界面, 文本 描述已自动生成"></p><p>迭代器遍历：</p><p><img src="/../../assets/image53-20231203171812-jngacpn.png" alt="文本 描述已自动生成"></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><img src="/../../assets/image54-20231203171812-spntofp.png"></p><p><img src="/../../assets/image55-20231203171812-jmrh0fy.png"></p><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p><img src="/../../assets/image56-20231203171812-5ocnhwk.png"></p><p>使用（实现了类型参数化）</p><p><img src="/../../assets/image57-20231203171812-k7hvjaa.png"></p><p>使用多个泛型占位符</p><p><img src="/../../assets/image58-20231203171812-5r7bs9f.png" alt="文本 描述已自动生成"></p><p>初始化时赋予类型</p><p><img src="/../../assets/image59-20231203171812-9gh9k6q.png"></p><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p><img src="/../../assets/image60-20231203171812-8gywz52.png" alt="文本 低可信度描述已自动生成"></p><p>接口被继承时赋予类型，并必须实现接口的成员</p><h3 id="普通类中的泛型方法"><a href="#普通类中的泛型方法" class="headerlink" title="普通类中的泛型方法"></a>普通类中的泛型方法</h3><p><img src="/../../assets/image61-20231203171812-qdsr6ap.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p><p><img src="/../../assets/image62-20231203171812-o36eu4p.png" alt="图形用户界面, 文本 描述已自动生成"></p><p>Default用于返回类型的默认值</p><p><img src="/../../assets/image63-20231203171812-jo1fbwf.png" alt="文本 描述已自动生成"></p><p>T用于作为返回值</p><p><img src="/../../assets/image64-20231203171812-i9xajdw.png"></p><p>使用多个泛型占位符的泛型方法</p><p><img src="/../../assets/image65-20231203171812-afwgc88.png" alt="文本 描述已自动生成"></p><h3 id="泛型类中的泛型方法"><a href="#泛型类中的泛型方法" class="headerlink" title="泛型类中的泛型方法"></a>泛型类中的泛型方法</h3><p><img src="/../../assets/image66-20231203171812-kb3c45v.png" alt="文本 描述已自动生成"></p><p><img src="/../../assets/image71-20231203171812-xxzauz1.png"></p><h3 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h3><p><img src="/../../assets/image72-20231203171812-abn5ml4.png" alt="文本 描述已自动生成"></p><p>总结</p><p><img src="/../../assets/image73-20231203171812-7yoapx9.png" alt="文本 描述已自动生成"></p><h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p><img src="/../../assets/image74-20231203171812-btz1zvj.png"></p><h3 id="值类型约束"><a href="#值类型约束" class="headerlink" title="值类型约束"></a>值类型约束</h3><p><img src="/../../assets/image75-20231203171812-ycllwwb.png" alt="图片包含 文本 描述已自动生成"></p><p><img src="/../../assets/image76-20231203171812-yj9cqq3.png" alt="图形用户界面, 应用程序 描述已自动生成"></p><h3 id="引用类型约束"><a href="#引用类型约束" class="headerlink" title="引用类型约束"></a>引用类型约束</h3><p><img src="/../../assets/image77-20231203171812-rxjd65w.png" alt="文本 描述已自动生成"></p><p><img src="/../../assets/image78-20231203171812-7w1448d.png"></p><h3 id="存在无参公共构造函数："><a href="#存在无参公共构造函数：" class="headerlink" title="存在无参公共构造函数："></a>存在无参公共构造函数：</h3><p>传入的必须有公共无参构造函数，否则报错。</p><p><img src="/../../assets/image79-20231203171812-zmwy2gg.png"></p><p><img src="/../../assets/image80-20231203171812-4ktvduc.png" alt="图形用户界面 描述已自动生成"></p><p>申明了一个有无参构造函数的类，和一个无参构造函数被顶替掉的类。</p><p>有无参构造不会报错</p><p><img src="/../../assets/image81-20231203171812-ehmj0lk.png"></p><p>无无参构造报错</p><p><img src="/../../assets/image82-20231203171812-n0pkrhk.png"></p><p>如果构造函数用了private或者protected也会报错，使用抽象类的话，因为抽象类不能实例化，所以不能传抽象类</p><p>可以传所有的结构体（值类型），默认都有无参构造</p><h3 id="某个类本身或者其派生类"><a href="#某个类本身或者其派生类" class="headerlink" title="某个类本身或者其派生类"></a>某个类本身或者其派生类</h3><p>传入的必须是这个类或者其派生（继承）类</p><p>传本身</p><p><img src="/../../assets/image83-20231203171812-6n7zv0h.png" alt="图形用户界面, 文本 描述已自动生成"></p><p><img src="/../../assets/image84-20231203171812-bjxarg3.png"></p><p>传派生类</p><p><img src="/../../assets/image85-20231203171812-1fectv6.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p><p><img src="/../../assets/image86-20231203171812-79zla9r.png"></p><h3 id="接口约束"><a href="#接口约束" class="headerlink" title="接口约束"></a>接口约束</h3><p><img src="/../../assets/image88-20231203171812-x0obgkr.png" alt="文本 中度可信度描述已自动生成"></p><p><img src="/../../assets/image90-20231203171812-1he19j9.png" alt="文本 描述已自动生成"></p><p>接口不能实例化，但是遵循里氏替换</p><p><img src="/../../assets/image91-20231203171812-n4lc8rq.png" alt="图形用户界面 描述已自动生成"></p><p>或者直接填接口的继承子类（类或者接口）也是可以的</p><p><img src="/../../assets/image92-20231203171812-5cz52d0.png" alt="图形用户界面 描述已自动生成"></p><h3 id="另一个泛型本身或者派生类"><a href="#另一个泛型本身或者派生类" class="headerlink" title="另一个泛型本身或者派生类"></a>另一个泛型本身或者派生类</h3><p><img src="/../../assets/image93-20231203171812-dlhua2g.png" alt="图形用户界面, 文本, 聊天或短信 描述已自动生成"></p><p>Test4继承了Ifly接口，Ifly接口继承了U</p><p><img src="/../../assets/image94-20231203171812-mjc3kje.png"></p><h3 id="约束的组合使用"><a href="#约束的组合使用" class="headerlink" title="约束的组合使用"></a>约束的组合使用</h3><p>需要先判断是否能够组合使用</p><p><img src="/../../assets/image95-20231203171812-pe220cw.png" alt="图形用户界面, 应用程序 描述已自动生成"></p><h3 id="多个泛型分别添加约束"><a href="#多个泛型分别添加约束" class="headerlink" title="多个泛型分别添加约束"></a>多个泛型分别添加约束</h3><p><img src="/../../assets/image96-20231203171812-g6sxh0y.png" alt="文本 描述已自动生成"></p><h2 id="泛型数据结构类"><a href="#泛型数据结构类" class="headerlink" title="泛型数据结构类"></a>泛型数据结构类</h2><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><img src="/../../assets/image97-20231203171812-tfxpnwb.png"> <img src="/../../assets/image98-20231203171812-cu6pzys.png" alt="文本 描述已自动生成"></p><h3 id="增-3"><a href="#增-3" class="headerlink" title="增"></a>增</h3><p>和arraylist语法一致</p><p><img src="/../../assets/image99-20231203171812-32qjo49.png" alt="文本 描述已自动生成"></p><p><img src="/../../assets/image100-20231203171812-rl57oqs.png" alt="图形用户界面, 文本 描述已自动生成"></p><h3 id="删-2"><a href="#删-2" class="headerlink" title="删"></a>删</h3><p><img src="/../../assets/image101-20231203171812-3ic7o7s.png"></p><h3 id="查-3"><a href="#查-3" class="headerlink" title="查"></a>查</h3><p><img src="/../../assets/image102-20231203171812-pziolh5.png" alt="文本 描述已自动生成"></p><h3 id="改-3"><a href="#改-3" class="headerlink" title="改"></a>改</h3><p><img src="/../../assets/image103-20231203171812-edq5b5i.png" alt="图形用户界面, 文本 描述已自动生成"></p><h3 id="遍历-3"><a href="#遍历-3" class="headerlink" title="遍历"></a>遍历</h3><p><img src="/../../assets/image104-20231203171812-exjjn38.png"></p><h2 id="字典（dictionary）"><a href="#字典（dictionary）" class="headerlink" title="字典（dictionary）"></a>字典（dictionary）</h2><p>可以理解为是一个泛型的哈希表</p><p><img src="/../../assets/image105-20231203171812-9nh8kgj.png" alt="文本 低可信度描述已自动生成"></p><p>自定义键和值的类型</p><p><img src="/../../assets/image106-20231203171812-1uv2lm6.png" alt="图形用户界面, 文本, 应用程序, 网站 描述已自动生成"></p><h3 id="增-4"><a href="#增-4" class="headerlink" title="增"></a>增</h3><p>不能出现相同键</p><p><img src="/../../assets/image107-20231203171812-ks0hnwt.png" alt="图片包含 文本 描述已自动生成"></p><h3 id="删-3"><a href="#删-3" class="headerlink" title="删"></a>删</h3><p><img src="/../../assets/image108-20231203171812-u4yy5uv.png" alt="文本 描述已自动生成"></p><h3 id="查-4"><a href="#查-4" class="headerlink" title="查"></a>查</h3><p><img src="/../../assets/image109-20231203171812-flmgks8.png"></p><h3 id="改-4"><a href="#改-4" class="headerlink" title="改"></a>改</h3><p><img src="/../../assets/image110-20231203171812-sx8bfss.png" alt="图形用户界面, 文本 描述已自动生成"></p><h3 id="遍历-4"><a href="#遍历-4" class="headerlink" title="遍历"></a>遍历</h3><p>‍</p><p><img src="/../../assets/image111-20231203171812-gxmu11m.png">​</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>实现单向链表</p><p><img src="/../../assets/image112-20231203171812-kkqd4wv.png"></p><p>用类封装链表和创建方法</p><p>因为类是引用类型，所以可以当作指针来用</p><p><img src="/../../assets/image113-20231203171812-a9rx4yh.png"></p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><img src="/../../assets/image114-20231203171812-lynscx4.png"></p><p><img src="/../../assets/image115-20231203171812-x4mxmp5.png"></p><h3 id="增-5"><a href="#增-5" class="headerlink" title="增"></a>增</h3><p><img src="/../../assets/image116-20231203171812-k3g15z1.png" alt="文本 描述已自动生成"></p><p><img src="/../../assets/image117-20231203171812-8jveern.png"></p><h3 id="删-4"><a href="#删-4" class="headerlink" title="删"></a>删</h3><p><img src="/../../assets/image118-20231203171812-ine49e5.png" alt="文本 描述已自动生成"></p><h3 id="查-5"><a href="#查-5" class="headerlink" title="查"></a>查</h3><p><img src="/../../assets/image119-20231203171812-725ke41.png"></p><p><img src="/../../assets/image120-20231203171812-dw8z8jz.png"></p><h3 id="改-5"><a href="#改-5" class="headerlink" title="改"></a>改</h3><p><img src="/../../assets/image121-20231203171812-gjk4d7b.png" alt="文本 描述已自动生成"></p><h3 id="遍历-5"><a href="#遍历-5" class="headerlink" title="遍历"></a>遍历</h3><p><img src="/../../assets/image122-20231203171812-8kzkm7g.png" alt="图形用户界面, 文本 描述已自动生成"></p><p><img src="/../../assets/image123-20231203171812-gdz767t.png" alt="文本 描述已自动生成"></p><h2 id="泛型栈和队列"><a href="#泛型栈和队列" class="headerlink" title="泛型栈和队列"></a>泛型栈和队列</h2><p><img src="/../../assets/image124-20231203171812-h6irddk.png" alt="文本 描述已自动生成"></p><p><img src="/../../assets/image125-20231203171812-wgf968f.png" alt="文本 描述已自动生成"></p><p>泛型数据集合使用较多</p><p>泛型栈和队列</p><p><img src="/../../assets/image126-20231203171812-2ximl7u.png" alt="图示 描述已自动生成"></p><p>申明</p><p><img src="/../../assets/image127-20231203171812-sxql1ld.png"></p><p>增删查改遍历和普通的一样</p><h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><h2 id="委托的用处和语法"><a href="#委托的用处和语法" class="headerlink" title="委托的用处和语法"></a>委托的用处和语法</h2><p><img src="/../../assets/image128-20231203171812-fqjabe6.png"></p><p><img src="/../../assets/image129-20231203171812-0xb4mxb.png" alt="文本 描述已自动生成"></p><p><img src="/../../assets/image130-20231203171812-8jzs1q0.png" alt="文本 描述已自动生成"></p><p>使用前，我们先定义一个无返回值，无参数的函数</p><p><img src="/../../assets/image131-20231203171812-s4r8coh.png"></p><p>然后传入函数名，将函数装在委托里，委托的申明和类一样，</p><p><img src="/../../assets/image132-20231203171812-c3bgu0y.png"></p><p>这样，我们可以<strong>使用委托来调用函数方法</strong></p><p>使用方式：</p><p><img src="/../../assets/image133-20231203171812-9t9gr8z.png"> 第一种方式</p><p><img src="/../../assets/image134-20231203171812-y0idwi3.png"> 第二种方式</p><p><img src="/../../assets/image135-20231203171812-47vdyp3.png" alt="文本 描述已自动生成"></p><p><img src="/../../assets/image136-20231203171812-xvtva39.png" alt="文本 描述已自动生成"></p><p><img src="/../../assets/image137-20231203171812-8dlrlu5.png" alt="文本 描述已自动生成"></p><h2 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a><strong>多播委托</strong></h2><p><img src="/../../assets/image138-20231203171812-2jbk3bm.png" alt="文本 描述已自动生成"> <img src="/../../assets/image139-20231203171812-28iwec7.png" alt="文本 描述已自动生成"></p><p>此时用委托存储一个Fun函数，再用+&#x3D;可以实现存储两个ff函数，使用ff（）时，会执行两次Fun函数。</p><p>存谁+&#x3D;谁，或者直接用加号</p><p><img src="/../../assets/image140-20231203171812-gzcefms.png"></p><p>移除指定元素是移除后被委托的指定元素。使用委托后，函数不会自动移除，可以手动null；</p><p>使用系统定义好的委托Action</p><p><img src="/../../assets/image141-20231203171812-nzf803f.png" alt="图形用户界面, 文本 描述已自动生成"></p><p><img src="/../../assets/image142-20231203171812-qkg5xs7.png" alt="文本 描述已自动生成"></p><p><img src="/../../assets/image143-20231203171812-rt88r7f.png" alt="手机屏幕的截图 描述已自动生成"></p><p>系统提供的泛型委托： Func&lt;T（指定返回值类型）&gt; 委托名 &#x3D; 函数名</p><p>Func&lt;&gt;<strong>传入多个参数时，最后一个为返回值类型，前面的为传入参数类型</strong></p><p>系统提供的<strong>无参无返回值</strong>委托：Action</p><p>系统提供的<strong>有参无返回值</strong>委托：Action&lt;T（指定n个参数类型）&gt;</p><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><img src="/../../assets/image144-20231203171812-6i42neh.png"></p><p><img src="/../../assets/image145-20231203171812-o8jnsvk.png"></p><p><img src="/../../assets/image146-20231203171812-7t3dheo.png"></p><p><img src="/../../assets/image147-20231203171812-74s3k48.png"></p><p><img src="/../../assets/image148-20231203171812-ctd28n2.png"></p><p><img src="/../../assets/image149-20231203171812-brwdp35.png"></p><p><img src="/../../assets/image150-20231203171812-4yvb2dk.png" alt="文本 描述已自动生成"></p><p><img src="/../../assets/image151-20231203171812-y2oc9wi.png"></p><h4 id="C-中的事件（委托的发布和订阅、事件的发布和订阅、EventHandler类、Windows事件）"><a href="#C-中的事件（委托的发布和订阅、事件的发布和订阅、EventHandler类、Windows事件）" class="headerlink" title="C#中的事件（委托的发布和订阅、事件的发布和订阅、EventHandler类、Windows事件）"></a>C#中的事件（委托的发布和订阅、事件的发布和订阅、EventHandler类、Windows事件）</h4><p><a href="https://wenchm.blog.csdn.net/article/details/134553445?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~Ctr-1-134553445-blog-80916020.235%5Ev43%5Epc_blog_bottom_relevance_base2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~Ctr-1-134553445-blog-80916020.235%5Ev43%5Epc_blog_bottom_relevance_base2&amp;utm_relevant_index=2">C#中的事件（委托的发布和订阅、事件的发布和订阅、EventHandler类、Windows事件）</a></p><p><a href="https://www.cnblogs.com/cdaniu/p/15382744.html">C# 事件Event（个人整理）</a></p><p><a href="https://www.cnblogs.com/VvxT/archive/2011/01/06/1929216.html">C# 浅谈事件监听及任务处理（监听属性值的改变及定时执行任务）</a></p><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><h2 id="匿名函数语法和用处"><a href="#匿名函数语法和用处" class="headerlink" title="匿名函数语法和用处"></a>匿名函数语法和用处</h2><p><img src="/../../assets/image152-20231203171812-i81u0co.png" alt="图片包含 文本 描述已自动生成"></p><p><img src="/../../assets/image153-20231203171812-a0c45e8.png" alt="文本 描述已自动生成"></p><p>匿名函数不能脱离委托或者事件</p><p><img src="/../../assets/image154-20231203171812-v1ixhjf.png"></p><p><img src="/../../assets/image155-20231203171812-gohcl9v.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p><p>使用匿名函数：</p><p>在类里使用的话，就用使用委托，为委托赋值一个匿名函数。因为事件不能在类里声明。</p><p><img src="/../../assets/image-20240417214039-pxvm13z.png" alt="image">​</p><p><img src="/../../assets/image-20240417234411-jzip4ql.png" alt="image">​</p><p><img src="/../../assets/image-20240417235308-2mi7xi7.png" alt="image">​</p><p><img src="/../../assets/image-20240418214432-42utlab.png" alt="image">​</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//无参无返回</span></span><br><span class="line">         Action func1 = <span class="built_in">delegate</span> ()</span><br><span class="line">           &#123;</span><br><span class="line"></span><br><span class="line">           &#125;;</span><br><span class="line">         <span class="comment">//有参无返回</span></span><br><span class="line">         Action&lt;<span class="built_in">int</span>&gt; func2 = <span class="built_in">delegate</span> (<span class="built_in">int</span> i)</span><br><span class="line">         &#123;</span><br><span class="line">         </span><br><span class="line">         &#125;;</span><br><span class="line">         <span class="comment">//有返回值</span></span><br><span class="line">         Func&lt;<span class="built_in">string</span>&gt; func3 = <span class="built_in">delegate</span> () &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="string">&quot;111&quot;</span>;</span><br><span class="line">         &#125;;</span><br><span class="line">         <span class="comment">//有参有返回值</span></span><br><span class="line">         <span class="comment">//&lt;&gt;里只有最后一个参数为返回值，前面的都为传入参数          </span></span><br><span class="line">         Func&lt;<span class="built_in">string</span>, <span class="built_in">int</span>,<span class="built_in">string</span>&gt; fun4 = <span class="built_in">delegate</span> (<span class="built_in">string</span> a,<span class="built_in">int</span> b) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="string">&quot;11&quot;</span>;</span><br><span class="line">         &#125;;</span><br></pre></td></tr></table></figure><pre><code>一般匿名函数可作为参数传递，没学匿名函数之前，我们是先声明一个函数，再将函数名传递进去作为参数，现在我们可以直接写一个匿名函数直接传参。</code></pre><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个测试类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//委托，存储方法</span></span><br><span class="line">            <span class="keyword">public</span> Action action;</span><br><span class="line"><span class="comment">//函数作为参数的方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dosomething</span>(<span class="params"><span class="built_in">int</span> a,Action action</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(a);</span><br><span class="line">                <span class="comment">//执行委托里的函数</span></span><br><span class="line">                action();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//匿名函数作为参数传入</span></span><br><span class="line"> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">            test.Dosomething(<span class="number">10</span>, <span class="built_in">delegate</span> ()</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;随参数传入的匿名函数逻辑&quot;</span>);</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><pre><code>匿名函数还可以作为返回值返回给委托储存</code></pre><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test2</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">//返回值为函数的方法</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Action <span class="title">GetFunc</span>()</span></span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">delegate</span> () &#123;</span><br><span class="line">                  <span class="comment">//作为返回值的匿名函数逻辑</span></span><br><span class="line">              &#125;;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//使用方法：</span></span><br><span class="line">Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">Action action = test2.GetFunc();</span><br><span class="line">action();</span><br><span class="line"><span class="comment">//一步到位</span></span><br><span class="line">    Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">          test2.GetFunc()();</span><br></pre></td></tr></table></figure><h2 id="匿名函数缺点："><a href="#匿名函数缺点：" class="headerlink" title="匿名函数缺点："></a>匿名函数缺点：</h2><p>委托可以多播委托，当我们传入多个函数给委托时，传入的匿名函数无法被指定清除，要想清除只能用清空方法</p><p><img src="/../../assets/image-20240418221827-irft2py.png" alt="image">​</p><p><img src="/../../assets/image-20240418222510-q9rcrtt.png" alt="image">​</p><h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><h2 id="回调函数的理解"><a href="#回调函数的理解" class="headerlink" title="回调函数的理解"></a>回调函数的理解</h2><pre><code>字面上的理解，回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。其实很好理解，回调，回调，就是回头调用的意思。主函数的事先干完，回头再调用传进来的那个函数。使用回调函数有两种写法，使用委托或者事件。</code></pre><h2 id="回调函数的使用"><a href="#回调函数的使用" class="headerlink" title="回调函数的使用"></a>回调函数的使用</h2><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用委托实现回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CallbackDelegate</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法1：执行某个任务并接受回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoWork</span>(<span class="params">CallbackDelegate callback</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;执行任务...&quot;</span>);</span><br><span class="line">        <span class="comment">// 模拟任务完成后调用回调函数</span></span><br><span class="line">        callback(<span class="string">&quot;任务完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 定义一个回调函数</span></span><br><span class="line">        CallbackDelegate myCallback = (message) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;回调信息: <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 调用DoWork，并传递回调函数</span></span><br><span class="line">        DoWork(myCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用事件实现回调函数</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 方法2：使用Action作为回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoWork</span>(<span class="params">Action&lt;<span class="built_in">string</span>&gt; callback</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;执行任务...&quot;</span>);</span><br><span class="line">        callback(<span class="string">&quot;任务完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用Action传递回调</span></span><br><span class="line">        DoWork((message) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;回调信息: <span class="subst">&#123;message&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Lamda表达式"><a href="#Lamda表达式" class="headerlink" title="Lamda表达式"></a>Lamda表达式</h1><h3 id="什么是lamda表达式"><a href="#什么是lamda表达式" class="headerlink" title="什么是lamda表达式"></a>什么是lamda表达式</h3><p><img src="/../../assets/image-20240418222836-vbcvtox.png" alt="image"></p><h3 id="Lamda表达式语法"><a href="#Lamda表达式语法" class="headerlink" title="Lamda表达式语法"></a>Lamda表达式语法</h3><p><img src="/../../assets/image-20240418222930-622w1jx.png" alt="image">​</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><img src="/../../assets/image-20240418223100-f2vcjba.png" alt="image">​</p><p><img src="/../../assets/image-20240418223257-d8t727p.png" alt="image">​</p><p><img src="/../../assets/image-20240418223418-dkmnhbr.png" alt="image">​</p><p><img src="/../../assets/image-20240418223614-zz88c1c.png" alt="image">、</p><p>缺点和匿名函数缺点一样</p><p><img src="/../../assets/image-20240418231103-5ufe8z1.png" alt="image">​</p><h3 id="闭包（重要）"><a href="#闭包（重要）" class="headerlink" title="闭包（重要）"></a>闭包（重要）</h3><p><a href="https://www.cnblogs.com/eventhorizon/p/9535289.html">https://www.cnblogs.com/eventhorizon/p/9535289.html</a></p><p><a href="https://www.cnblogs.com/pangjianxin/p/8400155.html">https://www.cnblogs.com/pangjianxin/p/8400155.html</a>这个讲的比较好</p><pre><code>我们把在Lambda表达式(或匿名方法)中所引用的外部变量称为**捕获变量**。而捕获变量的表达式就称为**闭包**。捕获的变量会在真正**调用委托**时“赋值”，而不是在捕获时“赋值”，即总是使用捕获变量的**最新的值**。</code></pre><p><img src="/../../assets/image-20240418223807-g6892gn.png" alt="image">​</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test3</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">event</span> Action action;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="title">Test3</span>()</span></span><br><span class="line">           &#123;</span><br><span class="line">               <span class="built_in">int</span> <span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line">               <span class="comment">//这里就形成了闭包</span></span><br><span class="line">               <span class="comment">//因为当构造函数执行完毕时，其中申明的临时变量value的生命周期被改变了</span></span><br><span class="line">               <span class="comment">//因为当构造函数执行时，value就被存到事件函数action里，不会被释放</span></span><br><span class="line">               action = () =&gt; &#123;</span><br><span class="line">                   Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">               &#125;;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//由于lamda表达式对临时变量i的捕获，延长了其生命周期</span></span><br><span class="line">               <span class="comment">//所以当for循环执行完时，事件action里存放的i的值都为10，可以用地址来理解</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">               &#123;</span><br><span class="line">                   action += () =&gt;</span><br><span class="line">                   &#123;</span><br><span class="line">                       Console.WriteLine(i);</span><br><span class="line">                   &#125;;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h1 id="List排序（重要）"><a href="#List排序（重要）" class="headerlink" title="List排序（重要）"></a>List排序（重要）</h1><h2 id="List自带排序方法"><a href="#List自带排序方法" class="headerlink" title="List自带排序方法"></a>List自带排序方法</h2><p>这个排序可以进行值类型（int、float）的排序</p><p>List之所以可以用Sort（）来进行排序，是因为List继承并实现了接口IComparable，Sort（）调用了C#帮我们实现的值类型比较接口。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建列表对象</span></span><br><span class="line"><span class="comment">//可对int、float、double等值类型进行排序</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">list.Add(<span class="number">3</span>);</span><br><span class="line">list.Add(<span class="number">5</span>);</span><br><span class="line">list.Add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//自带排序</span></span><br><span class="line">list.Sort();</span><br><span class="line"><span class="comment">//对float进行排序</span></span><br><span class="line">List&lt;<span class="built_in">float</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">float</span>&gt;();</span><br><span class="line">    list.Add(<span class="number">1.4f</span>);</span><br><span class="line">    list.Add(<span class="number">1.23f</span>);</span><br><span class="line">    list.Add(<span class="number">2.11f</span>);</span><br><span class="line">    list.Sort();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="自定义类的排序"><a href="#自定义类的排序" class="headerlink" title="自定义类的排序"></a>自定义类的排序</h2><pre><code>为了可以让自定义的类也可以进行排序， 我们要让自定义的类继承C#的IComparable&lt;&gt;泛型接口，并实现该接口。</code></pre><p>这样使用Sort（）方法可以调用我们实现的接口方法。</p><p>‍</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Item</span> :<span class="title">IComparable</span>&lt;<span class="title">Item</span>&gt;<span class="comment">//继承IComparable接口</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">string</span> name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">float</span> money &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Item</span>(<span class="params"><span class="built_in">string</span> name,<span class="built_in">float</span> money</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.name = name;</span><br><span class="line">                <span class="keyword">this</span>.money = money;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//实现接口包含的比较方法：</span></span><br><span class="line"><span class="comment">//返回值为负数表示在前，为0表示位置不变，为1表示在后</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params">Item other</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.money&gt;other.money)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//调用List里的Sort()方法</span></span><br><span class="line">List&lt;Item&gt; items = <span class="keyword">new</span> List&lt;Item&gt;();</span><br><span class="line"> items.Add(<span class="keyword">new</span> Item(<span class="string">&quot;辣条&quot;</span>,<span class="number">2.5f</span>));</span><br><span class="line">            items.Add(<span class="keyword">new</span> Item(<span class="string">&quot;棒棒糖&quot;</span>, <span class="number">1.5f</span>));</span><br><span class="line">            items.Add(<span class="keyword">new</span> Item(<span class="string">&quot;巧克力&quot;</span>,<span class="number">1.0f</span>));</span><br><span class="line">            items.Sort();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; items.Count; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(items[i].name + items[i].money);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="通过委托函数进行排序"><a href="#通过委托函数进行排序" class="headerlink" title="通过委托函数进行排序"></a>通过委托函数进行排序</h2><pre><code>List的Sort()方法有个委托重载，这可以让我们使用委托函数来进行排序。这样我们就可以传入函数了，这时我们可以使用匿名函数或者lamda表达式作为参数传入。甚至为了代码简洁，还能用到三目运算符。</code></pre><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义自定义的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ShopItem</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> id;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">ShopItem</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.id = id;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//使用lamda表达式进行排序</span></span><br><span class="line"> List&lt;ShopItem&gt; shopitem = <span class="keyword">new</span> List&lt;ShopItem&gt;();</span><br><span class="line">            shopitem.Add(<span class="keyword">new</span> ShopItem(<span class="number">1</span>));</span><br><span class="line">            shopitem.Add(<span class="keyword">new</span> ShopItem(<span class="number">4</span>));</span><br><span class="line">            shopitem.Add(<span class="keyword">new</span> ShopItem(<span class="number">3</span>));</span><br><span class="line">            shopitem.Add(<span class="keyword">new</span> ShopItem(<span class="number">2</span>));</span><br><span class="line"><span class="comment">//sort有委托重载，所以可以传入lamda函数</span></span><br><span class="line">            shopitem.Sort((a, b) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a.id&gt;b.id)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;**********&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (ShopItem item <span class="keyword">in</span> shopitem)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(item.id);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//还可以写得更简单（使用三目运算符）：</span></span><br><span class="line">            shopitem.Sort((a, b) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line"><span class="comment">//使用三目运算符</span></span><br><span class="line">               <span class="keyword">return</span> a.id &gt; b.id ? <span class="number">1</span> :<span class="number">-1</span>;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>在实际开发中， 我们会经常用到List 的Sort排序，例如背包物品的排序，商店物品的排序等。</code></pre><p><img src="/../../assets/image-20240419124414-dzq7vqd.png" alt="image"></p><p>‍</p><h1 id="协变逆变"><a href="#协变逆变" class="headerlink" title="协变逆变"></a>协变逆变</h1><p><img src="/../../assets/image-20240419194109-itx4xr4.png" alt="image">​</p><p>作用：</p><p><img src="/../../assets/image-20240419194412-x1hjgrq.png" alt="image">​</p><pre><code>协变和逆变的使用主要在委托的装载原则上。用out修饰的泛型委托，可以使用父类泛型委托装子类泛型委托。用in修饰的泛型委托，可以用子类泛型委托替代父类泛型委托。根据里氏替换原则，我们认为父类装子类是协和的，而子类装父类则有些违反我们的认知，所以叫协变和逆变。</code></pre><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.结合里氏替换原则理解</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//out修饰T 只能作为返回值</span></span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> T <span class="title">Test_out</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;()</span>;</span><br><span class="line">    <span class="comment">//In修饰T 只能作为传入参数</span></span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Test_in</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T t</span>)</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Father</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Son</span> : <span class="title">Father</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//测试：</span></span><br><span class="line"><span class="comment">//1.协变：父类能替代子类</span></span><br><span class="line"><span class="comment">//使用子类返回值委托</span></span><br><span class="line">            Test_out&lt;Son&gt; son = () =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Son();</span><br><span class="line">            &#125;;</span><br><span class="line"><span class="comment">//父类委托装子类委托</span></span><br><span class="line"><span class="comment">//如果Test_out委托没有out修饰，就会报错</span></span><br><span class="line">            Test_out&lt;Father&gt; father= son;</span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line"><span class="comment">//2.逆变：父类可以被子类替代</span></span><br><span class="line"><span class="comment">//使用父类作为传入参数的委托</span></span><br><span class="line">Test_in&lt;Father&gt; father = (<span class="keyword">value</span>) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">            &#125;;</span><br><span class="line"><span class="comment">//子类委托装父类委托</span></span><br><span class="line">Test_in&lt;Son&gt; son = father;</span><br></pre></td></tr></table></figure><p><img src="/../../assets/image-20240419202401-q550up6.png" alt="image">​</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p><img src="/../../assets/image-20240419202542-7q62e4x.png" alt="image">​</p><p><img src="/../../assets/image-20240419202612-vn4duqx.png" alt="image">​</p><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p><img src="/../../assets/image-20240419202750-8kkocqe.png" alt="image">​</p><p><img src="/../../assets/image-20240419202848-w8qkfxu.png" alt="image">​</p><h2 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h2><p><img src="/../../assets/image-20240419202935-xwhjajz.png" alt="image"></p><p><img src="/../../assets/image-20240419202951-9xvpzm6.png" alt="image">​</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><img src="/../../assets/image-20240419203316-bi83pd5.png" alt="image"></p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//运行标识</span></span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">bool</span> isRuning=<span class="literal">true</span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1.申明一个线程</span></span><br><span class="line">            <span class="comment">//将想要执行的函数作为参数传入</span></span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(NewThreadFunc);</span><br><span class="line">            <span class="comment">//2.起动线程</span></span><br><span class="line">            t.Start();</span><br><span class="line">            <span class="comment">//3.设置为后台线程</span></span><br><span class="line">            <span class="comment">//如果线程的逻辑为死循环，那么不设置为后台线程，则新开线程在主线程结束后不会结束</span></span><br><span class="line">            t.IsBackground = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//4.关闭释放一个线程</span></span><br><span class="line">            <span class="comment">// 如果是死循环，想要释放有两个方法</span></span><br><span class="line">                <span class="comment">//1.申明static bool isRunning=true;</span></span><br><span class="line">            <span class="comment">//将isRunning作为while的参数，设置isRunning=false，关闭线程</span></span><br><span class="line">            isRuning = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//2.使用线程自带方法(在.net core无法使用该方法)</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                t.Abort();</span><br><span class="line">                t = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//封装线程执行的逻辑</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewThreadFunc</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//5.线程休眠</span></span><br><span class="line">            <span class="comment">//毫秒为单位，在哪个线程里写，就让哪个线程休眠几秒</span></span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//线程执行的死循环逻辑，可以不是死循环</span></span><br><span class="line">            <span class="keyword">while</span> (isRuning)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;线程逻辑&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="线程之间的共享数据（重要）​"><a href="#线程之间的共享数据（重要）​" class="headerlink" title="线程之间的共享数据（重要）​"></a>线程之间的共享数据（重要）<img src="/../../assets/image-20240419210629-dj4fgxw.png" alt="image">​</h2><pre><code>lock解决了当多个线程访问同一个内存的东西时，会导致的逻辑执行顺序问题。这是一种解决方案，但并不是最优解，想要更好的性能优化可以了解其他锁。</code></pre><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//运行标识</span></span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">bool</span> isRuning=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//申明一个引用类型，供lock使用</span></span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">object</span> obj;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(NewThreadFunc);</span><br><span class="line">            t.Start();</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//使用加锁，参数为引用类型</span></span><br><span class="line">                <span class="comment">//意思是，当obj没被锁的时候，就会锁住obj，执行代码</span></span><br><span class="line">                <span class="comment">//执行完会解锁</span></span><br><span class="line">                <span class="keyword">lock</span> (obj)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//封装线程执行的逻辑</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewThreadFunc</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (isRuning)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//使用加锁，参数为引用类型</span></span><br><span class="line">                <span class="comment">//意思是，当obj没被锁的时候，就会锁住obj，执行代码</span></span><br><span class="line">                <span class="comment">//执行完会解锁</span></span><br><span class="line">                <span class="keyword">lock</span> (obj)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;线程逻辑&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="多线程的意义"><a href="#多线程的意义" class="headerlink" title="多线程的意义"></a>多线程的意义</h2><pre><code>当我们进行一些特别复杂的逻辑时，可能会导致卡顿，所以我们可以开一个线程来进行复杂的运算，从而让主线程可以流程运行。</code></pre><p><img src="/../../assets/image-20240419211732-k2ogczb.png" alt="image"></p><p><img src="/../../assets/image-20240419212034-ah7260n.png" alt="image">​</p><h1 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h1><p><img src="/../../assets/image-20240419221222-dct5x85.png" alt="image">​</p><p><img src="/../../assets/image-20240419221242-pq4rxko.png" alt="image">​</p><p><img src="/../../assets/image-20240419221339-2xvu6w4.png" alt="image">​</p><p><img src="/../../assets/image-20240419221757-dusnt18.png" alt="image"></p><p><img src="/../../assets/image-20240419222055-zafsmoe.png" alt="image">​</p><p><img src="/../../assets/image-20240419222218-3las1xt.png" alt="image"></p><p><img src="/../../assets/image-20240419222229-f1wp6xd.png" alt="image">​</p><p><img src="/../../assets/image-20240419222327-pc6892j.png" alt="image">​</p><h1 id="反射和特性"><a href="#反射和特性" class="headerlink" title="反射和特性"></a>反射和特性</h1><h2 id="什么是程序集"><a href="#什么是程序集" class="headerlink" title="什么是程序集"></a>什么是程序集</h2><p><img src="/../../assets/image-20240420085722-vsjz5f6.png" alt="image">​</p><p><img src="/../../assets/image-20240420085856-cvsgekl.png" alt="image">​</p><p><img src="/../../assets/image-20240420090000-89tu8lq.png" alt="image">​</p><p><img src="/../../assets/image-20240420091009-x8k537a.png" alt="image">​</p><p><img src="/../../assets/image-20240420091307-sdd7hql.png" alt="image"></p><p><img src="/../../assets/image-20240420091617-hqr5izv.png" alt="image">​</p><p>‍</p><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p><img src="/../../assets/image-20240420103612-bkiya5b.png" alt="image">​</p><p><img src="/../../assets/image-20240420105319-gyj2vvh.png" alt="image">​</p><p><img src="/../../assets/image-20240420104605-kjt2ge0.png" alt="image">​</p><p><img src="/../../assets/image-20240420104757-uv4eik0.png" alt="image">​</p><p><img src="/../../assets/image-20240420105243-dr8j6f4.png" alt="image">​</p><p>‍</p><p>‍</p><p>‍</p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="什么是LinQ？用来干什么？"><a href="#什么是LinQ？用来干什么？" class="headerlink" title="什么是LinQ？用来干什么？"></a>什么是LinQ？用来干什么？</h2><pre><code>LINQ（Language Integrated Query）是一种C#语言中的**查询技术**，它允许我们在代码中使用**类似SQL的查询语句来操作各种数据源**。这些数据源可以是集合、数组、数据库、XML文档等等。LINQ提供了一种统一的编程模型，使我们能够使用相同的方式来查询和操作不同类型的数据。比如我们可以用LinQ来操作SQL server数据库。除此之外，我们还可以操作数组、枚举集合、泛型列表等。</code></pre><h2 id="C-中的LINQ语法"><a href="#C-中的LINQ语法" class="headerlink" title="C#中的LINQ语法"></a>C#中的LINQ语法</h2><h3 id="使用-LINQ（Language-Integrated-Query）语法在-C-中进行查询操作"><a href="#使用-LINQ（Language-Integrated-Query）语法在-C-中进行查询操作" class="headerlink" title="使用 LINQ（Language-Integrated Query）语法在 C# 中进行查询操作"></a>使用 LINQ（Language-Integrated Query）语法在 C# 中进行查询操作</h3><p>‍</p><p>文章：<a href="https://blog.csdn.net/lgj123xj/article/details/134008760">C# Linq基本功 —— 必学的必熟的10个方法</a></p><p>‍</p><h4 id="1-检索List列表中装载的对象的属性"><a href="#1-检索List列表中装载的对象的属性" class="headerlink" title="1.检索List列表中装载的对象的属性"></a>1.检索List列表中装载的对象的属性</h4><pre><code>我们知道，当我们用List类对象装载了一个类的多个对象时，我们不能通过直接List类对象名点出来他包含的类对象的属性，只能通过Foreach循环来通过索引器来遍历。LINQ中的=&gt;语法可以让我们直接通过List类对象直接对其包含的类对象的属性进行检索。  </code></pre><p>例：</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Paper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> String PaperName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"><span class="comment">//  public List&lt;Question&gt; paper = new List&lt;Question&gt;();</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Content &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Score &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Paper&gt; Papers = <span class="keyword">new</span> List&lt;Paper&gt;();</span><br><span class="line"><span class="comment">//假设Papers中已经添加了多个Paper对象，我们可以通过以下方法来检索Paper属性，筛选出来满足条件的对象。</span></span><br><span class="line">Paper f = Papers.Find(Papers=&gt;Papers.PaperName==“检索内容”);</span><br></pre></td></tr></table></figure><h1 id="C-面试题"><a href="#C-面试题" class="headerlink" title="C#面试题"></a>C#面试题</h1><p><a href="https://www.cnblogs.com/anding/p/5229756.html">.NET面试题解析(00)-开篇来谈谈面试 &amp; 系列文章索引</a></p><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> Csharp相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Csharp </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity使用Luban+LitJson插件实现Excel转Json，Xml等并进行读取。</title>
      <link href="/2025/05/26/Unity/Unity%E4%BD%BF%E7%94%A8Luban+LitJson%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0Excel%E8%BD%ACJson%EF%BC%8CXml%E7%AD%89%E5%B9%B6%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%8F%96%E3%80%82/"/>
      <url>/2025/05/26/Unity/Unity%E4%BD%BF%E7%94%A8Luban+LitJson%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0Excel%E8%BD%ACJson%EF%BC%8CXml%E7%AD%89%E5%B9%B6%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%8F%96%E3%80%82/</url>
      
        <content type="html"><![CDATA[<h2 id="配置Luban环境并创建Unity项目"><a href="#配置Luban环境并创建Unity项目" class="headerlink" title="配置Luban环境并创建Unity项目"></a>配置Luban环境并创建Unity项目</h2><p><a href="https://luban.doc.code-philosophy.com/docs/beginner/quickstart">Luban官方文档</a></p><ol><li><p>安装<a href="https://dotnet.microsoft.com/download/dotnet/8.0">dotnet sdk 8.0</a>或更高版本sdk。（根据自己的系统下载对应的sdk。我的是windows所以我用的Windows x64版本）</p></li><li><p>下载<a href="https://gitee.com/focus-creative-games/luban_examples">luban_examples项目</a>。（Gitee需要登陆才能下载，如果不想登录可以去Github下载。这里放上Luban的Github链接：<a href="https://github.com/focus-creative-games/luban_examples">https://github.com/focus-creative-games/luban_examples</a>）</p></li></ol><p><img src="/../../assets/image-20250526201117-miykfr6.png" alt="image"></p><p>下载完成后我们新建一个Unity项目，准备将Luban部署到Unity项目里。</p><p>创建好Unity项目后，打开Unity项目目录创建一个  <code>LubanConfig </code>​ 。然后将我们下载的Luban插件里 <code>Tools/Luban</code>​ 和 <code>MiniTemplate</code>​ 文件夹放进去。</p><p><img src="/../../assets/image-20250526202416-pqurkkj.png" alt="image"></p><p><img src="/../../assets/image-20250526202726-rcu9aqo.png" alt="image"></p><p>接下来我们打开刚刚放进 <code>LubanConfig/MiniTemplate</code>​ 文件夹。</p><p>Datas文件夹是我们创建Excel配置表的地方。</p><p>Output是我们点击gen.bat后生成Json、Xml文件的地方。</p><p>接下来我们修改一下生成Json、Xml文件的存放路径。</p><p>右键编辑 <code>gen.bat</code>​ 文件</p><p>我们打开gen.bat文件后长这样：</p><p><img src="/../../assets/image-20250526203736-sabtz97.png" alt="image"></p><p>我们需要修改路径地址为我们Unity项目Assets文件夹下存放数据文件的路径，我的是：<code>Game_Demo/../../assets/Project/DataTable</code>​</p><p>由于我们所在的文件夹是<code>你的Unity项目名称/LubanConfig/MiniTemplate</code>​ ，所以需要后退两次到项目文件夹。</p><p><img src="/../../assets/image-20250526204309-5c79zrq.png" alt="image"></p><p>简单介绍 bat 文件中各项参数：</p><ul><li>​<code>LUBAN_DLL</code>​ Luban.dll 文件的路径。指向 luban_examples&#x2F;Tools&#x2F;Luban&#x2F;Luban.dll</li><li>​<code>CONF_ROOT </code>​配置项目的路径。指向 luban_examples&#x2F;DesignerConfigs</li><li>​<code>-t </code>​生成目标。可以为 client、server、all 之类的值</li><li>​<code>-c</code>​ 生成的代码类型。 cs-simple-json 为生成使用 SimpleJSON 加载 json 数据的 c# 代码</li><li>​<code>-d</code>​ 生成的数据类型。 如果我们想生成其他类型，将后面的json改为需要类型即可，比如xml。</li><li>​<code>inputDataDir </code>​配置表（如 xlsx ）的根目录</li><li>​<code>outputCodeDir</code>​ c# 代码的输出目录</li><li>​<code>outputDataDir </code>​json 数据的输出目录</li></ul><p>运行该脚本，如果一切正常，会产生一系列日志，最终一行是 bye~。</p><h2 id="创建Excel配置文件生成Json、xml等文件"><a href="#创建Excel配置文件生成Json、xml等文件" class="headerlink" title="创建Excel配置文件生成Json、xml等文件"></a>创建Excel配置文件生成Json、xml等文件</h2><p>配置到Unity之后我们就可以进行Excel配表了。可以看<a href="https://luban.doc.code-philosophy.com/docs/beginner/quickstart#%E5%88%9B%E5%BB%BAreward%E8%A1%A8">Luban官方文档快速上手</a>跟着创建reward.xlsx配置表。</p><p>不想来回切页面可以跟着我一起创建。</p><p>配置好之后我们进入 <code>MiniTemplate/Datas</code>​ 文件夹。</p><p><img src="/../../assets/image-20250526204719-ajh9daq.png" alt="image"></p><p>​<code>#demo.item.xlsx</code>​ 文件是Luban的一个示例文件，打开长这样。</p><p><img src="/../../assets/image-20250526204933-srothvx.png" alt="image"></p><p>简略介绍一下文件格式：</p><ul><li>第1行是字段名行。单元格 A1 必须以##开头。表示这是一个有效数据表。</li><li>第2行是字段类型行。第1个单元格必须为 ##type。</li><li>第3行是分组行。<code>c</code>​表示字段属于客户端，<code>s</code>​表示属于属于服务器,<code>c,s</code>​表示同时属于所有，留空也表示属于所有。</li><li>第4行是注释行。 以##开头。 可以有0-N个注释行，而且可以出现在任何位置</li><li>第5行起是数据行。</li></ul><p>luban并没有限制标题头行的位置和数量。像##xxx之类的行可以任意调整顺序和位置，而##group和##行也是可选的。</p><p>接下来我们可以直接删了这个 <code>#demo.item.xlsx</code>​ 文件，因为他一会儿会跟着生成Json文件。</p><p>在当前Datas页面创建一个 <code>reward.xlsx</code>​ 文件。具体内容如下</p><p><img src="/../../assets/image-20250526205631-d2jo9zz.png" alt="image"></p><p>‍</p><p>创建好我们的 <code>reward.xlsx</code>​ 配置表后，我们需要在主表中加入我们创建好的 <code>reward.xlsx</code>​ 参数和路径。</p><p><img src="/../../assets/image-20250526205808-v7kajif.png" alt="image"></p><p>‍</p><p>表字段说明：</p><table><thead><tr><th>字段</th><th>可空</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>full_name</td><td>否</td><td></td><td>类型全名，即可以是不包含命名空间，如 Hello，也可以包含命名空间如 item.Item</td></tr><tr><td>flags</td><td>是</td><td>false</td><td>等价schema逻辑结构中isFlags字段</td></tr><tr><td>unique</td><td>是</td><td>false</td><td>当前enum内的所有枚举值必须唯一，等价schema逻辑结构中isUniqueItemId字段</td></tr><tr><td>comment</td><td>是</td><td></td><td></td></tr><tr><td>tags</td><td>是</td><td></td><td>填写方式为 key1=value1#key2=value2…</td></tr><tr><td>items</td><td>否</td><td></td><td>枚举项列表</td></tr></tbody></table><p>‍</p><p>配置好后我们可以点击 <code>gen.bat</code>​ 测试能否生成Json文件了</p><p><img src="/../../assets/image-20250526211412-8zrd3xd.png" alt="image"></p><p>打开unity看一看，没有问题。</p><p><img src="/../../assets/image-20250526211446-8zm2jy4.png" alt="image"></p><h2 id="使用LitJson读取Json文件。"><a href="#使用LitJson读取Json文件。" class="headerlink" title="使用LitJson读取Json文件。"></a>使用LitJson读取Json文件。</h2><p>在我们的Assets文件夹里创建一个Scripts文件夹，创建一个 <code>demo.cs</code>​ 文件。用Visual Studio打开。</p><p>然后我们点击 <code>工具 - &gt; NuGet包管理器 - &gt; 管理解决方案的NuGet包</code>​ 在浏览里搜索LitJson，点击安装。我这已经安装好了。</p><p><img src="/../../assets/image-20250526212750-u1m7s0k.png" alt="image"></p><p>接着在我们Unity项目根目录里找到Packages文件夹，打开可以看到我们下载的LitJson。</p><p>接下来我们打开LitJson文件夹，找到对应版本NET文件夹下的LitJSON.dll。把这个文件放在 <code>../../assets/Plugins</code>​ 文件夹下即可</p><p><img src="/../../assets/image-20250526212901-owxlfzq.png" alt="image"></p><p>不同版本的Unity默认的Mono虚拟机版本不同，可能需要导入不同版本的程序库。选择主菜单的Edit→Project Settings，打开Project Settings，选择左侧Player（播放器，）然后再右侧的Other Settings中找到Scripting Runtime Version，可以看到当前脚本运行环境的版本</p><p>也可以用脚本来查看，可以在脚本中通过以下方式来查看：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">string</span> <span class="string">unityVersion</span> <span class="string">=</span> <span class="string">Application.unityVersion;</span></span><br><span class="line"><span class="string">Debug.Log(&quot;当前Unity版本：&quot;</span> <span class="string">+</span> <span class="string">unityVersion);</span></span><br></pre></td></tr></table></figure><p>这样就能够在Unity编辑器的控制台中看到当前脚本运行环境的版本信息。</p><p>‍</p><p>我的是.Net Standard 2.0，所以我就将 <code>LitJson/lib/netstandard2.0/LitJSON.dll</code>​ 文件放进去了。</p><p><img src="/../../assets/image-20250526213702-hnpe93u.png" alt="image"></p><p>导入后我们就可以写我们的读取代码了：</p><p>以下是 <code>Demo.cs</code>​ 代码</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> LitJson;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Demo</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Weapon</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> id;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> desc;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> jsonStr;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        jsonStr = File.ReadAllText(Application.dataPath + <span class="string">&quot;/Project/DataTable/demo_tbreward.json&quot;</span>);</span><br><span class="line">        <span class="comment">// Weapon[] arr = JsonMapper.ToObject&lt;Weapon[]&gt;(jsonStr);</span></span><br><span class="line">        List&lt;Weapon&gt; list = JsonMapper.ToObject&lt;List&lt;Weapon&gt;&gt;(jsonStr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> list)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(item.name + <span class="string">&quot; &quot;</span> + item.desc + <span class="string">&quot; &quot;</span> + item.count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注解：</p><ul><li><p><strong>Application：</strong> 是Stream.IO的一个类，用于操作和获取当前应用程序的信息。</p></li><li><p><strong>Application.dataPath ：</strong> 属性，返回应用程序的数据路径。（……&#x2F;你的Unity项目名称&#x2F;..&#x2F;..&#x2F;assets&#x2F;）</p></li><li><p><strong>JsonMapper：</strong>  是LitJson的一个工具类，存有静态方法。</p></li><li><p><strong>JsonMapper.ToObject(json)：</strong> 将一个json字符串解析成一个类对象</p></li><li><p><strong>JsonMapper.ToJson：</strong> 将一个类对象转化成一个json字符串</p></li></ul><p>敲完之后点击运行：</p><p><img src="/../../assets/image-20250526220631-1dz24rc.png" alt="image"></p><p>读取完成，希望这篇文章对你有所帮助。</p><h2 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h2><p><a href="https://blog.csdn.net/qq_33795300/article/details/131364030#:~:text=Unity%E7%9A%84Application%E7%B1%BB%E6%8F%90%E4%BE%9B%E4%BA%86%E8%8E%B7%E5%8F%96%E5%92%8C%E6%93%8D%E4%BD%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BF%A1%E6%81%AF%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E5%A6%82%E7%89%88%E6%9C%AC%E3%80%81%E8%BF%90%E8%A1%8C%E5%B9%B3%E5%8F%B0%E3%80%81%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84%E7%AD%89%E3%80%82,%E5%AE%83%E5%8C%85%E6%8B%ACidentifier%E3%80%81version%E3%80%81unityVersion%E3%80%81productName%E3%80%81companyName%E7%AD%89%E5%B1%9E%E6%80%A7%EF%BC%8C%E4%BB%A5%E5%8F%8AisEditor%E3%80%81isFocused%E3%80%81isPlaying%E7%AD%89%E6%96%B9%E6%B3%95%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%88%A4%E6%96%AD%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E3%80%82">深入了解Unity的Application类：一份详细的技术指南(二)</a></p><p><a href="https://cloud.tencent.com/developer/article/2380606">Unity 数据读取|（四）Json文件解析（Newtonsoft.Json ，Litjson，JsonUtility，SimpleJSON）</a></p><p><a href="https://yufulao.cn/posts/f1209f90/index.html">Luban数据配表方案</a></p><p><a href="https://blog.csdn.net/P_newbie/article/details/132261025">强力配置工具Luban使用教程</a></p><p><a href="https://blog.csdn.net/m0_63024355/article/details/132653036">Unity——LitJSON的安装</a></p>]]></content>
      
      
      <categories>
          
          <category> Unity技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> Luban </tag>
            
            <tag> LitJson </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github搭建个人博客</title>
      <link href="/2025/05/26/CoddingStore/Hexo+Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2025/05/26/CoddingStore/Hexo+Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="建立博客"><a href="#建立博客" class="headerlink" title="建立博客"></a>建立博客</h2><p><a href="https://blog.csdn.net/2303_76953932/article/details/145233223">https://blog.csdn.net/2303_76953932&#x2F;article&#x2F;details&#x2F;145233223</a></p><p>‍</p><h2 id="Hexo发布文章："><a href="#Hexo发布文章：" class="headerlink" title="Hexo发布文章："></a>Hexo发布文章：</h2><ol><li>将写好的markdown文章放在 <strong>​<code>source/_posts</code>​</strong>​ 文件夹下，将引用的资源放在<strong>​<code>source/assets</code>​</strong>​ 文件夹下。</li><li>依次输入执行下面的命令：</li></ol><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">hexo clean<span class="comment">//清除旧的数据，如非更换主题，则可以尽量不使用。一般发布文章使用下面几个命令就够了</span></span><br><span class="line">hexo g<span class="comment">//这个命令会将source文件夹下所有的md文件进行渲染，生成HTML页面，存放在public文件夹下</span></span><br><span class="line">hexo s<span class="comment">//重新生成页面后，我们可以在本地开启服务器，预览一下文章是否满意</span></span><br><span class="line">hexo d<span class="comment">//将网站部署到服务器上，也就是 Github.io 上</span></span><br></pre></td></tr></table></figure><p>（注：新生成的hexo项目source文件夹下没有assets文件夹，自己手动创建一个就行）</p><p><strong>参考文章：</strong></p><p><a href="https://fuguigui.github.io/hexo2/">一次完整的Hexo写作流程</a></p><h2 id="修改hexo主题"><a href="#修改hexo主题" class="headerlink" title="修改hexo主题"></a>修改hexo主题</h2><p><a href="https://zhuanlan.zhihu.com/p/385525053">https://zhuanlan.zhihu.com/p/385525053</a>     – 修改主题教程</p><p><a href="https://hexo.io/themes/">https://hexo.io/themes/</a>– 各种hexo主题</p><p>主题：</p><p><a href="https://github.com/volantis-x/hexo-theme-volantis/#5.8.0">https://github.com/volantis-x/hexo-theme-volantis/#5.8.0</a>– volantis主题</p><h3 id="Butterfly主题配置"><a href="#Butterfly主题配置" class="headerlink" title="Butterfly主题配置"></a>Butterfly主题配置</h3><p>‍</p><p><a href="https://butterfly.js.org/">Butterfly官方文档</a></p><p><a href="https://www.cnblogs.com/MoYu-zc/p/14395965.html">Butterfly美化</a></p><p><a href="https://blog.csdn.net/JesseXW/article/details/135649752">Butterfly自定义主页方法</a></p><p><a href="https://blog.captainz.cc/posts/hexo_butterfly_top_img.html">Hexo+Butterfly 主题一图流背景与顶部图修改</a></p><p><a href="https://www.cnblogs.com/an-shiguang/p/18269048#_label3_0_2_1">Butterfly主题美化配置</a></p><p><a href="https://blog.mitsumune.top/2023/02/13/hexo_butterfly%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E5%AF%B9%E9%9A%8F%E6%9C%BA%E5%9B%BE%E7%89%87api%E7%9A%84%E6%94%AF%E6%8C%81/">hexo butterfly主题添加对随机图片api的支持</a></p><h4 id="Page-Front-matter和Post-Front-matter"><a href="#Page-Front-matter和Post-Front-matter" class="headerlink" title="Page Front-matter和Post Front-matter"></a>Page Front-matter和Post Front-matter</h4><p><a href="https://blog.csdn.net/qq_43444349/article/details/105282118">front-matter参数的解释与设置</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Page Front-matter</span><br><span class="line">---</span><br><span class="line">title:【必需】頁面標題</span><br><span class="line">date:【必需】頁面創建日期</span><br><span class="line">updated:【可選】頁面更新日期</span><br><span class="line">type:【必需】標籤、分類和友情鏈接三個頁面需要配置</span><br><span class="line">comments:【可選】顯示頁面評論模塊 (默認 true)</span><br><span class="line">description:【可選】頁面描述</span><br><span class="line">keywords:【可選】頁面關鍵字</span><br><span class="line">top_img:【可選】頁面頂部圖片</span><br><span class="line">mathjax:【可選】顯示 mathjax (當設置 mathjax 的 per_page: false 時，才需要配置，默認 false)</span><br><span class="line">katex:【可選】顯示 katex (當設置 katex 的 per_page: false 時，才需要配置，默認 false)</span><br><span class="line">aside:【可選】顯示側邊欄 (默認 true)</span><br><span class="line">aplayer:【可選】在需要的頁面加載 aplayer 的 js 和 css,請參考文章下面的音樂 配置</span><br><span class="line">highlight_shrink:【可選】配置代碼框是否展開 (true/false) (默認為設置中 highlight_shrink 的配置)</span><br><span class="line">random:【可選】配置友情鏈接是否隨機排序（默認為 false）</span><br><span class="line">limit:【可選】配置説説顯示數量</span><br><span class="line">  type:【可選】配置説説顯示數量的類型 （date 或者 num）</span><br><span class="line">  value:【可選】配置説説顯示數量的值</span><br><span class="line">---</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Post Front-matter</span><br><span class="line">---</span><br><span class="line">title:【必需】文章標題</span><br><span class="line">date:【必需】文章創建日期</span><br><span class="line">updated:【可選】文章更新日期</span><br><span class="line">tags:【可選】文章標籤</span><br><span class="line">categories:【可選】文章分類</span><br><span class="line">keywords:【可選】文章關鍵字</span><br><span class="line">description:【可選】文章描述</span><br><span class="line">top_img:【可選】文章頂部圖片</span><br><span class="line">comments:【可選】顯示文章評論模塊(默認 true)</span><br><span class="line">cover:【可選】文章縮略圖(如果沒有設置 top_img,文章頁頂部將顯示縮略圖，可設為 false/圖片地址/留空)</span><br><span class="line">toc:【可選】顯示文章 TOC(默認為設置中 toc 的 enable 配置)</span><br><span class="line">toc_number:【可選】顯示 toc_number(默認為設置中 toc 的 number 配置)</span><br><span class="line">toc_style_simple:【可選】顯示 toc 簡潔模式</span><br><span class="line">copyright:【可選】顯示文章版權模塊(默認為設置中 post_copyright 的 enable 配置)</span><br><span class="line">copyright_author:【可選】文章版權模塊的文章作者</span><br><span class="line">copyright_author_href:【可選】文章版權模塊的文章作者鏈接</span><br><span class="line">copyright_url:【可選】文章版權模塊的文章連結鏈接</span><br><span class="line">copyright_info:【可選】文章版權模塊的版權聲明文字</span><br><span class="line">mathjax:【可選】顯示 mathjax(當設置 mathjax 的 per_page: false 時，才需要配置，默認 false )</span><br><span class="line">katex:【可選】顯示 katex (當設置 katex 的 per_page: false 時，才需要配置，默認 false )</span><br><span class="line">aplayer:【可選】在需要的頁面加載 aplayer 的 js 和 css,請參考文章下面的音樂 配置</span><br><span class="line">highlight_shrink:【可選】配置代碼框是否展開(true/false)(默認為設置中 highlight_shrink 的配置)</span><br><span class="line">aside:【可選】顯示側邊欄 (默認 true)</span><br><span class="line">abcjs:【可選】加載 abcjs (當設置 abcjs 的 per_page: false 時，才需要配置，默認 false )</span><br><span class="line">noticeOutdate:【可選】文章過期提醒 (默認為設置中 noticeOutdate 的 enable 配置)</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="Hexo-Butterfly-algolia-配置搜索"><a href="#Hexo-Butterfly-algolia-配置搜索" class="headerlink" title="Hexo+Butterfly+algolia 配置搜索"></a>Hexo+Butterfly+algolia 配置搜索</h4><p><a href="https://www.wuxx.top/2024/05/27/algolia-use/index.html">https://www.wuxx.top/2024/05/27/algolia-use/index.html</a></p><p>（注意点：如果你是windows用户，在 <code>此电脑-&gt;右键属性-&gt;高级系统设置-&gt;环境变量-&gt;</code>​ 里的用户变量或系统变量里注册。）</p><h4 id="【Vercel】Twikoo-为你的HEXO加入评论系统"><a href="#【Vercel】Twikoo-为你的HEXO加入评论系统" class="headerlink" title="【Vercel】Twikoo | 为你的HEXO加入评论系统"></a>【Vercel】Twikoo | 为你的HEXO加入评论系统</h4><p><a href="https://tech.yemengstar.com/hexo-tutorial-theme-butterfly-comments/">https://tech.yemengstar.com/hexo-tutorial-theme-butterfly-comments/</a></p><p>（注：域名就是你的博客网站的域名）</p><h4 id="hexo-Butterfly添加音乐播放器"><a href="#hexo-Butterfly添加音乐播放器" class="headerlink" title="hexo+Butterfly添加音乐播放器"></a>hexo+Butterfly添加音乐播放器</h4><p><a href="https://blog.csdn.net/qq_41467882/article/details/124734598">Hexo-Butterfly音乐播放器的添加</a></p><p>‍</p><p>注：关闭底部吸附歌词的方法：设置属性：<code>data-lrc-type=&quot;0&quot;</code>​</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="comment"># - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt;</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/modify.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># 吸附底部的音乐播放器</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;div</span> <span class="string">class=&quot;aplayer</span> <span class="literal">no</span><span class="string">-destroy&quot;</span> <span class="string">data-id=&quot;13519966293&quot;</span> <span class="string">data-server=&quot;netease&quot;</span> <span class="string">data-type=&quot;playlist&quot;</span>   <span class="string">data-order=&quot;list&quot;</span> <span class="string">data-fixed=&quot;true&quot;</span> <span class="string">data-preload=&quot;auto&quot;</span> <span class="string">data-autoplay=&quot;false&quot;</span> <span class="string">data-mutex=&quot;true&quot;</span> <span class="string">data-lrc-type=&quot;0&quot;</span> <span class="string">&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><h4 id="在Hexo博客上添加Live2D角色"><a href="#在Hexo博客上添加Live2D角色" class="headerlink" title="在Hexo博客上添加Live2D角色"></a>在Hexo博客上添加Live2D角色</h4><p><a href="https://zahi0.github.io/2022/01/21/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%8A%E6%B7%BB%E5%8A%A0Live2d%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/">https://zahi0.github.io/2022/01/21/%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%8A%E6%B7%BB%E5%8A%A0Live2d%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/</a></p><p><a href="https://zhuanlan.zhihu.com/p/593536116">https://zhuanlan.zhihu.com/p/593536116</a></p><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 创建个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏美术风格设计底层逻辑</title>
      <link href="/2025/05/25/3D_Art/%E6%B8%B8%E6%88%8F%E7%BE%8E%E6%9C%AF%E9%A3%8E%E6%A0%BC%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/"/>
      <url>/2025/05/25/3D_Art/%E6%B8%B8%E6%88%8F%E7%BE%8E%E6%9C%AF%E9%A3%8E%E6%A0%BC%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/</url>
      
        <content type="html"><![CDATA[<p><strong>参考视频：</strong></p><p><a href="https://www.bilibili.com/video/BV1984y1X7ch/?spm_id_from=333.337.search-card.all.click">原创风格公式。正确认识游戏美术风格</a></p><h1 id="游戏美术设计，三个底层逻辑："><a href="#游戏美术设计，三个底层逻辑：" class="headerlink" title="游戏美术设计，三个底层逻辑："></a>游戏美术设计，三个底层逻辑：</h1><p><img src="/../../assets/network-asset-1699862560615-aa839dbd-8de2-4f6d-ad30-42b8e177235e-20250525203434-vmmq059.png" alt="image.png"><br><img src="/../../assets/network-asset-1699862581488-15ac243c-3fdc-4f13-ad31-99a073b37adc-20250525203434-cev94ta.png" alt="image.png"></p><h1 id="第一条：正确认识风格"><a href="#第一条：正确认识风格" class="headerlink" title="第一条：正确认识风格"></a>第一条：正确认识风格</h1><h2 id="风格分析方法论"><a href="#风格分析方法论" class="headerlink" title="风格分析方法论"></a>风格分析方法论</h2><p>如何正确认识风格？<strong>风格&#x3D;题材元素+感受调性+技法风格（表现技法）</strong><br>我们可以依靠这种<strong>方法论</strong>来拆解一个项目的风格。<br><strong>题材元素：是什么内容（画面具体呈现了什么东西，区别于世界观题材）</strong><br><strong>感受调性：带给人的感受、情绪是什么？（比如压抑、搞笑、怀旧、热烈、阴冷）</strong><br><strong>技法风格：用了什么技术手段、怎么表达的（绘画技法、引擎的渲染方式（shader）、PBR、NPR、3D、2D、手绘等等）</strong></p><h2 id="举例1："><a href="#举例1：" class="headerlink" title="举例1："></a>举例1：</h2><p><img src="/../../assets/network-asset-1699863865992-fd5b00c1-feff-4575-8a2c-f8b82fba0408-20250525203434-5bfpaa6.png" alt="image.png"><br><strong>从题材上看：</strong><br>我们从画面的内容上看到旗子上的蜀、汉、诸葛，内容还有攻城车、城墙、士兵等可以知道这是一个三国题材，更进一步可以知道这是个战争题材（这是一种画面的表现内容，还可以是儿女情长，兄弟情义等）。<br><strong>从表现技法上看：</strong><br>从画面可以看出这是一个偏写实技法，有绘画质感，画面笔触较粗犷，不是超写实风格。<br><strong>从感受调性上看：</strong><br>黑云压城、炮火连天，可以感受到是非常压抑残酷，对抗激烈的情绪。</p><h2 id="分析练习："><a href="#分析练习：" class="headerlink" title="分析练习："></a>分析练习：</h2><p><img src="/../../assets/network-asset-1699864362683-2ad04af2-b731-43b5-9c12-3dc5237b81f5-20250525203434-umpkesu.png" alt="image.png"><br><strong>题材</strong>：（从CG图来看，这里不讨论这个游戏的玩法）古风题材，更细的来说是古风恋爱题材<br><strong>表现技法</strong>：偏写实，但是不是超写实，是有美型角色的那种风格，背景类似油画笔触。<br><strong>感受调性</strong>：儿女情长，男女之爱，卿卿我我，温婉细腻的情绪感受。<br><img src="/../../assets/network-asset-1699864505732-78042b37-d770-4994-b91b-dd3792d74773-20250525203435-4speagl.png" alt="image.png"><br><strong>题材</strong>：古风、战争的题材。<br><strong>表现技法</strong>：水墨笔触风格。大量的留白，画面只出现军旗未见兵。<br><strong>感受调性</strong>：决意、舍身赴死、孤独洒脱的情绪。</p><h2 id="风格的深入思考"><a href="#风格的深入思考" class="headerlink" title="风格的深入思考"></a>风格的深入思考</h2><p>思考：风格是一个很泛化的东西，上面只是一个通用的简单的思考方法论。而实际上风格多种多样，<strong>任何你可以看出差异的东西都可以称之为风格</strong>，比如头身的比例，人体结构的简化和复杂，以及与其他物体的结合（方块人、火柴人、福瑞、猫娘、舰娘、机甲等）。风格的差异，其实就是创新和多元化的产物。总之，在不同的事物领域（美术画面、听觉、文字等等）上，风格总是指那些独特、能够总结出一些特征的元素。归根结底，风格就是一个东西和另一个东西的差异（区别）点。</p><h1 id="第二条：三层设计思维"><a href="#第二条：三层设计思维" class="headerlink" title="第二条：三层设计思维"></a>第二条：三层设计思维</h1><h2 id="什么是底层逻辑，什么是顶层思维？"><a href="#什么是底层逻辑，什么是顶层思维？" class="headerlink" title="什么是底层逻辑，什么是顶层思维？"></a>什么是底层逻辑，什么是顶层思维？</h2><p>参考文章:<br><a href="https://www.zhihu.com/question/380838585">什么是底层逻辑？什么是顶层思维？</a></p><h2 id="游戏美术设计和世界观的关系"><a href="#游戏美术设计和世界观的关系" class="headerlink" title="游戏美术设计和世界观的关系"></a>游戏美术设计和世界观的关系</h2><p><img src="/../../assets/network-asset-1699873532337-4fc1fd28-86b5-40b2-ab82-98643469aa66-20250525203435-70r28ce.png" alt="image.png"><br>    什么是顶层设计逻辑和底层设计逻辑？有人说世界观是顶层思维逻辑，有人说世界观是底层思维逻辑，其实都不尽然正确。<br>我们进行美术设计的时候，一般考虑出发点：世界观、风格（题材元素、可爱的角色、战争、姿态、情绪）等等。而不是绝对的先有世界观，再设计其他元素。</p><p><strong>游戏美术设计的出发点</strong>是什么？可能我们是先有的<strong>世界观</strong>，然后根据世界观去进行<strong>美术设计</strong>；也有可能是先有<strong>一个想要创作的情绪</strong>，比如我想表达一个悲伤的情绪，然后再一步步去设计构建其他诸如世界观、题材元素等等。或者我单纯想要制作一个可爱的角色，我们想根表达角色的可爱，再以此为出发点去设计其他构成元素。所以世界观和美术设计、情绪这些并没有其中一个是<strong>绝对的底层逻辑</strong>。</p><p>而真正<strong>游戏设计的前后（上下游）<strong>​****大概是这样的，游戏制作中大概是先考虑完成世界观的构建，再根据世界观去进行美术设计。游戏研发上世界观和美术设计是上游和下游的关系。但是实际抛开游戏开发不谈，我们单纯进行美术设计的时候，世界观和美术设计并不是有一个绝对的底层逻辑。</strong></strong></p><p><strong><strong>对设计师来说：我们先来讲一讲</strong></strong>​<strong>方法论</strong>，我们一般设计东西会<strong>强调方法论，总结理论技巧方法，用来复制产出一些效果。<strong>​<strong><strong>说白了就是</strong></strong>​</strong>技法</strong>。姑且称它为<strong>中层设计</strong>，<strong>底层设计</strong>则是我们的一些想法，思考点，或者说我们的创作动机，我们想要创作一个可爱的角色、或者是表达一个情绪、展现一个世纪观之类的。基于这种<strong>底层设计</strong>，我们会思考我们要添加什么元素到我们的画面上，使用什么方法（技法）来实现我们的创作动机。这利用到了中层设计。</p><p>而<strong>顶层设计</strong>，则是指导我们设计的一种框架，设计原则，比如我们做一个项目，我们会考虑我们项目的用户（受众）是什么类型的人？（美术风格、游戏玩法、剧情体验、受众年龄、受众性别等等），基于用户类型，来指导我们进行游戏的整体框架的设计，是一种统筹谋划的思维。一般来说，你是管理层，或者独立游戏开发者，会比较注重顶层思维，这会关系到你的项目的成功与否。当然如果你是单纯的美术设计师的话，了解一下顶层思维，分析清楚你的受众，然后去进行设计，可以也会使你的作品被喜欢的概率更高，总之，了解一下顶层设计，是不会有坏处的。</p><p>网络上做自媒体有一种说法叫做<strong>基本盘</strong>，即你的作品的受众<strong>大多</strong>是什么类型的？那么这个类型就是你当自媒体的<strong>基本盘，</strong> 只要你稳固自己的基本盘，运营和维持你的基本盘，那么你基本就不会翻车。这和顶层设计的思维有一些异曲同工之妙。<br>在工作中，游戏美术设计这块上，是顶层指导中层，中层指导底层的，也可以理解为上级做框架，规定美术效果用什么技法实现，这些技法来指导我们制作我们的美术设计。</p><p>‍</p><p><img src="/../../assets/network-asset-1699874015166-0c869d2d-2c4e-489d-a899-25d165aa2609-20250525203435-yrd40lt.png" alt="image.png"></p><h1 id="第三条：抛球理论"><a href="#第三条：抛球理论" class="headerlink" title="第三条：抛球理论"></a>第三条：抛球理论</h1><p><img src="/../../assets/network-asset-1699877150636-579c84b5-4dfa-45e5-8eee-f6b48c007ff9-20250525203435-2f421r0.png" alt="image.png"><br>    抛弃理论很简单，我们游戏项目制作时，我们要同时注重游戏的美感表现、世界观背景（背景、剧情、人物的文字刻画等等）和功能体验（游戏玩法）。当然我们在这几个注重的点里要有一个更为侧重的点，当然所有的点都照顾到很好，但是大多不会面面俱全。所以我们会有一个更为侧重的点。</p><h1 id="风格分类图表："><a href="#风格分类图表：" class="headerlink" title="风格分类图表："></a>风格分类图表：</h1><p><img src="/../../assets/network-asset-1699865352885-e3ccf1df-6c04-4afd-ac0a-a191dcb44e4c-20250525203435-jkflhsa.png" alt="image.png"><br>我们可以善用表格来去对比交叉的内容<br><img src="/../../assets/network-asset-1699865452705-9daa7716-8314-4570-a4da-0c115b080586-20250525203435-euvy819.png" alt="image.png"></p><h1 id="进阶：美的塑造是哪几方面的"><a href="#进阶：美的塑造是哪几方面的" class="headerlink" title="进阶：美的塑造是哪几方面的"></a>进阶：美的塑造是哪几方面的</h1><p><img src="/../../assets/network-asset-1699863777432-d7efb5d2-d794-41f1-bd4a-5d42e3039856-20250525203435-fq71p6j.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 美术学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 审美 </tag>
            
            <tag> 游戏美术设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blender基础操作与常见问题</title>
      <link href="/2025/05/25/Blender/Blender%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2025/05/25/Blender/Blender%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Blender基础操作"><a href="#Blender基础操作" class="headerlink" title="Blender基础操作"></a>Blender基础操作</h1><h2 id="通用操-作命令："><a href="#通用操-作命令：" class="headerlink" title="通用操 作命令："></a>通用操 作命令：</h2><p><strong>TAB：</strong> ​切换为编辑模式​ 、</p><p><strong>Ctrl+TAB：</strong> 切换多种模式</p><p><strong>AlT+Shift+S</strong>：拉为球形</p><p><strong>L：</strong> 循环选择相似面</p><p><strong>ctrl键选择点、线或面：拾取最短路径：</strong> 鼠标点选点线或面，选中另一个点线或面，即可拾取最</p><p>短路径</p><p><strong>Shift+h：</strong> 只显示选中的面</p><p><strong>G:移动、R：旋转、S：放缩、A:</strong> 全选物体</p><p><strong>B:</strong> 框选物体、<strong>Ctrl+i：</strong> 反选物体、<strong>I：</strong> 内插面</p><p>（选中物体按下G、R、S进行编辑时，再按x、y、z会将物体吸附在所选轴上进行编辑，按C清除吸附）</p><p>X：<strong>删除</strong>、E：<strong>挤出</strong>、Z：**着色方式、</p><p><strong>Ctrl+鼠标右键：</strong> 添加所选物体或线或点</p><p><strong>ALT+S：</strong> 沿法向缩放</p><p>H：<strong>隐藏所选</strong>、Alt+H：取消所有隐藏</p><p><strong>W：</strong> 改变选择物体的方式</p><p><strong>K：</strong> 切割（回车键确定）</p><p><strong>M:</strong> 合并点线面</p><p><strong>Ctrl+R：</strong> 环切（鼠标滑轮改变数量）</p><p><strong>Shift+鼠标左键：</strong> 多选物体</p><p><strong>Shift+鼠标右键：</strong> 将游标点移动到鼠标所在位置</p><p><strong>Shift+A：</strong> 添加物体</p><p><strong>Shift+D:</strong> 复制物体</p><p><strong>Alt+D：</strong> 关联复制</p><p><strong>Ctrl+J：</strong> 合并选中的多个物体</p><p><strong>Ctrl+E：</strong> 细分边</p><p><strong>Ctrl+B：</strong> 边线倒角</p><p><strong>Ctrl+Shift+B：</strong> 顶点倒角</p><p><strong>Ctrl+X：</strong> 融并选区</p><p><strong>Shift+TAB：</strong> 打开吸附</p><p><strong>Shift+N：</strong> 重新计算法向</p><p><strong>F12:</strong> 渲染预览</p><p><strong>在编辑模式下按Z进入线框模式，选中物体按P键：</strong> 分离所选物体，接着将鼠标右键设置原点到几何中心</p><p><strong>在编辑模式下：1：点选择、2：便选择、3：面选择</strong></p><p><strong>Shift+S：</strong> 吸附键，游标变换操作</p><p><strong>大键盘 . ：轴心点操作</strong></p><h2 id="视图命令："><a href="#视图命令：" class="headerlink" title="视图命令："></a>视图命令：</h2><p>‍</p><p><strong>Shift+鼠标中键：</strong> 移动视图​、</p><p><strong>鼠标中键：</strong> 旋转视图</p><p><strong>鼠标滑轮：</strong> 缩放视图(颗粒)</p><p><strong>Ctrl+鼠标中键：</strong> 缩放视图(丝滑)</p><p><strong>Ctrl+空格：视图窗口最大化</strong></p><p> <strong>&#x2F;：</strong> 聚焦视口到所选物体并隐藏其他物体(再按一次取消)</p><p>‍</p><p><strong>小数字键盘：</strong></p><p><strong>2、8、4、6为以所选物体为中心上下左右旋转</strong></p><p><strong>5为切换正交、透视</strong></p><p><strong>1为前视图、Ctrl+1为后视图</strong></p><p><strong>3为右视图、Ctrl+3为左视图</strong></p><p><strong>7为顶视图、Ctrl+7为底视图</strong></p><p><strong>0为摄像机视图</strong></p><p> <strong>. 为聚焦视口到所选物体</strong></p><h2 id="创建多个视口："><a href="#创建多个视口：" class="headerlink" title="创建多个视口："></a>创建多个视口：</h2><p><img src="/../../assets/image1-20231204102551-16zk4ny.png"><img src="/../../assets/image3-20231204102551-cjmtvg8.png"></p><h2 id="创建及清除父子级"><a href="#创建及清除父子级" class="headerlink" title="创建及清除父子级"></a>创建及清除父子级</h2><p>选中多个物体，按Ctrl+P选择<strong>物体</strong>，最后一个选中的物体（黄色框框中的物体）为父级，剩下的为子集。对父级进行<strong>移动旋转</strong>时，子级跟着父级一起运动。对子级进行操作，父级不受影响。</p><p>断绝父子级则按Alt+P选择清空父级</p><h2 id="轴心点操作"><a href="#轴心点操作" class="headerlink" title="轴心点操作"></a>轴心点操作</h2><p>在不建立关联和父子级的情况下，选中多个物体进行操作时，我们需要注意操作作用的位置。按<code>键盘 &gt; 键</code>​可对轴心点（操作发挥作用的点）进行操作。</p><p>质心点：物体重心的平衡点</p><p>活动元素：及激活的物体（黄色框框中的物体）的中心点</p><p><strong>各自原点：每个物体自身的中心点，此方法比较常用，适合于对多个物体或线面进行相同操作。</strong></p><h2 id="激活元素（活动元素）注意"><a href="#激活元素（活动元素）注意" class="headerlink" title="激活元素（活动元素）注意"></a>激活元素（活动元素）注意</h2><p>在物体模式下显示活动元素，其中活动元素是黄色显示。</p><p>在编辑模式中的顶点、边和面的活动元素以白色显示。</p><h2 id="环形选择（Alt-鼠标左键点选）"><a href="#环形选择（Alt-鼠标左键点选）" class="headerlink" title="环形选择（Alt+鼠标左键点选）"></a>环形选择（Alt+鼠标左键点选）</h2><p>在编辑模式下，在1点选择模式下，Alt点选可以点选选择环形，也可以点选两个点，选择两点连线的环形。</p><p>在编辑模式下，在2线选择模式下，Alt点选可选择线所在的环形。</p><p>在编辑模式下，在3面选择模式下，Alt面选可选择面环形</p><h2 id="吸附操作（Shift-TAB开启）"><a href="#吸附操作（Shift-TAB开启）" class="headerlink" title="吸附操作（Shift+TAB开启）"></a>吸附操作（Shift+TAB开启）</h2><p><img src="/../../assets/image5-20231204102551-oab17vc.png"><img src="/../../assets/image7-20231204102551-m29dxtw.png"></p><h2 id="衰减编辑模式"><a href="#衰减编辑模式" class="headerlink" title="衰减编辑模式"></a>衰减编辑模式</h2><p>按快捷键<strong>o</strong>或者在顶菜单栏上找到衰减编辑模式。进入衰减编辑模式后，选择点、线、或面，进行移动，则会拉动周围点一起变化，<strong>衰减范围</strong>用<strong>鼠标滑轮滑动进行调节</strong>。<img src="/../../assets/image9-20231204102551-2sce51t.png"></p><p><img src="/../../assets/image10-20231204102551-91lxeh8.png" alt="电脑萤幕画面 描述已自动生成"></p><h1 id="常见问题与一些小技巧"><a href="#常见问题与一些小技巧" class="headerlink" title="常见问题与一些小技巧"></a>常见问题与一些小技巧</h1><h2 id="挤出小技巧（E-Alt-E）"><a href="#挤出小技巧（E-Alt-E）" class="headerlink" title="挤出小技巧（E &#x2F; Alt+E）"></a>挤出小技巧（E &#x2F; Alt+E）</h2><p>1.多选面合并挤出</p><p><img src="/../../assets/image11-20231204102551-a5nkhq9.png" alt="电脑萤幕画面 描述已自动生成"></p><p>2.分开挤出（Alt+E选择挤出各个面）</p><p><img src="/../../assets/image12-20231204102551-yol9fhs.png" alt="电脑萤幕画面 描述已自动生成"> <img src="/../../assets/image13-20231204102551-aet5lb4.png" alt="电脑游戏的屏幕 描述已自动生成"></p><h2 id="移动点线面小技巧"><a href="#移动点线面小技巧" class="headerlink" title="移动点线面小技巧"></a>移动点线面小技巧</h2><p>按一次G进行移动，再按一次G将点、线或面固定再物体表面上移动。</p><h2 id="创建点、线、面的方法"><a href="#创建点、线、面的方法" class="headerlink" title="创建点、线、面的方法"></a>创建点、线、面的方法</h2><p><strong>生成点：</strong></p><ol><li>Shift+A创建一个立方体或其他物体</li><li>选中物体按M合并生成点</li></ol><p>或者</p><ol><li>Shift+D复制物体的一个顶点</li><li>按E挤出</li></ol><p>或者</p><ol><li>Shift+D复制物体一个顶点</li><li>按Ctrl+鼠标右键</li></ol><p><strong>生成边的中点并生成多个点：</strong></p><ol><li>选择一条边</li><li>Ctrl+E或者鼠标右键细分</li><li>Ctrl+Shift+B顶点倒角</li></ol><p><strong>生成线：</strong></p><ol><li>Shift+D复制一个点</li><li>框选两个点按F生成线</li></ol><p>或者</p><p>1.按E挤出</p><p><strong>生成面：</strong></p><p>1. Shift+A创建立方体</p><p>2. 选择立方体按M合并为一个点</p><p>3. 按E进行挤出点形成线</p><p>4. 选中所有点，按F生成面</p><p><strong>平分一条线：</strong></p><ol><li>选择一条边</li><li>Ctrl+E细分生成中点</li><li>选择新生成的两条边</li><li>按“ . ”键选择按各自原点</li><li>Ctrl+E细分生成两条边各自的中点，得到均分的四条边</li></ol><p><strong>连接两点的方法：</strong></p><ol><li>选择两点</li><li>按F连接两点或者按J连接两点</li><li>F与J的区别——F为只连接所选点，不生成与别的线交叉的点，而J则生成与其他线有交叉的点。</li></ol><h2 id="修改器的应用"><a href="#修改器的应用" class="headerlink" title="修改器的应用"></a>修改器的应用</h2><p>在使用修改器时，常常会出现修改器没有作用到物体上的效果，那是因为我们没有应用修改器的原因。但是当我们想要应用修改器时也会遇到应用选项是灰色的。这是为什么呢？这是因为我们处于编辑模式， 所以不能进行此操作，此时我们需要按TAB键返回物体模式，这时我们就可以应用修改器了！（Ctrl+A）注意，应用编辑器后就不能回到原来的状态了，只能撤回（Ctrl+Z）</p><p><img src="/../../assets/image14-20231204102551-f83ynjt.png"><img src="/../../assets/image16-20231204102551-0szp7z3.png"></p><h2 id="切割和切分之方向的控制小技巧"><a href="#切割和切分之方向的控制小技巧" class="headerlink" title="切割和切分之方向的控制小技巧"></a>切割和切分之方向的控制小技巧</h2><p><strong>按K键打开切割模式，按C开启方向控制。Shift开启中点吸附，S开启角度距离数据。</strong></p><p><strong>适用于硬表面的建模，及精细化的工业建模，制造精密的零件模型等。如机械零件。</strong></p><p><strong>切分：在T面板里有切分选项，选择面，选择切分，按Ctrl可以控制水平或垂直</strong></p><h2 id="断离顶点或面"><a href="#断离顶点或面" class="headerlink" title="断离顶点或面"></a>断离顶点或面</h2><p>选中顶点按v断离，向想要断离的方向移动。</p><h2 id="细分出现锐角或折边解决"><a href="#细分出现锐角或折边解决" class="headerlink" title="细分出现锐角或折边解决"></a>细分出现锐角或折边解决</h2><p>方法</p><p><img src="/../../assets/image135-20231204102552-ygn8sg2.jpeg" alt="图片包含 图表 描述已自动生成"></p><p>1.一个是出现了重叠顶点，按M合并顶点</p><p>2.一个是法线方向反了的问题，按A全选后按shift+N重新计算法线方向</p><p>3.出现了内部的连线问题（多连或错连），打开线框模式检查线的连接是否正确</p><h2 id="移除重合顶点"><a href="#移除重合顶点" class="headerlink" title="移除重合顶点"></a>移除重合顶点</h2><p>选中物体，或者A全选物体，按M合并顶点，按距离。</p><h2 id="拓扑面时减少顶点的方法"><a href="#拓扑面时减少顶点的方法" class="headerlink" title="拓扑面时减少顶点的方法"></a>拓扑面时减少顶点的方法</h2><p><img src="/../../assets/image136-20231204102552-8wlmyei.png" alt="图片包含 图表 描述已自动生成"></p><p>此时有七个顶点，我想要减少成三个顶点，可以这么做，选中四个顶点按G和Z向上移动，再填充面，这样就减少了四个顶点</p><p><img src="/../../assets/image137-20231204102552-pq2ekpd.png" alt="图示 描述已自动生成"><img src="/../../assets/image138-20231204102552-ynjmzit.png" alt="图片包含 室内, 小, 橙子, 空 描述已自动生成"></p><p>方法还有很多，多多摸索。</p>]]></content>
      
      
      <categories>
          
          <category> Blender </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blender </tag>
            
            <tag> 备忘 </tag>
            
            <tag> 3DCG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(一)日语发声那些事儿</title>
      <link href="/2025/05/25/Japanese/%E6%97%A5%E8%AF%AD%E5%8F%91%E9%9F%B3%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2025/05/25/Japanese/%E6%97%A5%E8%AF%AD%E5%8F%91%E9%9F%B3%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="发音类型"><a href="#发音类型" class="headerlink" title="发音类型"></a>发音类型</h2><p><strong>日语的发音类型有：元音、清音、浊音、半浊音、拗音、长音、促音、拨音。最重要的是促音、长音、拔音和拗音，其他的只做了解即可。发音方法请自行上网学习。</strong></p><h3 id="元音"><a href="#元音" class="headerlink" title="元音"></a><strong>元音</strong></h3><p>只有：a（あ）、i（い）、u（う）、e（え）、o（お）。</p><h3 id="清音："><a href="#清音：" class="headerlink" title="清音："></a><strong>清音：</strong></h3><p>ｋ（か行）、ｓ（さ行）、ｔ（た行）、ｎ（な行）、ｈ（は行）</p><p>ｍ（ま行）、ｙ（や行）、ｒ（ら行）、ｗ（わ行）、ｐ（ぱ行）</p><h3 id="浊音："><a href="#浊音：" class="headerlink" title="浊音："></a><strong>浊音：</strong></h3><p>g（が行）、ｚ（ざ行）、ｄ（だ行）、ｂ（ば行）</p><p><strong>が 行</strong></p><p>平假名 　　が 　　ぎ 　　ぐ 　　げ 　　ご<br>片假名 　　ガ 　　ギ 　　グ 　　ゲ 　　ゴ<br>罗马字 　　ga gi gu ge go<br>    が行假名位于词中或词尾时有鼻浊音现象，这时发音由[η]加元音拼合而成。</p><p><strong>ざ 行</strong></p><p>平假名 　　ざ 　　じ 　　ず 　　ぜ 　　ぞ<br>片假名 　　ザ 　　ジ 　　ズ 　　ゼ 　　ゾ<br>罗马字 　　za zi zu ze zo<br>    其中「じ」发音成[ji]，「ず」发音成[zi]。</p><p><strong>だ 行</strong></p><p>平假名 　　だ 　　ぢ 　　づ 　　で 　　ど<br>片假名 　　ダ 　　ヂ 　　ヅ 　　デ 　　ド<br>罗马字 da di du de do<br>    注：だ行的假名「ぢ」、「づ」与ざ行的假名「じ」、「ず」的发音完全相同。现代日语中除了连浊现象及某些习惯用法外，一般都用「じ」和「ず」<br>    例：はなぢ（鼻血）中的「ぢ」属于<strong>连浊现象</strong>。</p><p><strong>ば 行</strong></p><p>平假名 　　ば 　　び 　　ぶ 　　べ 　　ぼ<br>片假名 　　バ 　　ビ 　　ブ 　　ベ 　　ボ<br>罗马字 　　ba bi bu be bo</p><h3 id="半浊音（ぱ行）："><a href="#半浊音（ぱ行）：" class="headerlink" title="半浊音（ぱ行）："></a><strong>半浊音（ぱ行）：</strong></h3><p>日语的半浊音只有一行，共 5 个。其书写方法是在「は」行假名的右上角添加半浊音符号「ﾟ」即可。</p><p><strong>ぱ 行</strong></p><p>平假名 　　ぱ 　　ぴ 　　ぷ 　　ぺ 　　ぽ<br>片假名 　　パ 　　ピ 　　プ 　　ペ 　　ポ<br>罗马字 pa pi pu pe po</p><h3 id="长音规则（重要）："><a href="#长音规则（重要）：" class="headerlink" title="长音规则（重要）："></a><strong>长音规则（重要）：</strong></h3><p>一个假名就是一个音节，也就是一拍，称为短音。把假名的发音时间延长一拍就成了长音，其长度相当于两个音拍。片假名的长音用“ー”（键盘的-键）来表示，平假名的长音是有规律的，规则如下</p><p><strong>あ段 +「あ」</strong></p><p>例：おかあさん（妈妈）おばあさん（奶奶）</p><p><strong>い段 +「い」</strong></p><p>例：おにいさん（哥哥）おじいさん（爷爷）</p><p><strong>う段 +「う」</strong></p><p>例：つうやく（口语翻译）くうき （空气）</p><p><strong>え段 +「い」或「え」，不过常用「い」</strong></p><p>例：せんせい（老师） えいが（电影）おねえさん（用「え」）</p><p><strong>お段 +「う」或「お」，不过常用「う」</strong></p><p>例：おとうさん（爸爸）とうよう（东洋） おおきい （用「お」）</p><p><strong>片假名用「―」</strong></p><p>例：カード（卡片） センター （中心）</p><p><strong>注：一定要记住长音是拉长一拍，不要读后面所跟的假名，所以おかあさん只需拉长か再读さん即可。</strong></p><h3 id="促音「小写っ」"><a href="#促音「小写っ」" class="headerlink" title="促音「小写っ」"></a>促音「小写っ」</h3><p><strong>日语中促音是用小写「つ」来表示的，即「っ」。一般不发音，促音的要点就是为准备下一个音而等待一拍，所以促音虽然不发音却也占一拍。</strong></p><p>例：はっきり（清晰地，清楚地）中「っ」不发音，它只是为准备下一个[k]音而等待一拍。</p><p>注：促音虽然不发音，但是有无促音也会改变词义。</p><p>例：さっか是作家的意思，さか却是坡的意思。</p><h3 id="拨音「ん」"><a href="#拨音「ん」" class="headerlink" title="拨音「ん」"></a>拨音「ん」</h3><p>日语中的 <strong>「ん」</strong> 称为拨音，其平假名的书写是「ん」，片假名是「ン」，罗马字是[n]。它不能单独使用，只能附在其他假名后面。发音时，拨音占一拍。</p><h3 id="拗音"><a href="#拗音" class="headerlink" title="拗音"></a>拗音</h3><p>キャ　キュ　キョ　きゃ　きゅ　きょ</p><p>シャ　シュ　ショ　しゃ　しゅ　しょ</p><p>チャ　チュ　チョ　ちゃ　ちゅ　ちょ</p><p>ニャ　ニュ　ニョ　にゃ　にゅ　にょ</p><p>ヒャ　ヒュ　ヒョ　ひゃ　ひゅ　ひょ</p><p>ミャ　ミュ　ミョ　みゃ　みゅ　みょ</p><h3 id="外来词专用音节"><a href="#外来词专用音节" class="headerlink" title="外来词专用音节"></a>外来词专用音节</h3><p><strong>ファ（fa）、ツァ（tsa）</strong></p><p><strong>ウィ（wi）、ツィ（tsi）、ティ（ti）、フィ（fi）、ディ（di）</strong></p><p><strong>トゥ（tu）、ドゥ（du）、ヂュ（dyu）</strong></p><p><strong>ウェ（we）、シェ（she）</strong> 、<strong>チェ（che）、ツェ（tse）</strong> 、<strong>フェ（fe）、ジェ（je）</strong></p><p><strong>ウォ（wo）、ツォ（tso）、フォ（fo）</strong></p><p>等等</p><h2 id="声调"><a href="#声调" class="headerlink" title="声调"></a>声调</h2><p>日语的声调主要是指词语中各个音节之间存在的高低，只有<strong>高音和低音</strong>两种。它具有<strong>区别语言含义的作用</strong>，如果声调读错了，那么意思也就不一样了。比如橋（0 型）、箸（1 型）。</p><p>日语的发音一共两个特点：</p><ul><li><p>单词的第一个音节和第二个音节的音高一定不同。</p></li><li><p>一个单词的声调中，或没有下降，或只有一处下降</p><p>  如何理解这两个特点呢？前面说过，日语的声调主要是各个音节之间的高低关系，那么第一个特点就是第一个音节和第二个音节只会有两种情况，一种是低-高，一种是高-低。第二个特点就是，在一个单词里，要么音节的高低不会出现变化，要么只会有一个下降 ↘ 的地方。</p><p>  让我们看图更方便理解，如图，第一个音节和第二个音节一定会是 ↘ 或者 ↗；而且在一个单词中，要么没有 ↘，要么只会有一处地方有 ↘。</p></li></ul><p><img src="/../../assets/image-20240511120306-gckhs4v.png" alt="image">​</p><pre><code>明白了这两个特点，我们就可以开始发音了，在学习发音前，我们要了解**音拍**这个概念，一个音节代表一拍，而一个单词有几个音节，就有几拍。比如：学校（がっこう）这个单词，有四个音拍。了解了一个单词有几个音拍，我们还需要知道这个**单词的音调类型**，才能读出正确的单词发音。而音调类型大致分为：</code></pre><p>０ 型：表示只有第一拍低，其他各拍都高。</p><p>① 型：表示只有第一拍高，以下各拍都低。</p><p>② 型：表示只有第二拍高，第一拍和第三拍以下各拍都低。</p><p>③ 型：表示第二拍、第三拍高，第一拍和第四拍以下各拍都低。</p><p>④ 型：表示第二拍至第四拍高，第一拍和第五拍以下各拍都低。</p><p>⑤ 型：表示第二拍至第五拍高，第一拍和第六拍以下各拍都低。</p><p>⑥ 型：表示第二拍至第六拍高，第一拍和第七拍以下各拍都低。</p><p>⑦ 型以及以下各型的声调依次类推。</p><pre><code>学完上面的内容，我们就可以开始读单词了，比如说刚才的单词：学校（がっこう）是 0 型四拍单词，所以是低高高高。怎么样，你学会了吗。</code></pre><h2 id="音读和训读"><a href="#音读和训读" class="headerlink" title="音读和训读"></a>音读和训读</h2><p><strong>初探：</strong></p><p>在学习<strong>日语汉字</strong>的过程中，初学者往往绕不开「音読み」（おんよみ）】（音读）和「訓読み」（くんよみ）（训读）。那什么是音读，什么是训读？如何区分呢？今天就带大家一探究竟~</p><p>首先，我们来了解下日语文字的形成历史。简单的来说，日本的文字（平假名、片假名、汉字）是从中国借来的，平假名来源于汉字草书，片假名来源于楷书的偏旁部首。</p><p>所以日语词汇大致可分为三类：</p><ol><li>和语词汇：日语原有（训读为主）</li><li>汉语词汇：汉字组成（音读为主）</li><li>外来语：西洋等外来的音译词汇</li></ol><p><strong>什么是音读：</strong></p><p>因为日文中很多汉字都是由我国传过去的，因此<strong>很多日文汉字与古代中国汉字发音相似</strong>，并且一直保留到现在。<strong>这种仍然保留汉语读音的日文汉字发音，我们称为音读。</strong></p><p>例如，汉字“水”在中国发音为“shui”，在日语中读作“水（すい）”，它的意思是“水”，这种类似于这种中国语音的发音被称为“音读”（音読み）。</p><p>音读多是汉语词汇，例如水（すい），<strong>很少单独使用</strong>，一般是组成「水産」（すいさん）、「水分」（すいぶん）等汉字词汇。所以一般在接续（连接）其他词汇时，大多用的是音读。</p><p><strong>什么是训读</strong></p><p><strong>“训读”就是按照日文固有的发音来拼读汉字</strong>，与原本汉字的读音天差地别，<strong>只是借用了汉字的外形与意义</strong>，汉字只是一个表音的记号。比如还是水，在训读就是「みず」。</p><p><strong>总结一下：音读与训读的主要区别是：音读是与古汉字类似的发音，训读是日本自己原有的发音。</strong></p><p>以上，了解了什么是音读和训读后，我们就可以知道，一个单独的汉字，可分为音读和训读两种，例如：水的音读是（すい）、训读是（みず）。風的音读是（ふう）、训读是（かぜ）。等等……</p><p>那么，了解了这些后，我们如何辨别在语句中，这个词是用音读还是训读呢？日本的单词是音读还是训读没有绝对的规律可循，只能靠多积累，和语感。一个汉字甚至可能有几个音读和几个训读，例如：天：（音読み：てん）（訓読み：あま、あめ）。</p><p><strong>由于日语汉字有 2 种发音规律，当两个汉字组合时，就会出现 3 种组合方式：</strong></p><ol><li><p>音读加音读，如「地下（ちか)」</p></li><li><p>训读加训读，如「根元(ねもと)」</p></li><li><p>音读与训读的混合如「稲作(いなさく)」</p></li></ol><p><strong>一般，两个或以上的汉字组成的词汇、な形容词，多用音读。</strong> 如：成都（せいと）、冷蔵庫（れいぞうこ）、青春（せいしゅん）、有名（ゆうめい）、綺麗（きれい）、元気（げんき）、便利（べんり）。等等</p><p><strong>而且我们也可以用一个单词的读法去推断更多其他单词的读法</strong>，例如：東京（とうきょう）、東欧（とうおう）、東南（とうなん）、東方（とうほう）、東洋（とうよう）、東部（とうぶ）。等等</p><p><strong>一般，日语里面的动词和い形容词，只有一个字的汉字一般会用训读。</strong> 如：寝（ね）、水（みず）、風（かぜ）、道（みち）。</p><p><strong>一个词汇，可能有不同的读法，读法不同，意义也不同。</strong> 例如：風車，使用音读：（ふうしゃ）的意思是，由风驱动的大型器械，并且，使用音读多用于连用，例如：風車小屋（ふうしゃごや）。而風車的训读：（かざぐるま），指的是小孩子玩的风车玩具，并且是专用的词汇，并不会连用。</p><p>在这个例子中，可能有人会问：风车的训读不应该是（かぜくるま）吗？那么这里则涉及到了日语单词连用（复合词）中发生的<strong>变音（音便）</strong> 现象。</p><h2 id="日语中的音便规律"><a href="#日语中的音便规律" class="headerlink" title="日语中的音便规律"></a>日语中的音便规律</h2><p><a href="https://www.sigure.tw/learn-japanese/grammar/n5/21.php">https://www.sigure.tw/learn-japanese/grammar/n5/21.php</a></p><h4 id="何为音便？"><a href="#何为音便？" class="headerlink" title="何为音便？"></a>何为音便？</h4><p>當<strong>五段動詞第二變化（</strong> 动词连用形 <strong>）</strong> 接「て形」或「た形」時，為了發音方便會產生「音便」。</p><p> &lt;需具備以下所有條件：<br>必須為五span data-type&#x3D;”text” style&#x3D;”font-size: 19px;”&gt;音便的産生段動詞。<br>絕對是第二變化（連用形）。<br>接「て形」或「た形」。&lt;&#x2F;需具備以下所有條件：</p><p><strong>注：<strong>​</strong>只有五段動詞會音便！上下一段、サ變カ變都不會產生音便</strong></p><p><img src="/../../assets/image-20240523224751-8urf7sn.png" alt="image">​</p><h4 id="音便種類"><a href="#音便種類" class="headerlink" title="音便種類"></a>音便種類</h4><p>依照五段動詞語尾變化之「っ(促音)、ん(撥音)、い(イ音)」而有了以下分類：</p><p><img src="/../../assets/image-20240523224840-sbzgajz.png" alt="image">​</p><p>例外：</p><p><img src="/../../assets/image-20240523224855-ckygr9b.png" alt="image">​</p><h4 id="如何做音便？"><a href="#如何做音便？" class="headerlink" title="如何做音便？"></a>如何做音便？</h4><pre><code>這裡先簡單說明一下，由於音便來自**第二變化的「連用形」** ，因此許多教學會使用大家比較熟悉的「ます形（連用形的其中一種）」來做說明，而「ます形産生音便」的意思就是先把**動詞變為第二變化**再加上ます，接著再由ます形去做音便的變化。</code></pre><p><img src="/../../assets/image-20240523224946-gbpro0v.png" alt="image">​</p><pre><code>在看到**辭書形**的單字時（例如「聞く」）須先轉換為**第二變化的連用形**，例如ます形的「**聞き**ます」，再轉音便「聞いて」，有不少學習「ます形」的學習者會對此步驟感到麻煩，這裡提醒各位， **「ます形」只是連用形的其中一種**，事實上只要會音便，並且瞭解音便是由**第二變化連用形**而來的，那麼**不一定要做轉換「ます」這個動作**。</code></pre><p><img src="/../../assets/image-20240523225137-705j2h8.png" alt="image">​</p><p>學習者也可以直接轉換音便，但要清楚知道這個音便是由<strong>第二變化連用形</strong>而來的。以上已將音便的由來及ます形的教法交予各位，接下來為求靈活使用，本篇將使用「直接轉連用形」的方式，也就是「語尾法」來帶領各位快速掌握音便的用法。</p><p><strong>「促音便」</strong></p><p><strong>促音便</strong>又稱為ツ音便，即變化後有促音（っ），請注意促音為小寫的「っ」，並且不發音，用以頓促，因而稱為促音。當看到<strong>五段動詞原形的語尾為う、つ、る時，可直接轉連用形並改為促音。</strong></p><p><img src="/../../assets/image-20240523225329-hsrl772.png" alt="image">​</p><p> <strong>「拨音便」</strong></p><p><img src="/../../assets/image-20240523225503-x9uzqrz.png" alt="image">​</p><p> <strong>「イ音便」</strong></p><p>イ音便即變化後為イ字（い）。當五段動詞原形的語尾為<strong>ぐ、く</strong>時，可直接轉連用形並改為「<strong>い</strong>」的音。</p><p><img src="/../../assets/image-20240523225703-1qvj34f.png" alt="image">​</p><p> <strong>「例外」</strong></p><p>只有一個單字是例外：行く。<br>語尾雖然是「く」（ます形是き），但屬於促音便。</p><p><img src="/../../assets/image-20240523225736-7i0b8uw.png" alt="image">​</p><p>如果有聽過以下台詞，就不用擔心會忘記這個例外了：</p><ol><li>行ってらっしゃい。（慢走、路上小心。）</li><li>行ってきます。（我出門了。）</li><li>行ってください。（請走。）</li></ol><p> <strong>「例外 ２」</strong></p><p>語尾是「す」的不需要音便。<br>例如：話す、外す、移す…等，直接轉連用形即可。</p><p><img src="/../../assets/image-20240523225837-hvfo8cn.png" alt="image">​</p><p> <strong>「总结」</strong></p><pre><code>前面我們都是用「**て形**」做示範，而「た形」也是一樣的，只要把「て」改為「た」即可，以下我們列出常見的「て形」跟「た形」的例子。  </code></pre><p>​<img src="/../../assets/image-20240523225939-i6to14v.png" alt="image">​</p><p>只有五段動詞會做音便，上下一段動詞、カ變、サ變不需要做音便，直接用第二變化接續即可。</p><p><img src="/../../assets/image-20240523230015-st1t3c0.png" alt="image">​</p>]]></content>
      
      
      <categories>
          
          <category> 日语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语 </tag>
            
            <tag> 发音 </tag>
            
            <tag> 音调 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git及Gitte远程仓库与常见问题</title>
      <link href="/2025/05/24/CoddingStore/Git%E5%8F%8AGitte%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
      <url>/2025/05/24/CoddingStore/Git%E5%8F%8AGitte%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Git及Gitte远程仓库"><a href="#Git及Gitte远程仓库" class="headerlink" title="Git及Gitte远程仓库"></a>Git及Gitte远程仓库</h1><h1 id="初始的Git配置和Totorise下载配置"><a href="#初始的Git配置和Totorise下载配置" class="headerlink" title="初始的Git配置和Totorise下载配置"></a>初始的Git配置和Totorise下载配置</h1><p>配置教程：<br><a href="https://blog.csdn.net/qq_45952294/article/details/121276730">https://blog.csdn.net/qq_45952294&#x2F;article&#x2F;details&#x2F;121276730</a><br><a href="https://blog.csdn.net/weixin_43373833/article/details/107701129">https://blog.csdn.net/weixin_43373833&#x2F;article&#x2F;details&#x2F;107701129</a><br>推送失败问题解决：<a href="https://www.cnblogs.com/qingheshiguang/p/14777557.html">https://www.cnblogs.com/qingheshiguang/p/14777557.html</a></p><h1 id="如何在自己的目录下创建Git库"><a href="#如何在自己的目录下创建Git库" class="headerlink" title="如何在自己的目录下创建Git库"></a>如何在自己的目录下创建Git库</h1><p>（❗重要，如果要在有文件的地方创建版本库，强烈建议备份文件，否则很有可能切换分支导致原来的文件被删除。）</p><p>指定一个文件夹文Git库<br><img src="/assets/network-asset-1699798166265-fc282f35-8405-41f6-9dcc-e4bd19dfadbc-20250524224448-8yxdtsz.png" alt="image.png"><br>直接点击确定<br><img src="/assets/network-asset-1699798421215-8a9d7acc-b455-466c-8c28-18ba0c057c15-20250524224448-mr6f01i.png" alt="image.png"><br>出现绿勾就表示这是一个Git库<br><img src="/assets/network-asset-1699798465176-6958a2a3-ef0c-4a6e-ac00-a68963f2fab0-20250524224448-451u9xk.png" alt="image.png"><br>在库中可以添加文件，我们可以添加一个文件试试<br><img src="/assets/network-asset-1699798545462-a0445a5a-0b87-43d7-a9e6-3f5f2c55bcbe-20250524224448-e6xw3s2.png" alt="image.png"><br>添加完之后我们可以在库里新建一个文件，此时的文件未受库的控制，所以我们要在空白处右键点击Git提交到master<br><img src="/assets/network-asset-1699799160039-fcb4aa99-8582-4fe8-b5a2-161a27744966-20250524224448-m7fr8je.png" alt="image.png"><br>记得填写日志<br><img src="/assets/network-asset-1699799195121-2a04501b-5cae-4a4f-bb80-690c0a7b7c70-20250524224448-13y5m17.png" alt="image.png"><br>提交成功<br><img src="/assets/network-asset-1699799214046-a500f4ab-b1a7-4ca9-82fc-d6dd675ab828-20250524224448-2vzxifp.png" alt="image.png"><br>这时文件显示绿色，这代表这个文件已经添加到库里了，如果修改了文件，修改文件后，记得也要Git提交到master哦！<br><img src="/assets/network-asset-1699799245304-634d810d-5a90-4bb9-8e56-62be28b935bb-20250524224448-uai5yb5.png" alt="image.png"><br><a name="ObMml"></a></p><h1 id="使用totorisegit连接Git库到Gitte远程仓库"><a href="#使用totorisegit连接Git库到Gitte远程仓库" class="headerlink" title="使用totorisegit连接Git库到Gitte远程仓库"></a>使用totorisegit连接Git库到Gitte远程仓库</h1><p>新建一个Gitte库<br><img src="/assets/network-asset-1699798101220-b3d87173-5346-4e25-83db-5fc47db62e9b-20250524224448-zu4129l.png" alt="image.png"><br>复制url链接<br><img src="/assets/network-asset-1699799873445-51ab0a37-f162-4efa-bdba-5359d14a9bde-20250524224448-xscxwke.png" alt="image.png"><br>打开totorisegit的设置<br><img src="/assets/network-asset-1699799902171-5a13dd75-60d7-420f-a021-6c57c6fd35fb-20250524224448-5rcvlwv.png" alt="image.png"></p><p>在远端里，粘贴url到URL和推送URL，给你的远端起一个名字，点击添加按钮，这时你就添加了远程仓库<br><img src="/assets/network-asset-1699799969551-fe911c99-884b-4cd9-be4c-b68dc3fa2395-20250524224448-g2nqdb7.png" alt="image.png"><br>接下来，我们推送仓库的文件到远程仓库，在我们的仓库目录下，右键空白处找到totorisegit推送。<br><img src="/assets/network-asset-1699800272850-843fd0cf-aa0e-4b45-8976-c982af6e6158-20250524224448-s8s858e.png" alt="image.png"><br>将我们远端仓库的URL复制下来粘贴到远端，我们可以看到我们的远端库名称：Anime_Origin<br><img src="/assets/network-asset-1699800384585-d739cdb0-7add-44a0-ba53-890b930bcf0d-20250524224448-mm7zv0o.png" alt="image.png"><br>如果出现以下错误，则是因为我们创建的远程仓库新建了ReadME文件或者是远端代码与你的存在差异，所以造成的本地和远程不同步。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git.exe push --set-upstream --progress &quot;AnimeOrigin&quot; master</span><br><span class="line">To https://gitee.com/a2055250755/anime_controller.git</span><br><span class="line">! [rejected]        master -&gt; master (non-fast-forward)</span><br><span class="line">error: failed to push some refs to &#x27;https://gitee.com/a2055250755/anime_controller.git&#x27;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. If you want to integrate the remote changes,</span><br><span class="line">hint: use &#x27;git pull&#x27; before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决方法：1.拉取远端的文件，这可以将远端有本地没有的文件拉取进来。然后再推送即可。<br><img src="/assets/network-asset-1699802977517-8f007db7-fea0-4dfd-81c2-f31d611a905f-20250524224448-8h4v95j.png" alt="image.png"><br>2.强推，勾选两个的其中一个，直接覆盖，一般选择第一个。<br><img src="/assets/network-asset-1699803988859-adca54b6-1f32-44cb-b10b-a6a92eba3dfc-20250524224448-4i0ie4f.png" alt="image.png"><br>点击确定，推送成功。<br><img src="/assets/network-asset-1699804157433-01f3bf04-f136-40e9-8597-ea73a6e2da7d-20250524224449-5wdr6vh.png" alt="image.png"><img src="/assets/network-asset-1699804161739-e279f209-bfea-4b1d-b8bf-a6daf8e5a031-20250524224449-11ni5ya.png" alt="image.png"><br>这里，我们的tortorisegit连接Gitte远程仓库就成功啦！Github创建远程仓库连接同理。<br><a name="hfqp7"></a></p><h3 id="git使用方法"><a href="#git使用方法" class="headerlink" title="git使用方法"></a>git使用方法</h3><p><a href="https://zhuanlan.zhihu.com/p/190027619">https://zhuanlan.zhihu.com/p/190027619</a><br><a href="https://zhuanlan.zhihu.com/p/135183491">https://zhuanlan.zhihu.com/p/135183491</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">然后进入文件夹，git bash here 输入参数，</span><br><span class="line">git remote add origin https://gitee.com/xxxxx/xxxxxxxxx.git</span><br><span class="line">如果更改仓库地址 删除方法:git remote rm origin</span><br><span class="line">执行后，再使用第一步操作更改</span><br><span class="line"></span><br><span class="line">可忽略！！！！！ git add&lt;文件名&gt; 将文件修改添加到暂存区</span><br><span class="line"></span><br><span class="line">git commit -m &quot;first commit&quot;===备注--告诉git提交到库的备注提交到本地仓库</span><br><span class="line">git push -u origin master===上传文件提交到远程仓库</span><br><span class="line">git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line">git log查看提交记录</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a name="oa9Iz"></a></p><h3 id="TortoiseGit使用方法"><a href="#TortoiseGit使用方法" class="headerlink" title="TortoiseGit使用方法"></a>TortoiseGit使用方法</h3><p><a href="https://www.cnblogs.com/anayigeren/p/10177027.html">https://www.cnblogs.com/anayigeren/p/10177027.html</a></p><p>更改（TortoiseGit）远程仓库<a href="https://blog.csdn.net/CHenJiAYi__/article/details/123591119">https://blog.csdn.net/CHenJiAYi__&#x2F;article&#x2F;details&#x2F;123591119</a><br><a name="GABmu"></a></p><h6 id="添加项目："><a href="#添加项目：" class="headerlink" title="添加项目："></a>添加项目：</h6><p>创建仓库：<img src="/assets/network-asset-1699772557607-d2009a1b-64d3-4087-9494-9d3126c1bebe-20250524224449-5f3ri7w.png" alt="image.png"><br>确定地址：<img src="/assets/network-asset-1699772576461-4669155d-fa0f-4788-a701-a1b1214c2783-20250524224449-7pj0np7.png" alt="image.png"><br>克隆（空项目）：<img src="/assets/network-asset-1699772641309-44f7cc59-3776-456c-a14a-3eaa35764926-20250524224449-pf38pvw.png" alt="image.png"><br>输入地址：<img src="/assets/network-asset-1699772657011-e0251275-d41a-48e8-9ed6-a8f82e3b569d-20250524224449-m3yyung.png" alt="image.png"></p><p>进入项目，创建文件（<a href="https://blog.csdn.net/Lakers2015/article/details/112320092">https://blog.csdn.net/Lakers2015/article/details/112320092</a>）<br><img src="/assets/network-asset-1699772963599-f5076294-4dda-4da5-8787-e25a975fbe85-20250524224449-1edpalc.png" alt="image.png"><br>提交到主分支，日志不可为空，下方文件需要勾选，才可以提交<br><img src="/assets/network-asset-1699772998599-c27305c0-c33b-4b65-878e-e4d9ad837075-20250524224449-fnq7dzs.png" alt="image.png"><img src="/assets/network-asset-1699773141291-d62aac80-bc6d-459d-aba6-71cfecbe7d3e-20250524224449-rixkc1c.png" alt="image.png"><br>日志写法:</p><ol><li>第一行：提交修改内容的摘要</li><li>第二行：空格</li><li>第三行以后：修改的理由</li></ol><p>推送<br><img src="/assets/network-asset-1699773663437-79f1fd69-90fb-4cdc-8641-1acf334e6c5a-20250524224449-tydce3f.png" alt="image.png"><br><a name="pN4uM"></a></p><h6 id="成员操作"><a href="#成员操作" class="headerlink" title="成员操作"></a>成员操作</h6><p>创建分支：<br><img src="/assets/network-asset-1699772756782-749bff3a-0248-4d08-a555-c14de16d90a1-20250524224449-2rpvchj.png" alt="image.png"><img src="/assets/network-asset-1699773204189-ffc505e6-10a0-42d0-b1e7-73f5a4979c57-20250524224449-s4s11yr.png" alt="image.png"><br>切换分支：<br><img src="/assets/network-asset-1699773233058-15854f45-502d-432c-b5e9-583d5e226a22-20250524224449-memcrwx.png" alt="image.png"><br>选择新建的<br><img src="/assets/network-asset-1699773263960-b82aaad4-1fce-4e93-8323-b3f90c7ba174-20250524224449-50jijwa.png" alt="image.png"><img src="/assets/network-asset-1699773290614-3788c1f4-7671-4482-b635-95631091619e-20250524224449-vvj8dz9.png" alt="image.png"><br>在此分支上修改<br><img src="/assets/network-asset-1699773374350-b22b4ddc-5612-4510-b582-b3a160f9b760-20250524224449-nkya8k1.png" alt="image.png"><br>修改完后提交<br><img src="/assets/network-asset-1699773409280-ced21e01-e2b4-4abc-b829-51a2655c1db2-20250524224449-p2vvph9.png" alt="image.png"><img src="/assets/network-asset-1699773467956-c6d02a94-c5a8-468a-b3fd-54fcde4440d1-20250524224449-b2n54ue.png" alt="image.png"><br>推送<br><img src="/assets/network-asset-1699773527937-3ee22162-d9a3-4bd4-827f-87fd1baf223b-20250524224449-57x0dwf.png" alt="image.png"><br>拉取主分支<br><img src="/assets/network-asset-1699773785997-b0fdb934-a500-4b27-b917-8238c9fdc76a-20250524224449-2gk55y0.png" alt="image.png"><br>推送主分支<br><img src="/assets/network-asset-1699773807024-92299e49-54f0-404f-884a-65d9b53da29d-20250524224449-hy7g7od.png" alt="image.png"><img src="/assets/network-asset-1699773824228-f460f72c-5c4b-4f3a-a15a-81fab3be7233-20250524224449-hznlf6f.png" alt="image.png"></p><p><a name="Xm4nk"></a></p><h3 id="VScode使用方法"><a href="#VScode使用方法" class="headerlink" title="VScode使用方法"></a>VScode使用方法</h3><p><a href="https://blog.csdn.net/weixin_33232568/article/details/97757384">https://blog.csdn.net/weixin_33232568&#x2F;article&#x2F;details&#x2F;97757384</a><br>​<a href="https://zhuanlan.zhihu.com/p/441835934">https://zhuanlan.zhihu.com/p/441835934</a></p><p><a name="dedfd"></a></p><h3 id="UE项目使用方法"><a href="#UE项目使用方法" class="headerlink" title="UE项目使用方法"></a>UE项目使用方法</h3><p><a href="https://ue5wiki.com/wiki/7647/">https://ue5wiki.com/wiki/7647/</a></p><p><a name="yNZXX"></a></p><h2 id="项目太大-如何解决"><a href="#项目太大-如何解决" class="headerlink" title="项目太大 如何解决"></a>项目太大 如何解决</h2><h1 id="Git切换分支导致本地文件删除解决方法"><a href="#Git切换分支导致本地文件删除解决方法" class="headerlink" title="Git切换分支导致本地文件删除解决方法"></a>Git切换分支导致本地文件删除解决方法</h1><p>解决方法：</p><p>1.打开GitBash</p><p><img src="/assets/image-20241025210450-gkb2vbj.png" alt="image">​</p><p>2.执行指令 <code>git reflog</code>​</p><p>然后找到之前commit(提交)的分支，</p><p>git checkout d113b23（开头的黄色序号） 切换过来，不知道是哪个可以一个一个切，然后看文件回来了没。</p><p>git checkout -b xxxxx     重命名，自己起名字：例如：branch</p><p>git checkout master   切换回主分支</p><p>git merge xxxxx      将分支合并到master分支</p><p>git branch -d xxxxx   删除掉自己命名的临时分支</p><p><img src="/assets/image-20241025211018-bypvgob.png" alt="image"></p><p>‍</p>]]></content>
      
      
      <categories>
          
          <category> 杂文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 解决方案 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
