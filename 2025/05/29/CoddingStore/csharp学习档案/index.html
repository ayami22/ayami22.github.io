<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Csharp学习档案 | Ayami的博客帆</title><meta name="author" content="Ayami"><meta name="copyright" content="Ayami"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="学习手册：w3schools 教程					从前端到后端到数据库，各种语言教程一应俱全 枚举（1）枚举的申明enum E_ZiDan{a,//自定义枚举项的名字，b=100,c,}  枚举项未赋值时，从0开始自动赋值，往后依次累加，给某个枚举项命名后，从这个项往后依次累加。申明枚举时要在namesapce中命名。 例子： 申明一个怪物类型的枚举项 enum E_MonsterT">
<meta property="og:type" content="article">
<meta property="og:title" content="Csharp学习档案">
<meta property="og:url" content="http://example.com/2025/05/29/CoddingStore/csharp%E5%AD%A6%E4%B9%A0%E6%A1%A3%E6%A1%88/index.html">
<meta property="og:site_name" content="Ayami的博客帆">
<meta property="og:description" content="学习手册：w3schools 教程					从前端到后端到数据库，各种语言教程一应俱全 枚举（1）枚举的申明enum E_ZiDan{a,//自定义枚举项的名字，b=100,c,}  枚举项未赋值时，从0开始自动赋值，往后依次累加，给某个枚举项命名后，从这个项往后依次累加。申明枚举时要在namesapce中命名。 例子： 申明一个怪物类型的枚举项 enum E_MonsterT">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://t.alcy.cc/lai?62">
<meta property="article:published_time" content="2025-05-28T22:47:50.000Z">
<meta property="article:modified_time" content="2025-05-29T06:58:52.327Z">
<meta property="article:author" content="Ayami">
<meta property="article:tag" content="Csharp">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="面向对象">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://t.alcy.cc/lai?62"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Csharp学习档案",
  "url": "http://example.com/2025/05/29/CoddingStore/csharp%E5%AD%A6%E4%B9%A0%E6%A1%A3%E6%A1%88/",
  "image": "https://t.alcy.cc/lai?62",
  "datePublished": "2025-05-28T22:47:50.000Z",
  "dateModified": "2025-05-29T06:58:52.327Z",
  "author": [
    {
      "@type": "Person",
      "name": "Ayami",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/assets/icon.jpg"><link rel="canonical" href="http://example.com/2025/05/29/CoddingStore/csharp%E5%AD%A6%E4%B9%A0%E6%A1%A3%E6%A1%88/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'medium_zoom',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Csharp学习档案',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/modify.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/assets/background.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/assets/icon.jpg" onerror="this.onerror=null;this.src='/assets/friend_404.gif'" alt="avatar"></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa-solid fa-timeline"></i><span> 时间戳</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: [object Object];"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Ayami的博客帆</span></a><a class="nav-page-title" href="/"><span class="site-name">Csharp学习档案</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/timeline/"><i class="fa-fw fa-solid fa-timeline"></i><span> 时间戳</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Csharp学习档案</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-28T22:47:50.000Z" title="发表于 2025-05-29 06:47:50">2025-05-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-29T06:58:52.327Z" title="更新于 2025-05-29 14:58:52">2025-05-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Csharp%E7%9B%B8%E5%85%B3/">Csharp相关</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">23.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>86分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-05-29 14:58:52&quot;}" hidden=""></div><h1 id="学习手册："><a href="#学习手册：" class="headerlink" title="学习手册："></a>学习手册：</h1><p><a target="_blank" rel="noopener" href="https://www.w3ccoo.com/">w3schools 教程</a>					从前端到后端到数据库，各种语言教程一应俱全</p>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="（1）枚举的申明"><a href="#（1）枚举的申明" class="headerlink" title="（1）枚举的申明"></a>（1）枚举的申明</h2><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> E_ZiDan</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">a,<span class="comment">//自定义枚举项的名字，</span></span><br><span class="line"></span><br><span class="line">b=<span class="number">100</span>,</span><br><span class="line"></span><br><span class="line">c,</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>枚举项未赋值时，从0开始自动赋值，往后依次累加，给某个枚举项命名后，从这个项往后依次累加。申明枚举时要在namesapce中命名。</p>
<p>例子：</p>
<p>申明一个怪物类型的枚举项</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> E_MonsterType</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">Normal,</span><br><span class="line"></span><br><span class="line">Boss,</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>申明一个玩家类型的枚举项</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> E_Player</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">main,</span><br><span class="line"></span><br><span class="line">other,</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="（2）枚举变量的申明初始化和使用"><a href="#（2）枚举变量的申明初始化和使用" class="headerlink" title="（2）枚举变量的申明初始化和使用"></a>（2）枚举变量的申明初始化和使用</h2><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="built_in">enum</span> E_Player</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">main,</span><br><span class="line"></span><br><span class="line">other,</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">E_Player e_Player = E_Player.main;</span><br></pre></td></tr></tbody></table></figure>

<h1 id="变量的类型及转换（显隐转换）"><a href="#变量的类型及转换（显隐转换）" class="headerlink" title="变量的类型及转换（显隐转换）"></a>变量的类型及转换（显隐转换）</h1><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//有符号</span></span><br><span class="line"><span class="built_in">sbyte</span></span><br><span class="line"><span class="built_in">int</span></span><br><span class="line"><span class="built_in">short</span></span><br><span class="line"><span class="built_in">long</span></span><br><span class="line"><span class="built_in">float</span>      <span class="comment">//c#中初始化：float=数值f，f用于区别于double类型 例： float f = 123.45f</span></span><br><span class="line"><span class="built_in">double</span></span><br><span class="line"><span class="comment">//无符号</span></span><br><span class="line"><span class="built_in">byte</span></span><br><span class="line"><span class="built_in">uint</span></span><br><span class="line"><span class="built_in">ushort</span></span><br><span class="line"><span class="built_in">ulong</span></span><br><span class="line"><span class="comment">//特殊类型</span></span><br><span class="line"><span class="built_in">bool</span> <span class="comment">//装true 或 false</span></span><br><span class="line"><span class="built_in">char</span> <span class="comment">//字符 只能存一个字符</span></span><br><span class="line"><span class="built_in">string</span> <span class="comment">//字符串</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>隐式转换（直接等号转换）</strong></p>
<p>大范围包含小范围，基本相同大类型互相转换，特使类型中，char可以转换为int以外，bool和string都不能隐式转换</p>
<p><strong>显示转换</strong></p>
<h3 id="括号转换"><a href="#括号转换" class="headerlink" title="括号转换"></a><strong>括号转换</strong></h3><p><strong>1.变量名=（转换类型）变量名；</strong></p>
<p>2 <strong>.bool</strong>和<strong>string</strong>不能通过括号转换强转</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> x；</span><br><span class="line"><span class="built_in">long</span> y；</span><br><span class="line">x=（<span class="built_in">int</span>）y</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Parse法-（把字符串类型转换为相应的类型）"><a href="#Parse法-（把字符串类型转换为相应的类型）" class="headerlink" title="Parse法 （把字符串类型转换为相应的类型）"></a><strong>Parse法</strong> （把字符串类型转换为相应的类型）</h3><p>（例如接受用户输入的字符串，将用户输入的字符串转换为相应的可以进行运算的数值）</p>
<p><strong>语法</strong>：<strong>变量类型.parse(“字符串”)</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> i = <span class="built_in">int</span>.parse(“<span class="number">123</span>”);</span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> f = <span class="built_in">float</span>.parse(“<span class="number">123.45</span>”);</span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> b = <span class="built_in">bool</span>.parse(“<span class="literal">true</span>”);</span><br><span class="line"></span><br><span class="line">console.write(<span class="built_in">int</span>.parse(“<span class="number">123</span>”));</span><br></pre></td></tr></tbody></table></figure>

<p>‍</p>
<p>注意：字符串必须能够转换成相应类型否则报错</p>
<h3 id="Convert法（更准确地将各个类型之间进行转换）"><a href="#Convert法（更准确地将各个类型之间进行转换）" class="headerlink" title="Convert法（更准确地将各个类型之间进行转换）"></a>Convert法（更准确地将各个类型之间进行转换）</h3><p><strong>语法： convert.To目标类型（变量或者常量）</strong></p>
<p><strong>例如：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = convert.ToInt32(“<span class="number">123</span>”); <span class="comment">//结果： 123</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> a = convert.ToInt32(<span class="number">1.692f</span>); <span class="comment">//(遵循四舍五入) 结果： 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> a = convert.ToInt32(<span class="literal">true</span>); <span class="comment">//（bool类型转int ）结果： 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> a = convert.ToInt32(“A”); <span class="comment">//字符类型转int 结果： 65</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">short</span> a = convert.ToInt16(“<span class="number">1</span>”);<span class="comment">//字符串类型转short，short对应的是int16</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">long</span> a = convert.ToInt64(“<span class="number">12</span>”); <span class="comment">//字符串类型转long型，long对应int64</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">byte</span> a = convert.ToByte(“<span class="number">3</span>”);</span><br><span class="line"></span><br><span class="line"><span class="built_in">uint</span> a = convert.ToUint32(“<span class="number">4</span>”); <span class="comment">//无符号类型的转换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">float</span> a = convert.ToSingle(“<span class="number">123.45</span>”); <span class="comment">//float对应single（单精度）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> a = convert.ToDouble(“<span class="number">123.45</span>”);<span class="comment">// double对应double（双精度）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bool</span> b = convert.ToBoolean(“<span class="literal">true</span>”); <span class="comment">//bool 对应 Boolean</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">char</span> a =convert.ToChar(“A”);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = convert.ToString(<span class="number">123</span>);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="其他类型转string"><a href="#其他类型转string" class="headerlink" title="其他类型转string"></a>其他类型转string</h3><p><strong>1.convert法：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">123</span>；</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = Convert.ToString(a);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>2.toString法：</strong></p>
<p><strong>语法： 变量.toString();</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="number">1.</span>toString(); <span class="comment">//整型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = <span class="literal">true</span>.toString(); <span class="comment">//bool类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = <span class="number">123.45f</span>.toString(); <span class="comment">//浮点</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = “A”.toString(); <span class="comment">//字符</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>另一种写法</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">Int a = <span class="number">6</span>；</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = a.toString();</span><br></pre></td></tr></tbody></table></figure>

<p><strong>在下面例子中，计算机用到了此方法进行转换</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">Console.WriteLine(“<span class="number">12345</span>” + <span class="number">1</span> + <span class="literal">true</span> );</span><br></pre></td></tr></tbody></table></figure>

<h3 id="数组与数组之间的转换"><a href="#数组与数组之间的转换" class="headerlink" title="数组与数组之间的转换"></a>数组与数组之间的转换</h3><p>Array.ConvertAll&lt;转换的对象的元素类型，要转换为的元素类型&gt;(转换对象，转换方法)</p>
<p>语法：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//TInput 和 TOutput 分别是源数组和目标数组。</span></span><br><span class="line"><span class="comment">//array:一个从零开始的一维数组，用于转换为目标类型。</span></span><br><span class="line"><span class="comment">//converter:一个转换器，用于将每个元素从一种类型转换为另一种类型。 </span></span><br><span class="line"><span class="comment">//简单理解：ConvertAll方法就是遍历源数组中的每一个元素，执行一个转换函数（括号里的第二个参数），并返回新的数组。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TOutput[] <span class="title">ConvertAll</span>&lt;<span class="title">TInput</span>,<span class="title">TOutput</span>&gt; (<span class="params">TInput[] array, Converter&lt;TInput,TOutput&gt; converter</span>)</span>;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//括号里面的第二个参数使用的lamda表达式。</span></span><br><span class="line"><span class="comment">//将int数组转换为字符数组</span></span><br><span class="line">  <span class="built_in">int</span>[] a = { <span class="number">5</span>, <span class="number">4</span> };          </span><br><span class="line">  <span class="built_in">string</span>[] b = Array.ConvertAll&lt;<span class="built_in">int</span>, <span class="built_in">string</span>&gt;(a,num=&gt;num.ToString());</span><br><span class="line"><span class="comment">//将string数组转为int数组</span></span><br><span class="line">  <span class="built_in">string</span>[] str = { <span class="string">"123"</span>, <span class="string">"456"</span> };</span><br><span class="line">  <span class="built_in">int</span>[] array = Array.ConvertAll&lt;<span class="built_in">string</span>, <span class="built_in">int</span>&gt;(str, str =&gt; <span class="built_in">int</span>.Parse(str));</span><br><span class="line"><span class="comment">//遍历提取出自定义类型的属性值：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span> {</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title">Person</span> {</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> Name { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">	}</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span> {</span><br><span class="line">      Person[] people = {</span><br><span class="line">         <span class="keyword">new</span> Person { Name = <span class="string">"Aman"</span> },</span><br><span class="line">         <span class="keyword">new</span> Person { Name = <span class="string">"Kumar"</span> },</span><br><span class="line">         <span class="keyword">new</span> Person { Name = <span class="string">"Gupta"</span> }</span><br><span class="line">      };</span><br><span class="line">	<span class="comment">//遍历people源数组，执行person =&gt; person.Name函数，并返回一个string数组</span></span><br><span class="line">      <span class="built_in">string</span>[] names = Array.ConvertAll(people, person =&gt; person.Name);</span><br><span class="line">      Console.WriteLine(<span class="string">"Converted to names:"</span>);</span><br><span class="line">      <span class="keyword">foreach</span> (<span class="built_in">string</span> name <span class="keyword">in</span> names) {</span><br><span class="line">         Console.WriteLine(name);</span><br><span class="line">      }</span><br><span class="line">   }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h1><p><strong>作用</strong>：避免代码报错时出现的程序卡死。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//必备部分</span></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//放需要进行异常捕获的代码块</span></span><br><span class="line"><span class="comment">//如果try中的代码块出错，会跳转到catch中</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//必备部分</span></span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">{</span><br><span class="line"><span class="comment">//如果出错，会执行catch中的代码来进行移除捕获</span></span><br><span class="line"><span class="comment">//catch后还可写为catch（Exception e）具体报错跟踪通过e得到具体的错误</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//可选部分</span></span><br><span class="line"><span class="keyword">finally</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"><span class="comment">//最后执行的代码块 不管出没出错都会执行</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>例子：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line">Console.WriteLine(“请输入数字”)；</span><br><span class="line">String str = console,ReadLine();</span><br><span class="line">Int i = <span class="built_in">int</span>.parse(str);</span><br><span class="line">Console.WriteLine( i );</span><br><span class="line">}</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line">Console.WriteLine(“请输入合法数字”);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="字符串拼接（非打印拼接）"><a href="#字符串拼接（非打印拼接）" class="headerlink" title="字符串拼接（非打印拼接）"></a>字符串拼接（非打印拼接）</h1><h3 id="1-字符串用＋号拼接"><a href="#1-字符串用＋号拼接" class="headerlink" title="1.字符串用＋号拼接"></a>1.字符串用＋号拼接</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="built_in">string</span> str = “<span class="number">123</span>”;</span><br><span class="line">str=str + “<span class="number">456</span>”;</span><br><span class="line">str=str + <span class="number">456</span>;     				  <span class="comment">//（456是整形，但是在这里默认调用了toString，将456转换为了字符串）</span></span><br><span class="line">str += “<span class="number">456</span>”+<span class="number">789</span>; 结果为<span class="number">123456789</span>  <span class="comment">//结果为123456789</span></span><br><span class="line"><span class="comment">//注意</span></span><br><span class="line">str += <span class="number">4</span>+<span class="number">5</span>+<span class="number">6</span>； 					  <span class="comment">//先算右侧结果，整型相加为15，接着再拼接，结果为12315</span></span><br><span class="line">str += “<span class="number">4</span>”+<span class="number">5</span>+<span class="number">6</span>；				  <span class="comment">// 右侧式子从左到右运算，结果为123456，先将字符4和5进行拼接，然后依次进行拼接。</span></span><br><span class="line">Str += <span class="number">4</span>+<span class="number">5</span>+“”+<span class="number">6</span>； 			<span class="comment">//右侧式子为4+5=9，“”为空字符串，9+“”相当于将9转换为字符串，接着与6进行拼接，结果为12396</span></span><br><span class="line">Str = <span class="number">4</span>+<span class="number">5</span>+“”+（<span class="number">6</span>+<span class="number">7</span>） 		<span class="comment">//结果为123913</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-字符串占位拼接"><a href="#2-字符串占位拼接" class="headerlink" title="2.字符串占位拼接"></a>2.字符串占位拼接</h3><p><strong>语法： string.Format(“带拼接的内容{0}，带拼接的内容{1}，”，内容0，内容1);</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//此句中，18是整型，但是调用了toString，也可填写true，123.45f等其他类型</span></span><br><span class="line">sring str = <span class="built_in">string</span>.Format(“我是{<span class="number">0</span>}，我今年{<span class="number">1</span>}，我想要{<span class="number">2</span>}”，“李明”，<span class="number">18</span>，“好好学习”)；</span><br></pre></td></tr></tbody></table></figure>

<h1 id="位运算符和三目运算符"><a href="#位运算符和三目运算符" class="headerlink" title="位运算符和三目运算符"></a>位运算符和三目运算符</h1><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>位与 &amp; 两个位都为1时，结果才为1</p>
<p>位或 | 两个位都为0时，结果才为0</p>
<p>异或 ^ 两个位相同为0，相异为1</p>
<p>取反 ~ 0变1，1变0</p>
<p>左移 &lt;&lt; 各二进位全部左移若干位，高位丢弃，低位补0</p>
<p>右移 &gt;&gt; 各二进位全部右移若干位，对无符号数，高位补0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补0（逻辑右移）</p>
<p>‍</p>
<h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>‍</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//  condition ? expression1 : expression2;</span></span><br><span class="line"><span class="comment">//  条件       ？ 为真返回值   ： 为假返回值</span></span><br><span class="line"> <span class="built_in">string</span> str = <span class="built_in">int</span> a&gt; <span class="built_in">int</span> b ? “大于” ：“小于”；</span><br><span class="line"> <span class="keyword">return</span> a&gt;b ? <span class="number">1</span> : <span class="number">-1</span> ;</span><br></pre></td></tr></tbody></table></figure>

<h1 id="C-中的数组"><a href="#C-中的数组" class="headerlink" title="C#中的数组"></a>C#中的数组</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//语法： 变量类型 [] 变量名</span></span><br><span class="line"><span class="comment">//写法1：</span></span><br><span class="line"><span class="built_in">int</span>[] arr1;</span><br><span class="line">arr1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//写法2：</span></span><br><span class="line"><span class="built_in">int</span>[] arr1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="comment">//写法3：</span></span><br><span class="line"><span class="built_in">int</span>[] arr1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line"><span class="comment">//写法4：</span></span><br><span class="line"><span class="built_in">int</span>[] arr1 = <span class="keyword">new</span> <span class="built_in">int</span>[]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,……}；</span><br><span class="line"><span class="comment">//写法5：</span></span><br><span class="line"><span class="built_in">int</span>[] arr1 = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,……}；</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="built_in">int</span> arr[] = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];	<span class="comment">//申明了数组 </span></span><br><span class="line"> arr[<span class="number">1</span>]=<span class="number">1</span>; 				<span class="comment">//赋值</span></span><br><span class="line"> arr.Length				<span class="comment">//获取数组长度：数组名 . Length </span></span><br><span class="line">console.WriteLine(arr.Length);	<span class="comment">//打印数组长度 </span></span><br><span class="line"><span class="comment">//遍历数组：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>; i&lt; arr1.Length;i++)</span><br><span class="line">{</span><br><span class="line">}</span><br><span class="line"><span class="comment">//数组扩容：</span></span><br><span class="line"><span class="built_in">int</span>[] arr1 = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line"><span class="built_in">int</span>[] arr2 = <span class="keyword">new</span> <span class="built_in">int</span> [<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;I&lt;arr1.Length;i++)</span><br><span class="line">{</span><br><span class="line">arr2[i]=arr1[i];</span><br><span class="line">}</span><br><span class="line">arr1=arr2; <span class="comment">//(将将arr1指向arr2数组，实现了arr1数组的扩容)</span></span><br><span class="line"><span class="comment">//缩容的话申请个较小的数组然后赋值后改指针指向</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>语法： int[,] arr = new int[2,3]{1,2,3,4,5,6};</p>
<p>写法和一维数组相同</p>
<p>使用：</p>
<p>获取数组长度</p>
<p>获取行长： arr1.GetLength（0）</p>
<p>获取列长： arr1.GetLength（1）</p>
<p>遍历二维数组：for（int i=0；i&lt;arr1,GetLength(0);i++） //行</p>
<p>{</p>
<p>For(int j=0;j&lt;arr1.GetLength(1);j++) //列</p>
<p>{</p>
<p>}</p>
<p>}</p>
<p>扩容二维数组：（和一维数组同一思想）</p>
<p>交错数组：</p>
<p>概念：装数组的数组，类似于指针数组；相当于二维数组，但是列长可以不一样</p>
<p>申明： 变量类型[][] <strong>变量名</strong>= new 变量类型[交错数组长度][]{一维数组1，2，……}；</p>
<p>举例： int[][] array = new int[3][]{ new int[]{1,2,3},</p>
<p>new int[]{4,5},</p>
<p>new int[]{7,8,9,10}};</p>
<p>获取长度 array.GetLength(0); 获取行长</p>
<p>array[i].GetLength(1); 获取某一列的长度</p>
<p>获取其中的元素 array[0][1] 获取第一行第二列的元素</p>
<p>遍历交错数组：</p>
<p>for (int i = 0; i &lt;array.GetLength(0); i++)</p>
<p>{</p>
<p>for (int j = 0; j &lt; array[i].Length; j++)</p>
<p>{</p>
<p>Console.Write(array3[i][j]+” “);</p>
<p>}</p>
<p>}</p>
<p>扩容交错数组：</p>
<p>和数组扩容同一原理</p>
<h1 id="值和引用（相当于c语言中的指针和值类型）"><a href="#值和引用（相当于c语言中的指针和值类型）" class="headerlink" title="值和引用（相当于c语言中的指针和值类型）"></a>值和引用（相当于c语言中的指针和值类型）</h1><ul>
<li><p><strong>引用类型：</strong></p>
<ul>
<li>string 、数组 、Class（类）</li>
<li><strong>在堆里申请的内存，在栈里存放的是地址）</strong></li>
<li>当声明一个类时，只在栈中分配一小片内存用于容纳一个地址，而此时<strong>并没有为其分配堆上的内存空间</strong>。当使用 new 创建一个类的实例时，分配堆上的空间，并把堆上空间的地址保存到栈上分配的小片空间中。</li>
</ul>
</li>
<li><p><strong>值类型：</strong></p>
<ul>
<li>除以上三种类型的其他类型( byte，short，int，long，float，double，decimal，char，bool 和 struct )</li>
<li><strong>（在栈里申请内存）</strong></li>
</ul>
</li>
</ul>
<p>由此可知</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//example 1</span></span><br><span class="line"><span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>]{{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};		<span class="comment">//arr存放的只是内存的地址</span></span><br><span class="line">arr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>};   		<span class="comment">// new代表新开辟的一个内存空间,初始化一块新的内存</span></span><br><span class="line"><span class="comment">//example 2</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>‍</p>
<h1 id="特殊的引用类型string"><a href="#特殊的引用类型string" class="headerlink" title="特殊的引用类型string"></a>特殊的引用类型string</h1><p>‍</p>
<p>​<code>string</code>​类型是不可变的字符串，一旦创建不能修改。<code>string</code>​类型在多次赋值时，会产生新的内存，将新的内容放在新的内存中，然后string存放新内存的地址，但是旧的内容的内存不会被回收，这样，多次给<code>string</code>​重新赋值时，会产生内存垃圾。</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str1= “<span class="number">12345</span>”；</span><br><span class="line">str1=“<span class="number">123</span>”； 		<span class="comment">//重新赋值后，“12345”所占内存不会被回收。</span></span><br><span class="line"><span class="built_in">string</span> str2=str1； 	<span class="comment">// str2指向str1的内存</span></span><br><span class="line">Str2=“<span class="number">123456</span>”； 	<span class="comment">//str2重新赋值会重新开辟内存空间，不会修改str1的内容。</span></span><br></pre></td></tr></tbody></table></figure>

<p>所以当我们对string需要非常频繁地拼接或修改字符串时，会产生非常大的内存消耗。这时候我们可以选用 <code>StringBuilder</code>​ 类来进行操作。（需要引用命名空间 <code>using System.Text;</code>​ ）</p>
<p><code>StringBuilder</code>​ 是可变的字符串缓冲区，适合频繁拼接或修改字符串的情况。</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="comment">//频繁地拼接或修改字符串时，用StringBuilder可以减少GC压力。</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) {</span><br><span class="line">    sb.Append(<span class="string">"Item"</span>).Append(i).Append(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>‍</p>
<table>
<thead>
<tr>
<th>比较项</th>
<th>​<code>string</code>​</th>
<th>​<code>StringBuilder</code>​</th>
</tr>
</thead>
<tbody><tr>
<td><strong>是否可变</strong></td>
<td>❌ 不可变，每次修改都会创建新字符串</td>
<td>✅ 可变，修改不会创建新对象</td>
</tr>
<tr>
<td><strong>性能（频繁操作）</strong></td>
<td>❌ 较差：每次拼接都会生成新对象</td>
<td>✅ 较好：内部使用字符数组动态扩容</td>
</tr>
<tr>
<td><strong>内存效率</strong></td>
<td>❌ 差（频繁拼接会产生很多临时字符串）</td>
<td>✅ 高效（在原有缓存上操作）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>小量拼接、只读操作、配置读取、UI显示等</td>
<td>循环拼接、日志记录、大量字符串拼接场景</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>✅ 线程安全（不可变）</td>
<td>❌ 默认不是线程安全的</td>
</tr>
<tr>
<td><strong>常用操作</strong></td>
<td>​<code>+</code>​、<code>Replace</code>​、<code>Substring</code>​等</td>
<td>​<code>Append</code>​、<code>Insert</code>​、<code>Replace</code>​、<code>Remove</code>​等</td>
</tr>
</tbody></table>
<p>‍</p>
<table>
<thead>
<tr>
<th>你要做的事<br></th>
<th>推荐使用类型</th>
</tr>
</thead>
<tbody><tr>
<td>拼接几段字符串</td>
<td>​<code>string</code>​</td>
</tr>
<tr>
<td>循环中拼接字符串（如生成代码、日志）</td>
<td>​<code>StringBuilder</code>​</td>
</tr>
<tr>
<td>替换、截取少量字符串内容</td>
<td>​<code>string</code>​</td>
</tr>
<tr>
<td>对性能要求高的字符串处理</td>
<td>​<code>StringBuilder</code>​</td>
</tr>
</tbody></table>
<p>‍</p>
<h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><h2 id="深拷贝和浅拷贝详解"><a href="#深拷贝和浅拷贝详解" class="headerlink" title="深拷贝和浅拷贝详解"></a>深拷贝和浅拷贝详解</h2><ul>
<li>对于所有面向对象的语言，复制永远是一个容易引发讨论的题目，C#中也不例外。</li>
<li>深拷贝：指的是拷贝一个对象时，不仅仅把对象的引用进行复制，还把该对象引用的值也一起拷贝。这样进行深拷贝后的拷贝对象就和源对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。 <strong>（拷贝整个对象的内容，包括其内部引用指向的对象也会新建一份）</strong></li>
<li>浅拷贝：指的是拷贝一个对象时，仅仅拷贝对象的引用进行拷贝，但是拷贝对象和源对象还是引用同一份实体。 <strong>（拷贝对象的“引用”地址，新对象和原对象指向同一块内存。）</strong></li>
</ul>
<p>学习过上面的值类型和引用类型后，我们可以知道，<strong>值类型是深拷贝</strong>，是<strong>开辟了新的内存并复制了值</strong>。而<strong>引用类型存储的是值所在内存的地址</strong>，所以引用类型的复制只是复制了值所在的地址，<strong>并没有再新开辟一个内存把值复制进去</strong>。（要注意C#里的string类型是一个特殊的引用类型）</p>
<p>‍</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    {</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        {</span><br><span class="line">            Person A = <span class="keyword">new</span> Person() { Name = <span class="string">"小李"</span> };</span><br><span class="line">            Person B = A;		 <span class="comment">// 浅拷贝</span></span><br><span class="line">            B.Name = <span class="string">"小黄"</span>; <span class="comment">// 拷贝对象改变Name值</span></span><br><span class="line">            <span class="comment">// 结果都是"小李",因为是浅拷贝，只是将A的值内存地址传递给了B，所以无论对B还是A进行修改，修改的都是同一个内存的值。</span></span><br><span class="line">            Console.WriteLine(<span class="string">"Person.Name: [A: {0}] [B:{1}]"</span>, A.Name, B.Name);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>‍</p>
<h2 id="C-实现自定义对象或数据集合的深拷贝"><a href="#C-实现自定义对象或数据集合的深拷贝" class="headerlink" title="C#实现自定义对象或数据集合的深拷贝"></a>C#实现自定义对象或数据集合的深拷贝</h2><p>有时候我们需要创建一个对象副本，且修改对象副本不会改变源对象的数据，这就需要使用深拷贝。那么我们在C#如何让引用类型也能实现深拷贝呢？</p>
<h3 id="1-使用序列化和反序列化"><a href="#1-使用序列化和反序列化" class="headerlink" title="1.使用序列化和反序列化"></a>1.使用序列化和反序列化</h3><p>网上有许多使用 <code>BinaryFormatter</code>​ 进行序列化的方法，但是这个方法在NET 5及以上已被标记为不安全和过时，且有安全风险。现在我们会用 <code>System.Text.Json</code>​ 序列化来替代。记得引入命名空间 <code>using System.Text.Json;</code>​</p>
<p>在<code>.NET Core 3.0及以上版本</code>​中，可以使用<code>System.Text.Json</code>​库进行深拷贝。原理是使用<code>JsonSerializer.Serialize()</code>​将对象转换为Json字符串，再使用<code>JsonSerializer.Deserialize()</code>​将Json字符串转换为新的对象。</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//注意：在Unity老版本不支持System.Text.Json进行序列化和反序列化，因为Unity老版本使用的是老版本.NET。</span></span><br><span class="line"><span class="comment">//例如我的Unity版本使用的是2020.3.28f1，使用的是NET Standard 2.0。</span></span><br><span class="line"><span class="comment">//查看你的Unity 使用的NET版本请在Unity里点击：ProjectSetting -&gt; Player -&gt; Other Settings，在里面翻一翻，可以看到 NET XXX。</span></span><br><span class="line"><span class="comment">//所以如果想在Unity使用序列化，请了解使用: XML，JsonUtility，Newtonsoft.Json，LitJson等。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Text.Json;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用System.Text.Json不需要[Serializable] 特性，这一点和BinaryFormatter不同。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyComplexObject</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">    <span class="comment">// 其他属性</span></span><br><span class="line">}</span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对象深拷贝扩展方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">DeepCopier</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">//深拷贝方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> T <span class="title">DeepCopy</span>&lt;<span class="title">T</span>&gt;(<span class="params">T obj</span>)</span></span><br><span class="line">{	<span class="comment">//序列化</span></span><br><span class="line">    <span class="built_in">string</span> json = JsonSerializer.Serialize(obj);</span><br><span class="line">	<span class="comment">//反序列化</span></span><br><span class="line">    <span class="keyword">return</span> JsonSerializer.Deserialize&lt;T&gt;(json);</span><br><span class="line">	<span class="comment">//原理：通过序列化源对象和反序列化创建了个新的副本对象返回。</span></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//调用示例：</span></span><br><span class="line">MyComplexObject original = <span class="keyword">new</span> MyComplexObject { Id = <span class="number">1</span>, Name = <span class="string">"Test"</span> };</span><br><span class="line">MyComplexObject copy = DeepCopier.DeepCopy(original);	</span><br><span class="line"><span class="comment">// 修改原对象不会影响 copy</span></span><br><span class="line">original.Name = <span class="string">"Changed"</span>;</span><br><span class="line">Console.WriteLine(copy.Name); <span class="comment">// 输出 "Test"</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-使用Newtonsoft-Json"><a href="#2-使用Newtonsoft-Json" class="headerlink" title="2.使用Newtonsoft.Json"></a>2.使用Newtonsoft.Json</h3><p>‍</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">‍</span><br><span class="line"></span><br><span class="line"><span class="meta">### 3.实现 `ICloneable`​ 接口 + 自定义 `Clone()`​</span></span><br><span class="line"></span><br><span class="line">‍</span><br><span class="line"></span><br><span class="line"><span class="meta">### 4.使用 `MemberwiseClone()`​</span></span><br><span class="line"></span><br><span class="line">‍</span><br><span class="line"></span><br><span class="line"><span class="meta">### 5.使用第三方库（推荐 AutoMapper）</span></span><br><span class="line"></span><br><span class="line">‍</span><br><span class="line"></span><br><span class="line"><span class="meta">### 6.使用表达树</span></span><br><span class="line"></span><br><span class="line">‍</span><br><span class="line"></span><br><span class="line">**为什么要使用深拷贝？**   </span><br><span class="line">​`深拷贝是一种保持数据独立性和完整性的重要手段，在许多场景下都是不可或缺的操作。 `​使用深拷贝的原因主要有以下几点：</span><br><span class="line"></span><br><span class="line">- 独立性：深拷贝创建的是一个完全独立的副本，对副本的操作不会影响原始数据，这在一些场景中非常重要，比如数据备份、多线程编程等。</span><br><span class="line">- 安全性：通过深拷贝，可以避免意外修改原始数据，从而提高代码的安全性和稳定性。</span><br><span class="line">- 可复用性：深拷贝后的副本可以独立使用和修改，方便代码的复用和模块化开发。</span><br><span class="line">- 隔离性：在一些复杂的数据结构中，深拷贝可以确保不同部分的数据相互隔离，避免不必要的关联和影响。</span><br><span class="line">- 性能优化：对于一些需要频繁修改数据的场景，使用深拷贝可以避免不必要的共享和同步操作，提高程序的性能。</span><br><span class="line"></span><br><span class="line">应用场景：</span><br><span class="line"></span><br><span class="line">无论是浅拷贝还是深拷贝，一般都用于操作Object 或 Array之类的复合类型。</span><br><span class="line"></span><br><span class="line">- **数据备份和恢复**：在进行数据备份时，使用深拷贝可以创建数据的完整副本，以便在需要时进行恢复。</span><br><span class="line"></span><br><span class="line">- **对象复制和克隆**：当需要创建一个对象的副本时，深拷贝可以确保副本与原始对象完全独立，不会相互影响。</span><br><span class="line"></span><br><span class="line">- **多线程编程**：在多线程环境下，深拷贝可以避免多个线程同时修改同一个对象导致的竞态条件。</span><br><span class="line">- **数据传递和共享**：将数据通过深拷贝传递给其他模块或进程，可以确保数据的独立性和完整性。</span><br><span class="line">- **缓存和数据持久化**：深拷贝可以用于缓存数据或将数据持久化到存储介质中，以提高性能和数据的可用性。</span><br><span class="line">- **测试和模拟**：在测试代码中，深拷贝可以用于创建测试数据的副本，以便进行各种测试和模拟。</span><br><span class="line"></span><br><span class="line">其他参考：</span><br><span class="line"></span><br><span class="line">[<span class="meta">C#|.net core 基础 - 深拷贝的五大类N种实现方式</span>](https:<span class="comment">//blog.csdn.net/zhulianfang1991/article/details/142421562#:~:text=C%23%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%A4%8D%E6%9D%82%EF%BC%8C%E6%96%87%E4%B8%AD%E4%BB%8B%E7%BB%8D%E4%BA%86%E4%BA%94%E5%A4%A7%E7%B1%BBN%E7%A7%8D%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95%EF%BC%8C%E5%8C%85%E6%8B%AC%E7%AE%80%E5%8D%95%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E3%80%81%E6%89%8B%E5%8A%A8%E6%96%B9%E5%BC%8F%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F%E3%80%81%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E6%96%B9%E5%BC%8F%E5%92%8C%E6%89%A9%E5%B1%95%E8%A7%86%E9%87%8E%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%B9%B6%E5%AF%B9%E6%AF%94%E4%BA%86%E6%80%A7%E8%83%BD%E3%80%82%20%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8AutoMapper%E5%92%8CDeepCloner%E7%AD%89%E6%88%90%E7%86%9F%E5%BA%93%E6%88%96%E6%A0%B9%E6%8D%AE%E6%80%A7%E8%83%BD%E9%9C%80%E6%B1%82%E9%80%89%E6%8B%A9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E5%92%8CEmit%E3%80%82,_c%23%20%E6%B7%B1%E6%8B%B7%E8%B4%9D)</span></span><br><span class="line"></span><br><span class="line">[深拷贝：概念、使用原因、应用场景、<span class="number">3</span>种常用方法](https:<span class="comment">//blog.csdn.net/cuclife/article/details/136453132)</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># C#函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">### 函数的基本知识</span></span><br><span class="line"></span><br><span class="line">- 函数名使用帕斯卡写法，即每个单词首字母大写</span><br><span class="line"></span><br><span class="line">- 函数的调用： 函数名（参数）； 有返回值则用可用返回类型接收</span><br><span class="line"></span><br><span class="line">- 返回多个值：用数组类型</span><br><span class="line"></span><br><span class="line">函数写在<span class="keyword">class</span>、<span class="title">struct</span>语句块中写法：</span><br><span class="line"></span><br><span class="line">```<span class="title">C</span>#</span><br><span class="line"><span class="title">Static</span> <span class="title">void</span>/其他类型 函数名（变量类型参数1，2，……）</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"><span class="comment">//函数代码逻辑</span></span><br><span class="line"><span class="keyword">return</span> 返回值（如有返回值才返回）</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayhello</span>(<span class="params"><span class="built_in">string</span> str</span>) <span class="comment">//无返回类型有参数</span></span></span><br><span class="line">{</span><br><span class="line">Console.WriteLine(str);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">sayhello</span>(<span class="params"><span class="built_in">string</span> str</span>) <span class="comment">//有返回有参数</span></span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">Console.WriteLine(str);</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">sayhello</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>函数举例：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span>[] <span class="title">sayhello</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">int</span> sum = a + b;</span><br><span class="line">	<span class="built_in">int</span> avg = (a + b) / <span class="number">2</span>;</span><br><span class="line">	<span class="built_in">int</span>[] arr = { sum,avg };</span><br><span class="line">	<span class="keyword">return</span> arr;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>关于<code>return</code>​：</p>
<ul>
<li><p>对于有返回值的函数，return需要返回函数声明的返回值类型的值。</p>
</li>
<li><p>对于无返回值函数，单独一个 <code>return </code>​可以直接返回函数外部，后面的代码不执行。</p>
</li>
</ul>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">speak</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span>(a+b&gt;<span class="number">10</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span>; <span class="comment">//注意：当返回类型为void时才可以使用return直接返回中止。</span></span><br><span class="line">	}</span><br><span class="line">	Console.WriteLine(a + b);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">speak</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span>(a+b&gt;<span class="number">10</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">int</span> c = a+b;</span><br><span class="line">		<span class="built_in">string</span> str = <span class="string">"和为："</span> + c;</span><br><span class="line">		<span class="keyword">return</span> str; <span class="comment">//注意：当返回类型为void时才可以使用return直接返回中止。</span></span><br><span class="line">	}</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="ref和out（用于函数形参和实参的传递）"><a href="#ref和out（用于函数形参和实参的传递）" class="headerlink" title="ref和out（用于函数形参和实参的传递）"></a>ref和out（用于函数形参和实参的传递）</h3><p><strong>作用：</strong></p>
<ul>
<li>当传入函数参数时，如果为值类型，在函数内修改形参不会改变实参。</li>
<li>若使用 <code>ref</code>​ 或 <code>out</code>​，则<strong>函数内的修改会影响函数外的实参</strong>。</li>
</ul>
<p><strong>语法：</strong>  在传入参数前加<code>ref</code>​或<code>out</code>​</p>
<p><strong>例子：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeVertex</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> a, <span class="keyword">ref</span> <span class="built_in">int</span> b</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">int</span> c;</span><br><span class="line">    c = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">int</span> b = <span class="number">4</span>;</span><br><span class="line">    ChangeVertex(<span class="keyword">ref</span> a, <span class="keyword">ref</span> b);</span><br><span class="line">    Console.WriteLine(a + <span class="string">" "</span> + b);  <span class="comment">// 输出：4 3</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>Ref和out的区别</strong></p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>​<code>ref</code>​</th>
<th>​<code>out</code>​</th>
</tr>
</thead>
<tbody><tr>
<td>调用前是否必须赋值</td>
<td>✅ 必须在调用前初始化</td>
<td>❌ 不需要在调用前初始化</td>
</tr>
<tr>
<td>方法内是否必须赋值</td>
<td>❌ 不强制赋值</td>
<td>✅ 方法内部<strong>必须赋值</strong>，否则编译错误</td>
</tr>
<tr>
<td>场景</td>
<td>双向传值</td>
<td>单向输出结果</td>
</tr>
</tbody></table>
<p>‍</p>
<p>​<strong>​<code>Out</code>​</strong>​<strong>示例：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeVertexO</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> a, <span class="keyword">out</span> <span class="built_in">int</span> b</span>)</span></span><br><span class="line">{</span><br><span class="line">    a = <span class="number">5</span>;  <span class="comment">// 内部必须赋值</span></span><br><span class="line">    b = <span class="number">6</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">int</span> a;</span><br><span class="line">    <span class="built_in">int</span> b;</span><br><span class="line">    ChangeVertexO(<span class="keyword">out</span> a, <span class="keyword">out</span> b);</span><br><span class="line">    Console.WriteLine(a + <span class="string">" "</span> + b);  <span class="comment">// 输出：5 6</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>​<strong>​<code>ref</code>​</strong>​ <strong>示例</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ChangeVertex</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> a, <span class="keyword">ref</span> <span class="built_in">int</span> b</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">int</span> c;</span><br><span class="line">    c = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">int</span> b = <span class="number">4</span>;</span><br><span class="line">    ChangeVertex(<span class="keyword">ref</span> a, <span class="keyword">ref</span> b);</span><br><span class="line">    Console.WriteLine(a + <span class="string">" "</span> + b);  <span class="comment">// 输出：4 3</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="变长和参数默认值："><a href="#变长和参数默认值：" class="headerlink" title="变长和参数默认值："></a>变长和参数默认值：</h3><h4 id="变长参数（可变参数）"><a href="#变长参数（可变参数）" class="headerlink" title="变长参数（可变参数）"></a>变长参数（可变参数）</h4><ul>
<li><strong>关键字：</strong>  <code>params</code>​</li>
<li><strong>语法：</strong></li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> 返回类型 函数名(<span class="keyword">params</span> 类型[] 数组名)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p><strong>注意事项：</strong></p>
<ul>
<li>​<code>params</code>​ 修饰的参数<strong>必须是最后一个参数</strong>。</li>
<li>它前面<strong>可以有其他参数</strong>，但<strong>后面不能再有其他参数</strong>，否则编译报错。</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Text</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[] a</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; a.Length; i++)</span><br><span class="line">    {</span><br><span class="line">        sum += a[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>调用示例：</strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> result = Text(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 输出：10</span></span><br></pre></td></tr></tbody></table></figure>

<p>‍</p>
<h4 id="参数默认值（可选参数）"><a href="#参数默认值（可选参数）" class="headerlink" title="参数默认值（可选参数）"></a>参数默认值（可选参数）</h4><p><strong>什么是参数默认值？</strong></p>
<p>当函数参数设置了默认值，即可在调用函数时<strong>选择是否传入对应实参</strong>，如果不传入，则会使用默认值。</p>
<p><strong>示例代码：</strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">string</span> str = <span class="string">"我什么也不想说"</span></span>) <span class="comment">// 设置默认值</span></span></span><br><span class="line">{</span><br><span class="line">    Console.WriteLine(str);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>使用方式：</strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">Speak();                      <span class="comment">// 输出：我什么也不想说</span></span><br><span class="line">Speak(<span class="string">"那我就说几句"</span>);        <span class="comment">// 输出：那我就说几句</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li><strong>可选参数必须放在参数列表的最前面。</strong></li>
<li>因为如果默认值参数在前，调用函数时会发生<strong>实参与形参匹配不明确的问题</strong>。</li>
</ul>
<p><strong>示例代码：</strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//正确示例</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Text</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b =<span class="number">1</span>,<span class="built_in">int</span> c=<span class="number">5</span>;<span class="built_in">int</span> d=<span class="number">6</span></span>)	<span class="comment">//可选参数放后面</span></span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//错误示例：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Text</span>(<span class="params"><span class="built_in">int</span> a =<span class="number">1</span>, <span class="built_in">int</span> b = <span class="number">2</span>, <span class="built_in">int</span> c</span>)	<span class="comment">//未将可选参数都放后面</span></span></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>函数重载：</p>
<ul>
<li><p>重载允许在同一作用域内定义多个同名函数。</p>
</li>
<li><p>具有相同函数名的函数，但是参数的类型、个数或者顺序不同的函数，叫做函数重载。</p>
</li>
<li><p>返回值与函数重载无关，即返回值可相同可不同，但是传入参数的类型、个数或者顺序要有一个不同。</p>
</li>
<li><p>函数重载注意用于处理不同参数同一类型的逻辑处理</p>
</li>
</ul>
<p>举例：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//这三个函数的函数名相同，但是参数的个数和顺序或者类型不同，所以这三个函数重载。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> a,<span class="built_in">int</span> b, <span class="built_in">int</span> c=<span class="number">5</span>,<span class="built_in">int</span> d=<span class="number">3</span></span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> a + b + c + d;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">float</span> <span class="title">Test</span>(<span class="params"><span class="built_in">float</span> a,<span class="built_in">int</span> b</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">float</span> c = a + b;</span><br><span class="line">	<span class="keyword">return</span> c;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">float</span> <span class="title">Test</span>(<span class="params"><span class="built_in">float</span> a, <span class="built_in">float</span> b</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//params（变长参数）也可用于函数重载</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CompareVertex</span>(<span class="params"><span class="keyword">params</span> <span class="built_in">int</span>[] a</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">int</span> index=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; a.Length; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span>(a[i]&gt;a[index])</span><br><span class="line">		{</span><br><span class="line">			index = i;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> a[index];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">float</span> <span class="title">CompareVertex</span>(<span class="params"><span class="built_in">float</span> a, <span class="built_in">float</span> b</span>)</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">if</span> (a &gt; b)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> a;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>递归函数：就是让函数自己调用自己。</p>
<p>条件：一个正确的递归函数，必须有结束条件，这个条件必须是根据循环的次数改变而改变的，否则就会陷入无限循环。</p>
<p><strong>普通举例：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test_DiGui</span>(<span class="params"><span class="built_in">int</span> a</span>)</span></span><br><span class="line">{</span><br><span class="line">	Console.WriteLine(<span class="string">"二哈！！！过来"</span>);</span><br><span class="line">	<span class="keyword">if</span> (a &gt; <span class="number">1</span>)</span><br><span class="line">		{</span><br><span class="line">			Test_DiGui(a - <span class="number">1</span>); <span class="comment">//递归函数自我调用</span></span><br><span class="line">		}</span><br><span class="line">} <span class="comment">//打印a次字符串</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>遍历目录示例：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">string</span> rootPath = <span class="string">@"C:\Example\MyFolder"</span>; <span class="comment">// 设置你要遍历的根目录</span></span><br><span class="line">        TraverseDirectory(rootPath);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">TraverseDirectory</span>(<span class="params"><span class="built_in">string</span> path</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 打印当前目录路径</span></span><br><span class="line">        Console.WriteLine(<span class="string">"目录："</span> + path);</span><br><span class="line">        <span class="comment">// 遍历文件</span></span><br><span class="line">        <span class="built_in">string</span>[] files = Directory.GetFiles(path);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> <span class="keyword">file</span> <span class="keyword">in</span> files)</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(<span class="string">"文件："</span> + Path.GetFileName(<span class="keyword">file</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 遍历子目录（并递归调用）</span></span><br><span class="line">        <span class="built_in">string</span>[] directories = Directory.GetDirectories(path);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> dir <span class="keyword">in</span> directories)</span><br><span class="line">        {</span><br><span class="line">            TraverseDirectory(dir); <span class="comment">// 递归调用</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="C-结构体"><a href="#C-结构体" class="headerlink" title="C#结构体"></a>C#结构体</h1><p>结构体是一种<code>自定义的变量类型</code>​，他是<code>数据和函数的集合</code>​，在结构体中可以申明各种变量和方法（函数）</p>
<p><strong>作用：</strong> 用来表现存在关系的数据集合，比如结构体表现学生、怪物、动物等</p>
<p><strong>基本语法：</strong></p>
<ul>
<li>结构体一般写在<code>namespace</code>​空间里，且里面的变量和函数默认为<code>private</code>​类型</li>
<li>如果想要外部调用，要在前加<code>public</code>​。函数在结构体里不用加<code>static</code>​。结构体里还可以写构造函数。</li>
</ul>
<p>}</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">Struct 结构体名</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> age；</span><br><span class="line">	<span class="comment">//…… ……</span></span><br><span class="line">	<span class="keyword">void</span> 函数名（）</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//…… ……</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>举例：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">bool</span> sex;</span><br><span class="line">	<span class="built_in">enum</span> E_sex</span><br><span class="line">	{</span><br><span class="line">		男生,</span><br><span class="line">		女生</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> name,<span class="built_in">int</span> age,<span class="built_in">bool</span> sex</span>) <span class="comment">//构造函数，其中this表示自己的参数</span></span></span><br><span class="line">	{ <span class="comment">//因为传入参数名称和外部变量名称相 同，所以用this来表示这个变量为 结构体自己的参数。</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.sex = sex;</span><br><span class="line">	}</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span>()</span></span><br><span class="line">	{</span><br><span class="line">		Console.WriteLine(<span class="string">"我是{0},我今年{1}岁，我是{2}"</span>,name,age,(E_sex) Convert.ToInt32(sex));</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">{</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//结构体初始化方法一:</span></span><br><span class="line">		Student s1;</span><br><span class="line">		s1.age = <span class="number">18</span>;</span><br><span class="line">		s1.name = <span class="string">"林语馨"</span>;</span><br><span class="line">		s1.sex = <span class="literal">true</span>;</span><br><span class="line">		s1.speak();</span><br><span class="line">		<span class="comment">//方法二:</span></span><br><span class="line">		Student s2 = <span class="keyword">new</span> Student(<span class="string">"林雨馨"</span>,<span class="number">18</span>,<span class="literal">true</span>); <span class="comment">//对结构体内的变量统一赋值。</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubble Sort）是一种简单的排序算法，它通过重复地遍历待排序的列表，比较相邻的元素并交换它们的位置来实现排序。该算法的名称来源于较小的元素会像”气泡”一样逐渐”浮”到列表的顶端。</p>
<h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li><strong>比较相邻元素</strong>：从列表的第一个元素开始，比较相邻的两个元素。</li>
<li><strong>交换位置</strong>：如果前一个元素比后一个元素大，则交换它们的位置。</li>
<li><strong>重复遍历</strong>：对列表中的每一对相邻元素重复上述步骤，直到列表的末尾。这样，最大的元素会被”冒泡”到列表的最后。</li>
<li><strong>缩小范围</strong>：忽略已经排序好的最后一个元素，重复上述步骤，直到整个列表排序完成。</li>
</ol>
<h3 id="原理说明："><a href="#原理说明：" class="headerlink" title="原理说明："></a>原理说明：</h3><p>设数组元素个数为 <code>n</code>​，从数组下标为 0 的元素开始，每次<strong>两两比较相邻元素</strong>，把较大的（或较小的）元素“冒泡”移动到后面。</p>
<ul>
<li><strong>第一轮比较 n-1 次</strong></li>
<li><strong>第二轮比较 n-2 次</strong></li>
<li>……</li>
<li><strong>第 n-1 轮比较 1 次</strong></li>
</ul>
<p>在第 <code>x</code>​ 轮中，后面的元素已经排好，无需再次比较，因此每轮的比较次数会逐渐减少。</p>
<table>
<thead>
<tr>
<th>第几轮（x）</th>
<th>比较次数（m-x）</th>
</tr>
</thead>
<tbody><tr>
<td>第 1 轮</td>
<td>m - 1</td>
</tr>
<tr>
<td>第 2 轮</td>
<td>m - 2</td>
</tr>
<tr>
<td>第 3 轮</td>
<td>m - 3</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>第 n 轮</td>
<td>m - n = 0</td>
</tr>
</tbody></table>
<p>说明：<strong>m</strong>  <strong>=</strong>  <strong>数组长度</strong></p>
<h3 id="循环结构说明："><a href="#循环结构说明：" class="headerlink" title="循环结构说明："></a>循环结构说明：</h3><p>冒泡排序中包含两层 <code>for</code>​ 循环：</p>
<h4 id="外层循环：控制“轮数”"><a href="#外层循环：控制“轮数”" class="headerlink" title="外层循环：控制“轮数”"></a>外层循环：控制“轮数”</h4><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length - <span class="number">1</span>; i++)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>从第 0 轮开始</li>
<li>共进行 <code>n - 1</code>​ 轮</li>
</ul>
<h4 id="内层循环：每轮中的“两两比较”"><a href="#内层循环：每轮中的“两两比较”" class="headerlink" title="内层循环：每轮中的“两两比较”"></a>内层循环：每轮中的“两两比较”</h4><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; arr.Length - <span class="number">1</span> - i; j++)</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>比较相邻两个元素 <code>arr[j]</code>​ 和 <code>arr[j+1]</code>​</li>
<li>若顺序不对则交换</li>
</ul>
<h3 id="C-实现冒泡排序："><a href="#C-实现冒泡排序：" class="headerlink" title="C#实现冒泡排序："></a>C#<strong>实现冒泡排序：</strong></h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//降序排序（从大到小）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length<span class="number">-1</span>; i++)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; arr.Length - <span class="number">1</span> - i; j++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (arr[j + <span class="number">1</span>] &gt; arr[j])</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">int</span> temp;</span><br><span class="line">			temp = arr[j];</span><br><span class="line">			arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">			arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//升序排序（从小到大）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.Length<span class="number">-1</span>; i++)</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; arr.Length - <span class="number">1</span> - i; j++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (arr[j + <span class="number">1</span>] &lt; arr[j])</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">int</span> temp;</span><br><span class="line">			temp = arr[j];</span><br><span class="line">			arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">			arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li>实现简单，代码易于理解。</li>
<li>原地排序，不需要额外的存储空间。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>效率较低，尤其是对于大规模数据集。</li>
<li>不适合处理几乎已经有序的列表，因为仍然需要进行多次遍历。</li>
</ul>
</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="什么是选择排序"><a href="#什么是选择排序" class="headerlink" title="什么是选择排序"></a>什么是选择排序</h3><p>选择排序基本思想是每次从待排序的数据中选择最小（或最大）的元素，放到已排序序列的末尾，直到全部数据排序完成。</p>
<h3 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol>
<li><strong>初始化</strong>：将列表分为已排序部分和未排序部分。初始时，已排序部分为空，未排序部分为整个列表。</li>
<li><strong>查找最小值</strong>：在未排序部分中查找最小的元素。</li>
<li><strong>交换位置</strong>：将找到的最小元素与未排序部分的第一个元素交换位置。</li>
<li><strong>更新范围</strong>：将未排序部分的起始位置向后移动一位，扩大已排序部分的范围。</li>
<li><strong>重复步骤</strong>：重复上述步骤，直到未排序部分为空，列表完全有序。</li>
</ol>
<p>‍</p>
<p>设数组长度为 <code>n</code>​，排序过程如下：</p>
<ol>
<li>第1轮：从下标 <code>0~n-1</code>​ 中找到最小值，放到第0位；</li>
<li>第2轮：从下标 <code>1~n-1</code>​ 中找到最小值，放到第1位；</li>
<li>…</li>
<li>第n-1轮：只剩一个元素，已自动排好。</li>
</ol>
<p>‍</p>
<p>假设原数组为：[<strong>64, 25, 12, 22, 11</strong>]</p>
<table>
<thead>
<tr>
<th>轮次</th>
<th>当前数组状态</th>
<th>操作说明</th>
</tr>
</thead>
<tbody><tr>
<td>第1轮</td>
<td>[64, 25, 12, 22,<strong>11</strong>]</td>
<td>找到最小值11，和64交换</td>
</tr>
<tr>
<td></td>
<td>[11, 25, 12, 22, 64]</td>
<td></td>
</tr>
<tr>
<td>第2轮</td>
<td>[11, 25,<strong>12</strong>, 22, 64]</td>
<td>找到12，和25交换</td>
</tr>
<tr>
<td></td>
<td>[11, 12, 25, 22, 64]</td>
<td></td>
</tr>
<tr>
<td>第3轮</td>
<td>[11, 12, 25,<strong>22</strong>, 64]</td>
<td>找到22，和25交换</td>
</tr>
<tr>
<td></td>
<td>[11, 12, 22, 25, 64]</td>
<td></td>
</tr>
<tr>
<td>第4轮</td>
<td>[11, 12, 22, 25, 64]</td>
<td>已排好</td>
</tr>
</tbody></table>
<p>‍</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//升序（从小到大）</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectionSort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">int</span> n = arr.Length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 假设当前位置 i 是最小值索引</span></span><br><span class="line">            <span class="built_in">int</span> minIndex = i;</span><br><span class="line">            <span class="comment">// 遍历后面的元素，寻找更小值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[minIndex])</span><br><span class="line">                {</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 如果找到更小值，进行交换</span></span><br><span class="line">            <span class="keyword">if</span> (minIndex != i)</span><br><span class="line">            {</span><br><span class="line">                <span class="built_in">int</span> temp = arr[i];</span><br><span class="line">                arr[i] = arr[minIndex];</span><br><span class="line">                arr[minIndex] = temp;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">int</span>[] data = { <span class="number">64</span>, <span class="number">25</span>, <span class="number">12</span>, <span class="number">22</span>, <span class="number">11</span> };</span><br><span class="line">        Console.WriteLine(<span class="string">"原始数组： "</span> + <span class="built_in">string</span>.Join(<span class="string">", "</span>, data));</span><br><span class="line">        SelectionSort(data);</span><br><span class="line">        Console.WriteLine(<span class="string">"排序后：   "</span> + <span class="built_in">string</span>.Join(<span class="string">", "</span>, data));</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>‍</p>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li><p><strong>优点</strong>：</p>
<ul>
<li>实现简单，代码易于理解。</li>
<li>原地排序，不需要额外的存储空间。</li>
<li>对于小规模数据集，性能尚可接受。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>时间复杂度较高，不适合大规模数据集。</li>
<li>不稳定排序算法（如果存在相同元素，可能会改变它们的相对顺序）。</li>
</ul>
</li>
</ul>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>面向对象关键知识：</p>
<ul>
<li>类（class）</li>
</ul>
<p>面向对象三大特征</p>
<ul>
<li>​<code>封装：</code>​用程序语言来形容对象</li>
<li>​<code>继承：</code>​复用封装对象的代码：儿子继承父亲，复用现成代码。</li>
<li>​<code>多态：</code>​同样行为的不同表现，儿子继承父亲但是有不同的行为表现。</li>
</ul>
<p>面向对象七大原则</p>
<ul>
<li>开闭原则</li>
<li>依赖倒转原则</li>
<li>里氏替换原则</li>
<li>第一职责原则</li>
<li>接口隔离原则</li>
<li>合成复用原则</li>
<li>迪米特法则</li>
</ul>
<h2 id="类和（类）对象"><a href="#类和（类）对象" class="headerlink" title="类和（类）对象"></a>类和（类）对象</h2><h3 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h3><ul>
<li><p><strong>类的定义：</strong> 具有相同特性和行为的对象组成的集合就是类。<strong>类是对象的抽象，对象是类的具体实例。</strong> 比如你要买一辆车，车有品牌，排量，颜色，款式，这时车就是类，而当你看中了一个品牌，排列，颜色，款式确定的一款车时，这个车就是类的实例。</p>
</li>
<li><p>类是一个引用类型；</p>
</li>
<li><p>类的声明一般声明在<code>namespace</code>​空间中，而不是定义在 <code>class Program</code>​ 里。在类中申明类是类的内部类。</p>
</li>
</ul>
<h3 id="类的声明"><a href="#类的声明" class="headerlink" title="类的声明"></a>类的声明</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">访问修饰符 Class 类名</span><br><span class="line">{</span><br><span class="line"><span class="comment">//特征——成员变量</span></span><br><span class="line"><span class="comment">//行为——成员方法</span></span><br><span class="line"><span class="comment">//保护特征——成员属性</span></span><br><span class="line"><span class="comment">//构造函数和析构函数</span></span><br><span class="line"><span class="comment">//索引器</span></span><br><span class="line"><span class="comment">//运算符重载</span></span><br><span class="line"><span class="comment">//静态成员</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="类声明实例"><a href="#类声明实例" class="headerlink" title="类声明实例"></a>类声明实例</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">Class Person <span class="comment">//人类</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="built_in">int</span> age;</span><br><span class="line">	<span class="built_in">int</span> sex;	<span class="comment">//假设0为女,1为男</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Class Machine <span class="comment">//机器类</span></span><br><span class="line">{</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="（类）对象"><a href="#（类）对象" class="headerlink" title="（类）对象"></a><strong>（类）对象</strong></h3><ul>
<li><p>类的申明相当于申明了一个自定义变量类型。</p>
</li>
<li><p>（类）对象的申明是相当于申明了一个指定类的对象。</p>
</li>
<li><p>类创建对象的过程，一般称为实例化对象。</p>
</li>
<li><p>（类）对象是引用类型。</p>
</li>
<li><p>引用类型是在栈上申请了一个内存，存放地址，new后在堆上申请空间，将地址存在栈上。</p>
</li>
</ul>
<h3 id="对象的申明："><a href="#对象的申明：" class="headerlink" title="对象的申明："></a><strong>对象的申明：</strong></h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">类名 变量名;				<span class="comment">//声明变量但不初始化。类成员的引用类型变量如果没初始化，会自动是 null。	</span></span><br><span class="line">类名 变量名=<span class="literal">null</span>;			<span class="comment">//声明变量，并显式赋值为 null。</span></span><br><span class="line">类名 变量名=<span class="keyword">new</span> 类名();	<span class="comment">//声明变量并创建一个新的对象实例。</span></span><br></pre></td></tr></tbody></table></figure>

<p>三种声明方法对比</p>
<table>
<thead>
<tr>
<th>写法</th>
<th>是否赋值</th>
<th>是否可以使用变量</th>
<th>是否分配内存</th>
</tr>
</thead>
<tbody><tr>
<td>​<code>Person p;</code>​</td>
<td>❌</td>
<td>❌ 编译错误</td>
<td>❌</td>
</tr>
<tr>
<td>​<code>Person p = null;</code>​</td>
<td>✅ null</td>
<td>❌ 运行时错误</td>
<td>❌</td>
</tr>
<tr>
<td>​<code>Person p = new Person();</code>​</td>
<td>✅ 实例</td>
<td>✅ 正常使用</td>
<td>✅</td>
</tr>
</tbody></table>
<p>实践建议</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐写法</th>
</tr>
</thead>
<tbody><tr>
<td>延迟初始化</td>
<td>​<code>Person p = null;</code>​</td>
</tr>
<tr>
<td>立即使用</td>
<td>​<code>Person p = new Person();</code>​</td>
</tr>
<tr>
<td>先声明，后赋值（临时变量）</td>
<td>​<code>Person p;</code>​，但马上赋值</td>
</tr>
</tbody></table>
<h3 id="实例化对象："><a href="#实例化对象：" class="headerlink" title="实例化对象："></a><strong>实例化对象：</strong></h3><p><strong>假设申明了一个Person类。</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">{</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="built_in">int</span> age;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line">Person P1;</span><br><span class="line">P1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">Person P2=<span class="literal">null</span>;</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">Person P3=<span class="keyword">new</span> Person();</span><br></pre></td></tr></tbody></table></figure>

<h2 id="成员变量和访问修饰符"><a href="#成员变量和访问修饰符" class="headerlink" title="成员变量和访问修饰符"></a>成员变量和访问修饰符</h2><h3 id="C-访问修饰符："><a href="#C-访问修饰符：" class="headerlink" title="C#访问修饰符："></a>C#访问修饰符：</h3><table>
<thead>
<tr>
<th>修饰符</th>
<th>可访问范围</th>
<th>应用场景常用位置</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>​<code>public</code>​</td>
<td>任何地方都可访问</td>
<td>类、成员、属性、方法</td>
<td>​<code>public class Person { public string Name; }</code>​</td>
</tr>
<tr>
<td>​<code>private</code>​</td>
<td>仅在<strong>当前类内部</strong>可访问</td>
<td>类内部成员、字段</td>
<td>​<code>private int age;</code>​</td>
</tr>
<tr>
<td>​<code>protected</code>​</td>
<td><strong>当前类</strong>及其<strong>派生类（子类）</strong> 中可访问</td>
<td>继承场景的成员字段</td>
<td>​<code>protected string password;</code>​</td>
</tr>
<tr>
<td>​<code>internal</code>​</td>
<td>当前项目（程序集）中可访问</td>
<td>库组件、模块间通讯</td>
<td>​<code>internal class Utils { ... }</code>​</td>
</tr>
<tr>
<td>​<code>protected internal</code>​</td>
<td>当前<strong>程序集</strong>或子类（无论在不在当前程序集）中可访问</td>
<td>跨项目但需要继承支持时使用</td>
<td>​<code>protected internal void Log() {}</code>​</td>
</tr>
</tbody></table>
<h3 id="类里的成员变量："><a href="#类里的成员变量：" class="headerlink" title="类里的成员变量："></a>类里的成员变量：</h3><p>‍</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//注：成员变量声明后可赋值，与结构体不同。</span></span><br><span class="line">访问修饰符 Class 类名</span><br><span class="line">{</span><br><span class="line"><span class="comment">//特征——成员变量</span></span><br><span class="line"><span class="comment">//行为——成员方法</span></span><br><span class="line"><span class="comment">//保护特征——成员属性</span></span><br><span class="line"><span class="comment">//构造函数和析构函数</span></span><br><span class="line"><span class="comment">//索引器</span></span><br><span class="line"><span class="comment">//运算符重载</span></span><br><span class="line"><span class="comment">//静态成员</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>‍</p>
<p>类里面可以声明自己类的对象（变量），例如：</p>
<p>‍</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span> Int age;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> Bool sex;</span><br><span class="line"><span class="keyword">public</span> Person girlfriend; 		<span class="comment">//在类中申明类变量，注意不要用new创建实例。</span></span><br><span class="line"><span class="keyword">public</span> Person[] friend=<span class="literal">null</span>;	<span class="comment">//可赋值null，但是不能new；否则循环。</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//实例化一个对象语法： Person p1=new Person();</span></span><br></pre></td></tr></tbody></table></figure>

<p>注：</p>
<ol>
<li>如果在类中对（类）对象进行new（构造成员变量）—— Public Person girlfriend=new Person（）；则会使类进行无限递归，而爆掉内存。</li>
<li>类中的成员变量会有默认值，例如，值类型默认值：int默认值为0；，bool为false等。引用类型都是空（NULL）</li>
<li>看默认值小技巧Console.WriteLine(default(变量))</li>
</ol>
<p>‍</p>
<h2 id="成员方法（函数）："><a href="#成员方法（函数）：" class="headerlink" title="成员方法（函数）："></a>成员方法（函数）：</h2><p><strong>成员方法</strong>（函数），用来表现对象行为，申明在类语句块中，规则和函数申明规则一致，可受访问修饰符影响，</p>
<p><strong>1.成员方法不要加static</strong></p>
<p><strong>2.成员方法必须实例化出对象，再通过对象来使用，相当于该对象执行了某个行为，</strong></p>
<p><strong>3.成员方法受访问修饰符影响</strong></p>
<p><strong>如果成员方法前加staic：</strong></p>
<p>在C#程序中，当你在一个类中将方法声明为静态（static）时，意味着该方法不属于任何特定的实例对象，而是属于整个类本身。这意味着你可以直接通过类名来访问该静态方法，而不需要实例化类对象。</p>
<p>例如Person类中的Eat()方法，如果你将其前缀声明为static，那么就可以通过Person.Eat()的方式直接调用该方法，而不需要先创建Person类的实例。</p>
<p>如果你在代码中定义了一个静态的Eat()方法，它可以直接执行一些与吃饭相关的操作，而不需要依赖于Person类的实例。这样的静态方法可以在不创建实例对象的情况下被调用，使得代码更加简洁和高效。</p>
<p>静态方法只能访问静态成员（如静态字段或其他静态方法），不能访问实例成员（如实例字段或实例方法），因为静态方法没有与特定对象实例相关联。</p>
<p>如果你需要执行某个与类相关，但是不依赖于类的实例对象的操作，那么可以将该操作声明为静态方法。例如，用于计算数字之间的某个关系，或者用于管理一个公共资源池等。</p>
<p><strong>举例</strong>：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">Class Person</span><br><span class="line">{</span><br><span class="line">	Public <span class="built_in">string</span> name；</span><br><span class="line">	Public <span class="built_in">int</span> age；</span><br><span class="line">	<span class="comment">//说话的方法</span></span><br><span class="line">	<span class="function">Public <span class="keyword">void</span> <span class="title">Speak</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line">	{</span><br><span class="line">		Console.WriteLine(“{<span class="number">0</span>}说：{<span class="number">1</span>}”,name,str)</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//判断是否成年的方法</span></span><br><span class="line">	<span class="function">Public <span class="built_in">bool</span> <span class="title">ISAdult</span>()</span></span><br><span class="line">	{</span><br><span class="line">		Return age&gt;=<span class="number">18</span>; <span class="comment">//如果大于等于返回true，否则返回false</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>例2：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">	Person[] friends;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Addfriend</span>(<span class="params">Person friend</span>)</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span>(friends==<span class="literal">null</span>)</span><br><span class="line">		{</span><br><span class="line">			friends = <span class="keyword">new</span> Person[] { friend };</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			Person[] newFriend = <span class="keyword">new</span> Person[friends.Length + <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; friends.Length; i++)</span><br><span class="line">			{</span><br><span class="line">				newFriend[i] = friends[i];</span><br><span class="line">			}</span><br><span class="line">			friends = newFriend;</span><br><span class="line">		}</span><br><span class="line">		Console.WriteLine(<span class="string">"{0}添加了一个新朋友：{1}"</span>, name,friend.name);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span>{</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SelectionSort</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">	{</span><br><span class="line">		Person p1=<span class="keyword">new</span> Person();</span><br><span class="line">		p1.name = <span class="string">"小可乐"</span>;</span><br><span class="line">		p1.age = <span class="number">18</span>;</span><br><span class="line">		Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">		p2.age = <span class="number">17</span>;</span><br><span class="line">		p2.name = <span class="string">"小辣椒"</span>;</span><br><span class="line">		p1.Addfriend(p2);</span><br><span class="line">		<span class="comment">//运行结果：小可乐添加了一个新朋友：小辣椒</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="构造函数（初始化调用）、析构、垃圾回收"><a href="#构造函数（初始化调用）、析构、垃圾回收" class="headerlink" title="构造函数（初始化调用）、析构、垃圾回收"></a>构造函数（初始化调用）、析构、垃圾回收</h2><h3 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h3><p>‍</p>
<p><strong>构造函数只能在类中声明</strong>，默认有一个0参的（无传入参数）构造函数（用于对变量成员的初始化）。</p>
<p>构造函数用于给类的成员属性进行赋值并初始化一个新的对象。</p>
<p>例如类的实例化：<code> Person p1 = new Person()；</code>​这句的 <code>new Person()</code>​ 就相当于调用了无参的构造函数初始化一个空对象。当在类中重新申明一个构造函数时，默认的0参构造函数就会被回收。</p>
<p>构造函数可以重载，如果想要0参的构造函数，可以手动再次申明。</p>
<p><strong>构造函数申明语法</strong>：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">Class 你的类{</span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="built_in">int</span> count;</span><br><span class="line">	访问修饰符 类名（传入参数）</span><br><span class="line">	{</span><br><span class="line">	</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>构造函数声明示例：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//举例：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">public</span> Person[] friends;</span><br><span class="line"></span><br><span class="line">	<span class="function">Public <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age,<span class="built_in">string</span> name</span>) <span class="comment">//构造函数</span></span></span><br><span class="line">	{</span><br><span class="line">	This.age=age;</span><br><span class="line">	This.name =name;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function">Public <span class="title">Person</span>()<span class="comment">//0参构造函数，两构造函数重载</span></span></span><br><span class="line">	{</span><br><span class="line">	age=<span class="number">0</span>;</span><br><span class="line">	name =””;</span><br><span class="line">	friends=<span class="literal">null</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>构造函数的特殊写法</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Public <span class="title">Perosn</span>(<span class="params">参数</span>)：<span class="title">this</span>(<span class="params">参数</span>)</span>;</span><br><span class="line">{</span><br><span class="line">	<span class="comment">//逻辑</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这种写法的作用是，当调用这个构造函数时，会先调用<code>this（参数）构造函数</code>​，<code>this（参数）</code>​相当于调用<code>public Person （参数）;</code>​</p>
<p>这种构造函数的运行逻辑是</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">public</span> Person[] friends;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span></span><br><span class="line">	{</span><br><span class="line">	name = <span class="string">""</span>;</span><br><span class="line">	age = <span class="number">0</span>;</span><br><span class="line">	friends = <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">//如果在无参构造函数后面加:this(参数)时，由于此构造函数无传入参数，所以无参数传入this（参数）里。</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age</span>):<span class="title">this</span>() <span class="comment">//调用此构造函数时会先调用this()，也就是先调用public Person()构造函数</span></span></span><br><span class="line">	{</span><br><span class="line">	age = <span class="number">18</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age,<span class="built_in">string</span> name</span>):<span class="title">this</span>(<span class="params">age</span>)</span>;</span><br><span class="line">	{</span><br><span class="line">	<span class="comment">//当调用此构造函数时，传入的参数age和name，其中age会被传入this(age)这个函数里，然后调用public Person(int age)这个构造函数。</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="析构"><a href="#析构" class="headerlink" title="析构"></a>析构</h3><p><strong>当引用类型的堆内存被回收时，会调用该函数</strong></p>
<p>C#存在自动垃圾回收机制GC，所以不怎么用析构函数。</p>
<p>只做了解即可。</p>
<p>如果想要在GC回收时执行一些自定义逻辑可以写里面。</p>
<p><strong>基本语法：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">~类名（）</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>举例</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span> </span><br><span class="line">{</span><br><span class="line">	<span class="comment">//……</span></span><br><span class="line">}</span><br><span class="line">~Person()</span><br><span class="line"> {</span><br><span class="line"><span class="comment">//逻辑</span></span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>

<h3 id="垃圾回收机制（Garbage-collector）"><a href="#垃圾回收机制（Garbage-collector）" class="headerlink" title="垃圾回收机制（Garbage collector）"></a>垃圾回收机制（Garbage collector）</h3><p><strong>GC只负责堆里面的内存的垃圾回收。</strong></p>
<p>值类型在栈中分配的内存，他们有自己的生命周期，会自动分配和释放。</p>
<p>Heap：堆</p>
<p>Stack：栈</p>
<p>垃圾回收主要算法：</p>
<ol>
<li>标记-清除算法</li>
<li>压缩算法</li>
<li>分代清除算法</li>
</ol>
<p>手动调用GC：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">GC.collect(); <span class="comment">//手动触发垃圾回收|在Unity里面一般都是在加载场景（进度条）时使用，不会频繁调用</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="成员属性（包裹成员变量）"><a href="#成员属性（包裹成员变量）" class="headerlink" title="成员属性（包裹成员变量）"></a>成员属性（包裹成员变量）</h2><p><strong>基本概念：</strong></p>
<ol>
<li>用于保护成员变量</li>
<li>为成员属性的获取和赋值添加逻辑处理</li>
<li>解决3p的局限性（private——内部访问、public——内外、protected——内部和子类）</li>
<li>属性可以让成员变量在外部 只能获取，不能修改，或者只能修改，不能获取</li>
<li>可以在里面执行一些自定义逻辑，比如对数据进行加密和解密</li>
</ol>
<p><strong>语法：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">访问修饰符 属性类型 属性名</span><br><span class="line">{</span><br><span class="line"><span class="keyword">get</span>{</span><br><span class="line">	<span class="comment">//逻辑代码</span></span><br><span class="line">	<span class="comment">//可以进行解密</span></span><br><span class="line">	<span class="keyword">return</span> 属性类型变量</span><br><span class="line">}</span><br><span class="line"><span class="keyword">set</span>{</span><br><span class="line">	<span class="comment">//逻辑代码</span></span><br><span class="line">	<span class="comment">//可以进行加密</span></span><br><span class="line">	<span class="comment">// 类中的变量=value（外部传入值）</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//注意：</span></span><br><span class="line">	<span class="comment">//1.成员属性中get和set可以加访问修饰符</span></span><br><span class="line">	<span class="comment">//2.默认不加 会使用属性申明时的访问权限</span></span><br><span class="line">	<span class="comment">//3.加的访问修饰符要低于属性的访问权限</span></span><br><span class="line">	<span class="comment">//4.不能让get和set的访问权限都低于属性权限</span></span><br><span class="line">	<span class="comment">//5.get和set可以只有一个，另一个不写</span></span><br><span class="line">	<span class="comment">//6.成员属性对应一个成员变量，成员属性的名称一般为成员变量名称的大写</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>申明举例：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//在自定义类中声明使用成员属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">{	</span><br><span class="line">	<span class="comment">//成员变量name</span></span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">	<span class="comment">//成员属性Name</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">get</span> {<span class="keyword">return</span> name;}		<span class="comment">//返回成员变量name的值。</span></span><br><span class="line">		<span class="keyword">set</span> {name=<span class="keyword">value</span>; }  	<span class="comment">//将value值传入name变量。value 关键字，用于表示外部传入的量。</span></span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//成员属性Age</span></span><br><span class="line">	Public <span class="built_in">int</span> Age</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">get</span>{<span class="keyword">return</span> age+<span class="number">5</span>；}	<span class="comment">//get为私有属性，Age属性只能外部修改不能外部获取</span></span><br><span class="line">		<span class="keyword">set</span>{age = <span class="keyword">value</span><span class="number">-5</span>；}</span><br><span class="line">	} </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员属性的调用</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">p1.Name = <span class="string">"哇哈啊"</span>;				<span class="comment">// 实际上调用的set语句块</span></span><br><span class="line">Console.WriteLine(p1.Name); 	<span class="comment">//实际上调用的get语句块</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="自动属性"><a href="#自动属性" class="headerlink" title="自动属性"></a>自动属性</h2><p>‍</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//如果类的成员属性没有什么特殊处理，那么可以用自动属性。</span></span><br><span class="line">Public <span class="built_in">float</span> Height <span class="comment">//申明了一个只能获取的Height成员属性</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">get</span>;				<span class="comment">//默认跟随成员属性的访问修饰符</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">set</span>;		<span class="comment">//外部获得不能外部修改</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//另一种写法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> str { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//相当于以下代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">string</span> str;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> Str</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">get</span> { <span class="keyword">return</span> str; }</span><br><span class="line">		<span class="keyword">set</span> { str = <span class="keyword">value</span> }</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h2><p><strong>基本概念：</strong> 为类定义一个索引器，让对象可以像数组一样通过索引访问其中元素，使程序看起来更直观，更容易编写。</p>
<h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a><strong>语法：</strong></h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//声明方式一：</span></span><br><span class="line"><span class="comment">//索引器可以有多个传入参数</span></span><br><span class="line">访问修饰符 返回值类型 <span class="keyword">this</span>[参数类型 参数名 ,参数类型 参数名, ……]</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">get</span>{</span><br><span class="line">		<span class="comment">//返回参数值</span></span><br><span class="line">		<span class="comment">// return 对象名[index];</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">set</span>{</span><br><span class="line">		<span class="comment">//设置赋值语句</span></span><br><span class="line">		<span class="comment">//对象名[index] = value;</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//声明方式二：</span></span><br><span class="line"><span class="comment">//索引类型不一定要用int型，也可以用string等其他类型。</span></span><br><span class="line">[访问修饰符] 数据类型 <span class="keyword">this</span>[索引参数类型 index]</span><br><span class="line">{</span><br><span class="line">	<span class="keyword">get</span></span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//返回参数值，往往跟索引的不同返回不同的字段，用选择语句Switch</span></span><br><span class="line">		<span class="comment">// return 对象名[index];</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">set</span></span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//设置赋值语句</span></span><br><span class="line">		<span class="comment">//对象名[index] = value;</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//如何访问索引器：</span></span><br><span class="line"><span class="comment">//像数组那样通过对象名的索引来选择就行 ： 对象名[index] </span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="声明方式一索引器使用举例："><a href="#声明方式一索引器使用举例：" class="headerlink" title="声明方式一索引器使用举例："></a>声明<strong>方式一索引器使用举例：</strong></h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//声明学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span> </span><br><span class="line">{</span><br><span class="line">	<span class="comment">//成员变量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">private</span> Student[] friends;</span><br><span class="line">	<span class="comment">//成员属性</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">string</span> GetName </span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">get</span> { <span class="keyword">return</span> name; }</span><br><span class="line">		<span class="keyword">set</span> { name = <span class="keyword">value</span>; }</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//成员属性</span></span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> GetAge </span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">get</span> { <span class="keyword">return</span> age; }</span><br><span class="line">		<span class="keyword">set</span> { age = <span class="keyword">value</span>; }</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//索引器</span></span><br><span class="line">	<span class="keyword">public</span> Student <span class="keyword">this</span>[<span class="built_in">int</span> index] </span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">set</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span>(friends==<span class="literal">null</span>)</span><br><span class="line">				{</span><br><span class="line">				friends = <span class="keyword">new</span> Student[] { <span class="keyword">value</span> };</span><br><span class="line">				}</span><br><span class="line">			friends[index] = <span class="keyword">value</span>;</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">get</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span>(friends==<span class="literal">null</span>||friends.Length<span class="number">-1</span>&lt;index||index&lt;<span class="number">0</span>)</span><br><span class="line">				{</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">				}</span><br><span class="line">			<span class="keyword">return</span> friends[index];</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//成员方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Init</span>(<span class="params">Student s,<span class="built_in">int</span> age,<span class="built_in">string</span> name</span>)</span> </span><br><span class="line">	{</span><br><span class="line">		s.GetAge = age;</span><br><span class="line">		s.GetName = name;</span><br><span class="line">		Console.WriteLine(s.GetName);</span><br><span class="line">		Console.WriteLine(s.GetAge);</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//构造函数重载</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> age,<span class="built_in">string</span> name</span>)</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//构造函数</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span>()</span></span><br><span class="line">	{</span><br><span class="line">		age = <span class="number">0</span>;</span><br><span class="line">		name = <span class="string">""</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">//主程序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">{</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">		{</span><br><span class="line">			Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">			s1.Init(s1, <span class="number">18</span>, <span class="string">"老黄"</span>);</span><br><span class="line">			<span class="comment">//索引器测试</span></span><br><span class="line">			Console.WriteLine(<span class="string">"----------------------"</span>);</span><br><span class="line">			s1[<span class="number">0</span>] = <span class="keyword">new</span> Student(<span class="number">18</span>, <span class="string">"老黄的朋友[0]"</span>); <span class="comment">//通过索引器访问s1的friends[]</span></span><br><span class="line">			Student s2 = s1[<span class="number">0</span>]; <span class="comment">//实例化一个student s2，将刚生成的朋友放在s2</span></span><br><span class="line">				Console.WriteLine(s2.GetName + <span class="string">" "</span> + s2.GetAge + <span class="string">"岁了"</span>); <span class="comment">//检查s2是否是生成的朋友</span></span><br><span class="line">		}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>‍</p>
<h3 id="声明方式二索引器举例："><a href="#声明方式二索引器举例：" class="headerlink" title="声明方式二索引器举例："></a>声明方式二索引器<strong>举例：</strong></h3><p>‍</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">string</span> sex;</span><br><span class="line">	<span class="keyword">private</span> <span class="built_in">string</span> tel;</span><br><span class="line"><span class="comment">//索引器</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index]<span class="comment">//【访问修饰符】 数据类型 this【索引器类型 index】 语法格式</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">get</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">switch</span> (index)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//由于return就有返回功能和结束功能所以这里的break可以省略因为写了运行不到这句代码</span></span><br><span class="line">			<span class="keyword">return</span> name;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">return</span> sex;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			<span class="keyword">return</span> tel;</span><br><span class="line">			<span class="literal">default</span>:</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="string">"index"</span>);<span class="comment">//抛出异常</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">set</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">switch</span> (index)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//这里必须要有break结束语句，因为每个case的功能语句都是赋值且没有结束语句所以这里需要break</span></span><br><span class="line">			name = <span class="keyword">value</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			sex = <span class="keyword">value</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			tel = <span class="keyword">value</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="literal">default</span>:</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="string">"index"</span>);<span class="comment">//抛出异常</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line">	<span class="comment">//成员方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">	{</span><br><span class="line">	<span class="comment">//this[] this表示的是索引器，this[]表示访问向对应的字段。</span></span><br><span class="line">	Console.WriteLine(<span class="string">"我叫{0}，我是{1}生，我的电话是{2}"</span>, <span class="keyword">this</span>[<span class="number">1</span>], <span class="keyword">this</span>[<span class="number">2</span>], <span class="keyword">this</span>[<span class="number">3</span>]);</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//主程序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">{</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">	{</span><br><span class="line">		Student stu = <span class="keyword">new</span> Student();<span class="comment">//实例化对象</span></span><br><span class="line">		stu[<span class="number">1</span>] = <span class="string">"xxx"</span>;<span class="comment">//给索引器以数组的方式赋值</span></span><br><span class="line">		stu[<span class="number">2</span>] = <span class="string">"男"</span>;</span><br><span class="line">		stu[<span class="number">3</span>] = <span class="string">"13122022202"</span>;</span><br><span class="line">		stu.Speak();</span><br><span class="line">		Console.ReadKey();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h2><p>被 <code>static</code>​ 修饰的成员，叫做静态成员。静态成员是属于类的，通过类名直接访问。</p>
<ul>
<li>当类第一次被访问时，类下的所有静态成员就会被创建在内存中。</li>
<li>静态成员既不在栈中也不在堆中，而是创建在 <strong>静态存储区</strong>。</li>
<li>静态成员 <strong>只创建一次</strong>，直到程序结束前都不会被销毁。</li>
<li>静态成员函数 <strong>不能访问非静态成员</strong>。</li>
<li>静态成员 <strong>可以访问其他静态成员或函数</strong>。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 静态成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 访问静态成员：通过类名</span></span><br><span class="line">        <span class="built_in">int</span> age = Person.Age;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问实例成员：通过对象</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.Name = <span class="string">"Jack"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="const-和-static-的区别"><a href="#const-和-static-的区别" class="headerlink" title="const 和 static 的区别"></a>const 和 static 的区别</h3><p><strong>相同点</strong>：</p>
<ul>
<li>都可以通过类名访问。</li>
</ul>
<p><strong>不同点</strong>：</p>
<ol>
<li>​<code>const</code>​ 必须初始化，且不可修改；<code>static</code>​ 没有此限制。</li>
<li>​<code>const</code>​ 只能修饰变量；<code>static</code>​ 可以修饰变量、方法、类、构造函数等。</li>
<li>​<code>const</code>​ 必须写在变量声明前面；<code>static</code>​ 没有此限制，通常可配合访问修饰符使用。</li>
</ol>
<hr>
<h3 id="静态成员实现单例模式（不安全示例）"><a href="#静态成员实现单例模式（不安全示例）" class="headerlink" title="静态成员实现单例模式（不安全示例）"></a>静态成员实现单例模式（不安全示例）</h3><p>这是一个不推荐在生产环境中使用的单例实现，因为它在多线程场景下不安全。</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> { }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            {</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>问题</strong>：</p>
<ul>
<li>如果两个线程同时执行 <code>if (instance == null)</code>​，就可能创建多个实例，违背了单例的设计初衷。</li>
</ul>
<h3 id="线程安全的单例实现方式"><a href="#线程安全的单例实现方式" class="headerlink" title="线程安全的单例实现方式"></a>线程安全的单例实现方式</h3><h4 id="方法一：使用-lock​-加锁（懒汉式，线程安全）"><a href="#方法一：使用-lock​-加锁（懒汉式，线程安全）" class="headerlink" title="方法一：使用 lock​ 加锁（懒汉式，线程安全）"></a>方法一：使用 <code>lock</code>​ 加锁（懒汉式，线程安全）</h4><p>这是最常见的一种线程安全实现方法：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> lockObj = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> { }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 双重检查锁定（Double-Check Locking）</span></span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">lock</span> (lockObj)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="literal">null</span>)</span><br><span class="line">                    {</span><br><span class="line">                        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>​<code>lock</code>​ 保证线程互斥地访问实例创建逻辑。</li>
<li>“双重检查锁定”是为了避免每次访问都加锁，提高性能。</li>
<li>缺点是代码稍复杂，但性能和安全兼顾。</li>
</ul>
<h4 id="方法二：静态构造函数（饿汉式，线程安全，推荐）"><a href="#方法二：静态构造函数（饿汉式，线程安全，推荐）" class="headerlink" title="方法二：静态构造函数（饿汉式，线程安全，推荐）"></a>方法二：静态构造函数（饿汉式，线程安全，推荐）</h4><p>利用 C# 静态构造函数的特性：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态构造函数（自动线程安全）</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Singleton</span>()</span> { }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> { }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance =&gt; instance;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>静态构造函数只执行一次，CLR 保证其线程安全。</li>
<li>在类被首次使用前就完成实例初始化。</li>
<li>缺点是：实例会 <strong>在程序启动后就创建</strong>，即使永远不会被用到。</li>
</ul>
<h4 id="方法三：使用-Lazy​（懒汉式，线程安全，现代推荐方式）"><a href="#方法三：使用-Lazy​（懒汉式，线程安全，现代推荐方式）" class="headerlink" title="方法三：使用 Lazy<T>​（懒汉式，线程安全，现代推荐方式）"></a>方法三：使用 <code>Lazy&lt;T&gt;</code>​（懒汉式，线程安全，现代推荐方式）</h4><p>C# 提供了 <code>System.Lazy&lt;T&gt;</code>​ 类，专为延迟初始化设计：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">{</span><br><span class="line">	<span class="comment">//用到了lamda表达式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Lazy&lt;Singleton&gt; lazyInstance = <span class="keyword">new</span> Lazy&lt;Singleton&gt;(() =&gt; <span class="keyword">new</span> Singleton());</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span> { }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance =&gt; lazyInstance.Value;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>​<code>Lazy&lt;T&gt;</code>​ 默认采用 <code>LazyThreadSafetyMode.ExecutionAndPublication</code>​，线程安全。</li>
<li>实例在 <strong>首次访问时才创建</strong>，且线程安全，效率高。</li>
<li>是 C# 中实现单例的 <strong>现代推荐写法</strong>。</li>
</ul>
<table>
<thead>
<tr>
<th>实现方式</th>
<th>是否懒加载</th>
<th>是否线程安全</th>
<th>是否推荐</th>
</tr>
</thead>
<tbody><tr>
<td>简单懒汉式</td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>❌ 不推荐</td>
</tr>
<tr>
<td>lock双重检查</td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>✅ 推荐</td>
</tr>
<tr>
<td>静态构造函数</td>
<td>❌ 否</td>
<td>✅ 是</td>
<td>✅ 推荐</td>
</tr>
<tr>
<td>Lazy</td>
<td>✅ 是</td>
<td>✅ 是</td>
<td>✅ 最推荐</td>
</tr>
</tbody></table>
<p>‍</p>
<h2 id="静态类和静态构造函数"><a href="#静态类和静态构造函数" class="headerlink" title="静态类和静态构造函数"></a>静态类和静态构造函数</h2><h3 id="静态类（static-class​）"><a href="#静态类（static-class​）" class="headerlink" title="静态类（static class​）"></a>静态类（<code>static class</code>​）</h3><p><strong>特点：</strong></p>
<ul>
<li>只能包含 <strong>静态成员</strong></li>
<li><strong>不能被实例化</strong></li>
<li>不能继承或被继承</li>
</ul>
<p><strong>作用：</strong></p>
<ol>
<li>将静态成员集中放入静态类中，<strong>方便调用</strong></li>
<li>静态类不能实例化，更能体现其作为<strong>工具类的唯一性</strong></li>
<li>常用于存放工具方法（如：数学计算、字符串处理等）</li>
</ol>
<p>✅ 例如：<code>Console</code>​ 就是一个静态类</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">"Hello from static class!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>调用方式：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">Test.SayHello(); <span class="comment">// 不需要实例化</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h3 id="静态构造函数（static-构造函数​）"><a href="#静态构造函数（static-构造函数​）" class="headerlink" title="静态构造函数（static 构造函数​）"></a>静态构造函数（<code>static 构造函数</code>​）</h3><p><strong>特点：</strong></p>
<ul>
<li>可存在于 <strong>普通类</strong> 和 <strong>静态类</strong></li>
<li><strong>没有访问修饰符</strong>（如 public、private 等）</li>
<li><strong>不能带参数</strong></li>
<li>系统自动调用：在第一次访问类的成员时自动执行</li>
<li>只会被调用 <strong>一次</strong></li>
</ul>
<p><strong>作用：</strong></p>
<p>用于 <strong>初始化静态字段或执行类级别的一次性任务</strong></p>
<p><strong>语法格式：</strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">MyClass</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 静态构造逻辑</span></span><br><span class="line">        Console.WriteLine(<span class="string">"Static constructor executed."</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> Number = <span class="number">42</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>调用示例：</strong></p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">Console.WriteLine(MyClass.Number); <span class="comment">// 首次访问类，静态构造函数被调用</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h2><p>可以在不修改某一个类的情况下，为该类扩展新的成员方法，实现方法的扩展。注意，不能为静态类扩展方法。</p>
<p>为一个类添加扩展方法需要满足三个要素：</p>
<ol>
<li>扩展方法所在的类必须是静态类。</li>
<li>扩展方法本身必须是静态方法。</li>
<li>扩展方法的第一个参数需要使用关键字 <code>this</code>​，指定要扩展的类。</li>
</ol>
<p>‍</p>
<p>示例语法：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 静态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">TestExtensionM</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 静态扩展方法，扩展 int 类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">ExtensionInt</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">int</span> s</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> s + s;	<span class="comment">//这个扩展方法是服务于int类型的，返回它自己的2倍；</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>使用方法也很简单：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">9</span>;</span><br><span class="line">a = a.ExtensionInt();  <span class="comment">// 结果为 18</span></span><br></pre></td></tr></tbody></table></figure>

<p>扩展方法也可以带多个参数：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">TestExtensionM</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 静态扩展方法，带多个参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">ExtensionInt</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">int</span> s, <span class="built_in">int</span> m, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> s + m + y;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>使用示例：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> a = <span class="number">10</span>;</span><br><span class="line">a = a.ExtensionInt(<span class="number">20</span>, <span class="number">30</span>);  <span class="comment">// 结果为 60</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>注意事项：</p>
<ul>
<li>如果扩展的方法和类里面原有的方法重名，则调用该方法时运行类里面原有的方法</li>
</ul>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>​<code>运算符重载</code>​：允许自定义类型（类或结构体）重新定义标准运算符的行为，使得该类型的对象能够像内置类型一样，直接使用运算符进行操作。</p>
<p><strong>作用：</strong></p>
<ul>
<li>让自定义类型的对象更自然地使用 <code>+</code>​、<code>-</code>​、<code>*</code>​、<code>==</code>​ 等运算符。</li>
<li>提升代码的可读性和可维护性。</li>
<li>实现特定类型间的运算规则。</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>只能重载已有的运算符，不能创造新的运算符。</li>
<li>至少要重载一对相关运算符（比如 <code>==</code>​ 和 <code>!=</code>​）。</li>
<li>重载运算符必须是 <code>public static</code>​ 方法。</li>
<li>运算符重载不是必须的，只在需要时使用。</li>
</ul>
<p><strong>基本语法：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回类型 <span class="keyword">operator</span> 运算符(参数列表)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 实现运算符逻辑</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p> <strong>C# 中运算符重载的能力：</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>+, -, !, ~, ++, –</td>
<td>这些一元运算符只有一个操作数，且可以被重载。</td>
</tr>
<tr>
<td>+, -, *, /, %</td>
<td>这些二元运算符带有两个操作数，且可以被重载。</td>
</tr>
<tr>
<td>==, !=, &lt;, &gt;, &lt;=, &gt;=</td>
<td>这些比较运算符可以被重载。</td>
</tr>
<tr>
<td>&amp;&amp;, ||</td>
<td>这些条件逻辑运算符不能被直接重载。</td>
</tr>
<tr>
<td>+=, -=, *=, /=, %=</td>
<td>这些赋值运算符不能被重载。</td>
</tr>
<tr>
<td>=, ., ?:, -&gt;, new, is, sizeof, typeof</td>
<td>这些运算符不能被重载。</td>
</tr>
</tbody></table>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h3><p>继承是面向对象编程的基本特性。</p>
<p>继承允许一个类（子类）继承另一个类（父类）的<code>属性</code>​和<code>方法</code>​，从而实现代码复用和扩展。</p>
<p>语法： ：类名</p>
<p>举例：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span>()</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">"Hello, my name is "</span> + Name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Student</span>()：<span class="title">Person</span></span><br><span class="line">{</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> StudentID;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    {</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.Name = <span class="string">"Tom"</span>;    <span class="comment">// 继承自Person</span></span><br><span class="line">        student.StudentID = <span class="number">123</span>;</span><br><span class="line">        student.SayHello();      <span class="comment">// 调用继承的方法</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"Student ID: "</span> + student.StudentID);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="继承构造函数："><a href="#继承构造函数：" class="headerlink" title="继承构造函数："></a>继承构造函数：</h3><ul>
<li>初始化子类时，会先调用父类的默认构造函数，然后再调用子类的构造函数。</li>
<li>当父类或子类定义了构造函数时，默认的无参构造函数会被覆盖。</li>
<li>在子类声明构造函数时，如果想指定调用父类的某个构造函数，可以使用 <code>base(参数)</code>​。</li>
<li>如果想在一个类中用自己的构造函数调用该类的另一个构造函数，可以使用 <code>this(参数)</code>​。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GameObject</span>  <span class="comment">// 父类</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">float</span> x;</span><br><span class="line">    <span class="built_in">float</span> y;</span><br><span class="line">    <span class="built_in">float</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">GameObject</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">int</span> m, <span class="built_in">int</span> k</span>)  <span class="comment">// 构造函数</span></span></span><br><span class="line">    {</span><br><span class="line">        x = i;</span><br><span class="line">        y = m;</span><br><span class="line">        z = k;</span><br><span class="line">        Console.WriteLine(<span class="string">"GameObject构造函数"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">GameObject</span>()  <span class="comment">// 构造函数重载</span></span></span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">"GameObject构造函数重载"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cube</span> : <span class="title">GameObject</span>  <span class="comment">// Cube类继承GameObject</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> vertex;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> edge;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">ConstructCube</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">int</span> c = vertex + edge;</span><br><span class="line">        vertex = <span class="number">0</span>;</span><br><span class="line">        edge = <span class="number">0</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">"您已创建正方体"</span>);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cube</span>(<span class="params"><span class="built_in">int</span> i, <span class="built_in">int</span> m, <span class="built_in">int</span> k</span>) : <span class="title">base</span>(<span class="params">i, m, k</span>)  <span class="comment">// 使用Base()继承父类构造函数</span></span></span><br><span class="line">    {</span><br><span class="line">        vertex = <span class="number">8</span>;</span><br><span class="line">        edge = <span class="number">12</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">"Cube继承子类构造函数"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cube</span>()  <span class="comment">// 构造函数重载</span></span></span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">"Cube构造函数继承子类重载"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cube</span>(<span class="params"><span class="built_in">string</span> str</span>) : <span class="title">this</span>()  <span class="comment">// 调用自己的无参构造函数</span></span></span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">"我用构造函数调用自己类的构造函数说了："</span> + str);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="万物之父（object）-装箱和拆箱"><a href="#万物之父（object）-装箱和拆箱" class="headerlink" title="万物之父（object）,装箱和拆箱"></a>万物之父（object）,装箱和拆箱</h1><p>​<code>object</code>​（System.Object）是所有类型的终极父类（基类），所有类型都可以向上转换为<code>object</code>​。</p>
<ol>
<li>可以用里氏替换原则，用object装所有对象</li>
<li>可以用来表示不确定型，作为函数参数类型</li>
</ol>
<h3 id="Object装引用类型："><a href="#Object装引用类型：" class="headerlink" title="Object装引用类型："></a>Object装引用类型：</h3><p>​<code>object</code>​ 是所有类型的基类，引用类型可以直接赋值给 <code>object</code>​ 类型变量。</p>
<h4 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h4><ul>
<li><strong>装箱</strong>：将值类型转换为引用类型（如object），将值从栈内存复制到堆内存，并封装成对象。</li>
<li><strong>拆箱</strong>：将引用类型中的值转换回对应的值类型，从堆内存复制回栈内存，必须显式强制转换。</li>
</ul>
<h4 id="装箱的作用"><a href="#装箱的作用" class="headerlink" title="装箱的作用"></a>装箱的作用</h4><ul>
<li>允许<strong>值类型</strong>以<strong>引用类型</strong>的形式存储和传递，方便在需要引用类型的场景（如集合）中使用值类型。</li>
</ul>
<h4 id="拆箱的作用"><a href="#拆箱的作用" class="headerlink" title="拆箱的作用"></a>拆箱的作用</h4><ul>
<li>将装箱后的引用类型恢复为原始值类型，方便进行值类型的操作。</li>
</ul>
<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li><strong>好处</strong>：方便不同类型的数据存储和传递，增强灵活性。</li>
<li><strong>坏处</strong>：装箱和拆箱涉及内存复制和堆分配，带来额外的性能开销，频繁使用会影响效率。</li>
</ul>
<h4 id="装类类型"><a href="#装类类型" class="headerlink" title="装类类型"></a>装类类型</h4><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Person();  <span class="comment">// Person 对象赋值给 object</span></span><br><span class="line">Person s = <span class="keyword">new</span> Person();</span><br><span class="line">o = s;  <span class="comment">// object 可以引用 Person 对象（引用赋值）</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>使用时推荐<strong>里氏替换原则</strong>，即用父类（或基类）变量引用子类实例。</li>
<li>判断和转换：</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (o <span class="keyword">is</span> Person)  <span class="comment">// 判断 o 是否是 Person 类型或其子类实例</span></span><br><span class="line">{</span><br><span class="line">    Person s2 = o <span class="keyword">as</span> Person;  <span class="comment">// 安全转换，失败时返回 null</span></span><br><span class="line">    <span class="comment">// 或者 Person s2 = (Person)o; // 强制转换，失败时抛异常</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="装字符串类型"><a href="#装字符串类型" class="headerlink" title="装字符串类型"></a>装字符串类型</h4><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line">Object o = <span class="string">"12342"</span>;  <span class="comment">// 字符串是引用类型，直接赋值给 object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方式：</span></span><br><span class="line"><span class="built_in">string</span> str1 = o.ToString();  <span class="comment">// 调用 ToString()，返回字符串表示</span></span><br><span class="line"><span class="built_in">string</span> str2 = o <span class="keyword">as</span> <span class="built_in">string</span>;   <span class="comment">// 使用 as 转换，成功返回字符串，失败返回 null</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="装数组类型"><a href="#装数组类型" class="headerlink" title="装数组类型"></a>装数组类型</h4><figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> o = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换方法1：使用 as（安全转换，失败返回 null）</span></span><br><span class="line"><span class="built_in">int</span>[] a = o <span class="keyword">as</span> <span class="built_in">int</span>[];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换方法2：强制类型转换（失败抛异常）</span></span><br><span class="line"><span class="built_in">int</span>[] a2 = (<span class="built_in">int</span>[])o;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="装值类型："><a href="#装值类型：" class="headerlink" title="装值类型："></a>装值类型：</h4><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">object</span> o = <span class="number">1</span>;   <span class="comment">// 将值类型装箱为引用类型</span></span><br><span class="line"><span class="comment">// 转换方法 强制类型转换</span></span><br><span class="line"><span class="built_in">int</span> i = (<span class="built_in">int</span>)o;  <span class="comment">// 将object类型拆箱回int类型</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><strong>装箱</strong>：将值类型转换为引用类型（如object），将值从栈内存复制到堆内存，并封装成对象。</li>
<li><strong>拆箱</strong>：将引用类型中的值转换回对应的值类型，从堆内存复制回栈内存，必须显式强制转换。</li>
</ul>
<h3 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h3><ul>
<li><p>用sealed封装，不能被继承的类。</p>
</li>
<li><p>在面向对象的程序设计中，密封类的主要作用是不允许最底层的子类被继承，这样安全性更高。</p>
</li>
</ul>
<p><strong>语法：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">ClassName</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 类成员</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例代码</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个密封类</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">"动物叫声"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的代码会报错，因为Animal是sealed，不能被继承</span></span><br><span class="line"><span class="comment">// class Dog : Animal</span></span><br><span class="line"><span class="comment">// {</span></span><br><span class="line"><span class="comment">// }</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>补充说明</strong></p>
<ul>
<li><strong>sealed类</strong>可以继承自其他类，但不能被继承。</li>
<li><strong>sealed修饰方法</strong>：方法也可以被<code>sealed</code>​修饰（必须是重写方法），防止被进一步重写。</li>
<li>如果不希望其他类继承某个类，就可以将该类声明为<code>sealed</code>​。</li>
</ul>
<h1 id="多态vob"><a href="#多态vob" class="headerlink" title="多态vob"></a>多态vob</h1><h3 id="什么是多态（Polymorphism）？"><a href="#什么是多态（Polymorphism）？" class="headerlink" title="什么是多态（Polymorphism）？"></a><strong>什么是多态（Polymorphism）？</strong></h3><ul>
<li>多态是指<strong>相同的方法在不同的对象上有不同的表现形式</strong>。</li>
</ul>
<h3 id="多态的三要素：V-O-B"><a href="#多态的三要素：V-O-B" class="headerlink" title="多态的三要素：V.O.B"></a><strong>多态的三要素：V.O.B</strong></h3><ul>
<li><table>
<thead>
<tr>
<th>缩写</th>
<th>含义</th>
<th>关键词</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>V</td>
<td>Virtual</td>
<td>​<code>virtual</code>​</td>
<td>父类中声明<strong>虚方法</strong>，允许子类重写</td>
</tr>
<tr>
<td>O</td>
<td>Override</td>
<td>​<code>override</code>​</td>
<td>子类中重写父类的<strong>虚方法</strong></td>
</tr>
<tr>
<td>B</td>
<td>Base</td>
<td>​<code>base</code>​</td>
<td>子类中调用父类<strong>被重写的方法</strong></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="多态的目的"><a href="#多态的目的" class="headerlink" title="多态的目的"></a><strong>多态的目的</strong></h3><ul>
<li><strong>让继承父类的子类对象</strong>在调用同一个方法时拥有<strong>各自不同的行为</strong></li>
<li><strong>统一接口，行为多样化</strong></li>
<li><strong>实现行为复用 + 灵活扩展</strong></li>
</ul>
<h3 id="示例说明（吃饭行为的多态）"><a href="#示例说明（吃饭行为的多态）" class="headerlink" title="示例说明（吃饭行为的多态）"></a><strong>示例说明（吃饭行为的多态）</strong></h3><ul>
<li><strong>父类：</strong>  父亲吃饭 → 坐着吃</li>
<li><strong>子类：</strong>  儿子吃饭 → 站着吃（但想先执行父亲的逻辑）</li>
</ul>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a><strong>原理：</strong></h3><ul>
<li><p>​<code>virtual</code>​ 修饰父类方法，可被重写</p>
</li>
<li><p>​<code>override</code>​ 用于子类方法的重写</p>
</li>
<li><p>​<code>base.方法()</code>​ 表示在子类中<strong>调用父类的实现</strong></p>
</li>
<li><p><strong>虚函数可以被子类重写，配合</strong>​<strong>​<code>override</code>​</strong>​<strong>使用</strong></p>
</li>
</ul>
<h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a><strong>举例：</strong></h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Animals</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Animals</span>(<span class="params"><span class="built_in">string</span> name</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Speak</span>() <span class="comment">// V: virtual 虚方法</span></span></span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">"I am an animal"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Duck</span> : <span class="title">Animals</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Duck</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span> { }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>() <span class="comment">// O: override 重写方法</span></span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 如果想继承父类部分逻辑可用 base.Speak();</span></span><br><span class="line">        Console.WriteLine(<span class="string">"I am a duck, My name is {0}"</span>, name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Turkey</span> : <span class="title">Animals</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Turkey</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>)</span> { }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Speak</span>()</span></span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">"I am a turkey, My name is {0}"</span>, name);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">    {</span><br><span class="line">        Animals duck01 = <span class="keyword">new</span> Duck(<span class="string">"Ducky"</span>);</span><br><span class="line">        duck01.Speak(); <span class="comment">// 输出：I am a duck, My name is Ducky</span></span><br><span class="line"></span><br><span class="line">        Animals turkey02 = <span class="keyword">new</span> Turkey(<span class="string">"Kidden"</span>);</span><br><span class="line">        turkey02.Speak(); <span class="comment">// 输出：I am a turkey, My name is Kidden</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="C-抽象类与抽象方法（abstract​）"><a href="#C-抽象类与抽象方法（abstract​）" class="headerlink" title="C# 抽象类与抽象方法（abstract​）"></a>C# 抽象类与抽象方法（<code>abstract</code>​）</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>关键词：<code>abstract</code>​</p>
<h3 id="什么是抽象类？"><a href="#什么是抽象类？" class="headerlink" title="什么是抽象类？"></a>什么是抽象类？</h3><ul>
<li><p>‍</p>
</li>
<li><p>抽象类是用于<strong>被其他类继承</strong>的类，<strong>不能直接被实例化</strong></p>
</li>
<li><p>它通常用来定义一类对象的<strong>通用属性和行为</strong></p>
</li>
<li><p>抽象类的作用是作为<strong>父类模板</strong>，供子类实现具体逻辑</p>
</li>
</ul>
<p>例如：<code>Thing</code>​ 类是“物品”的统称，是一个抽象概念，不能单独存在，只能被继承。</p>
<h3 id="抽象方法的特点"><a href="#抽象方法的特点" class="headerlink" title="抽象方法的特点"></a>抽象方法的特点</h3><ul>
<li>抽象方法<strong>没有方法体</strong>（即不包含具体实现）</li>
<li>必须在子类中进行<strong>重写（override）</strong></li>
<li>抽象方法必须定义在抽象类中</li>
</ul>
<h3 id="示例说明：动物类"><a href="#示例说明：动物类" class="headerlink" title="示例说明：动物类"></a>示例说明：动物类</h3><ul>
<li>​<code>Animal</code>​ 是抽象类，不能实例化，只能作为父类存在</li>
<li><code>Shout()</code>​ 是抽象方法，所有子类必须重写此方法</li>
</ul>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span> <span class="comment">// 抽象类</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法，无方法体</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Shout</span>()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Shout</span>()</span></span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">"Meow!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Shout</span>()</span></span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">"Woof!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>‍</p>
<h3 id="抽象类使用规则总结"><a href="#抽象类使用规则总结" class="headerlink" title="抽象类使用规则总结"></a>抽象类使用规则总结</h3><table>
<thead>
<tr>
<th align="center">编号</th>
<th>规则描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td>抽象方法只能出现在抽象类中</td>
</tr>
<tr>
<td align="center">2</td>
<td>抽象类中可以包含普通方法（可有方法体）</td>
</tr>
<tr>
<td align="center">3</td>
<td>抽象方法没有实现，必须被子类重写</td>
</tr>
<tr>
<td align="center">4</td>
<td>抽象类不能被实例化（不能<code>new</code>​）</td>
</tr>
<tr>
<td align="center">5</td>
<td>抽象类和抽象方法都需使用<code>abstract</code>​关键字</td>
</tr>
<tr>
<td align="center">6</td>
<td>子类重写抽象方法时，必须使用<code>override</code>​关键字</td>
</tr>
<tr>
<td align="center">7</td>
<td>如果子类不是抽象类，它<strong>必须实现</strong>父类的所有抽象方法</td>
</tr>
</tbody></table>
<h3 id="使用场景举例"><a href="#使用场景举例" class="headerlink" title="使用场景举例"></a>使用场景举例</h3><table>
<thead>
<tr>
<th>场景</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>动物种类抽象</td>
<td>​<code>Animal</code>​→<code>Dog</code>​、<code>Cat</code>​</td>
</tr>
<tr>
<td>形状抽象</td>
<td>​<code>Shape</code>​→<code>Circle</code>​、<code>Rectangle</code>​</td>
</tr>
<tr>
<td>员工类型抽象</td>
<td>​<code>Employee</code>​→<code>Manager</code>​、<code>Developer</code>​</td>
</tr>
</tbody></table>
<h3 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h3><ul>
<li>抽象类是一种<strong>模板设计方式</strong>，强制子类实现某些功能</li>
<li>如果不打算实例化一个类，而只是作为基类，优先使用 <code>abstract</code>​</li>
</ul>
<h2 id="抽象方法（函数）"><a href="#抽象方法（函数）" class="headerlink" title="抽象方法（函数）"></a>抽象方法（函数）</h2><h3 id="什么是抽象方法？"><a href="#什么是抽象方法？" class="headerlink" title="什么是抽象方法？"></a>什么是抽象方法？</h3><ul>
<li>抽象方法是<strong>没有方法体</strong>的方法。</li>
<li>它只能存在于<strong>抽象类</strong>中。</li>
<li>子类必须使用<code>override</code>​来<strong>重写实现</strong>该抽象方法，这表示不抽象方法能用<code>private</code>​修饰。</li>
</ul>
<h3 id="抽象方法的定义格式："><a href="#抽象方法的定义格式：" class="headerlink" title="抽象方法的定义格式："></a>抽象方法的定义格式：</h3><ul>
<li>​<code>abstract</code>​ 关键字放在方法定义前面</li>
<li>方法<strong>没有方法体</strong>（即没有 <code>{}</code>​，只以 <code>;</code>​ 结尾）</li>
</ul>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> 类名</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> 返回类型 方法名(参数列表);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类必须实现抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">"Woof!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="抽象方法与普通虚方法的区别"><a href="#抽象方法与普通虚方法的区别" class="headerlink" title="抽象方法与普通虚方法的区别"></a>抽象方法与普通虚方法的区别</h3><table>
<thead>
<tr>
<th>比较项</th>
<th>抽象方法 (<code>abstract</code>​)</th>
<th>虚方法 (<code>virtual</code>​)</th>
</tr>
</thead>
<tbody><tr>
<td>是否有方法体</td>
<td>❌ 没有</td>
<td>✅ 有默认实现</td>
</tr>
<tr>
<td>是否必须重写</td>
<td>✅ 是</td>
<td>❌ 可选</td>
</tr>
<tr>
<td>是否必须在抽象类中</td>
<td>✅ 是</td>
<td>❌ 否</td>
</tr>
</tbody></table>
<h3 id="抽象方法的优点"><a href="#抽象方法的优点" class="headerlink" title="抽象方法的优点"></a>抽象方法的优点</h3><ul>
<li>提供统一的接口规范</li>
<li>强制子类实现特定功能</li>
<li>有助于面向对象中的“<strong>多态性</strong>”设计</li>
</ul>
<h3 id="使用场景示例"><a href="#使用场景示例" class="headerlink" title="使用场景示例"></a>使用场景示例</h3><p>所有子类都必须实现某些功能时：</p>
<ul>
<li>比如：<code>Animal</code>​ 类中的 <code>MakeSound()</code>​ 方法</li>
<li>或 <code>Shape</code>​ 类中的 <code>CalculateArea()</code>​ 方法</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote>
<p>抽象方法是一种设计规范的体现。<br>希望所有子类都<strong>必须实现</strong>某个方法时，就使用抽象方法。</p>
</blockquote>
<p>‍</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="什么是接口？"><a href="#什么是接口？" class="headerlink" title="什么是接口？"></a>什么是接口？</h2><p>关键词：<code>Interface</code>​</p>
<ul>
<li><p>里面的成员不能实现，被类和接口继承，一个类可以继承多个接口，继承接口后必须实现其成员</p>
</li>
<li><p>接口不能被实例化，只能当作存储容器，遵循里氏替换原则</p>
</li>
<li><p>接口相当于抽象行为的基类，是行为的抽象规范，一般用来抽象行为</p>
</li>
</ul>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">Fly</span> <span class="comment">//接口</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Func_Fly</span>()</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Bird</span> : <span class="title">Animals</span>, <span class="title">Fly</span> <span class="comment">//小鸟继承了接口</span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Bird</span>(<span class="params"><span class="built_in">string</span> name</span>) : <span class="title">base</span>(<span class="params">name</span>) <span class="comment">//构造函数</span></span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Func_Fly</span>() <span class="comment">//实现接口成员</span></span></span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">"小鸟完成了飞行"</span>);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="显示实现接口"><a href="#显示实现接口" class="headerlink" title="显示实现接口"></a>显示实现接口</h2><h3 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h3><p>当一个类<strong>实现多个接口</strong>，而这些接口中有<strong>同名的方法或属性</strong>时，为了避免命名冲突，<strong>必须通过“显式实现”来区分它们</strong>。</p>
<h3 id="语法格式示例"><a href="#语法格式示例" class="headerlink" title="语法格式示例"></a>语法格式示例</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IOne</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span>()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">ITwo</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoSomething</span>()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">IOne</span>, <span class="title">ITwo</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 显式实现接口 IOne 的方法</span></span><br><span class="line">    <span class="keyword">void</span> IOne.DoSomething()</span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">"IOne.DoSomething"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式实现接口 ITwo 的方法</span></span><br><span class="line">    <span class="keyword">void</span> ITwo.DoSomething()</span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">"ITwo.DoSomething"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">MyClass obj = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="comment">// 必须强制转换为接口类型，才能访问显式实现的方法</span></span><br><span class="line">((IOne)obj).DoSomething();     <span class="comment">// 输出：IOne.DoSomething</span></span><br><span class="line">((ITwo)obj).DoSomething();     <span class="comment">// 输出：ITwo.DoSomething</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul>
<li><p><strong>显式实现的方法不会在类实例中直接暴露</strong></p>
<ul>
<li>即：<code>obj.DoSomething();</code>​ ❌ 无法调用</li>
</ul>
</li>
<li><p>只能通过<strong>接口引用</strong>或者强制类型转换来访问</p>
</li>
</ul>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>实现多个接口中<strong>具有相同成员签名的方法</strong></li>
<li>防止接口方法被类实例直接访问（封装接口成员）</li>
<li>提高类的灵活性和接口解耦能力</li>
</ul>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>是否支持重载</td>
<td>支持，同名方法根据接口区分</td>
</tr>
<tr>
<td>调用方式</td>
<td>必须通过接口引用或强制类型转换</td>
</tr>
<tr>
<td>好处</td>
<td>避免命名冲突，增强封装性</td>
</tr>
<tr>
<td>限制</td>
<td>类中无法直接访问显式实现的方法</td>
</tr>
</tbody></table>
<p>‍</p>
<h1 id="密封函数"><a href="#密封函数" class="headerlink" title="密封函数"></a>密封函数</h1><p>当在<code>override</code>​前加上<code>sealed</code>​时，这个函数不能被子类重写，当在继承子类中，在重写的父类函数<code>override</code>​关键字前加<code>sealed</code>​，则不允许继承子类的子类再次进行重写。</p>
<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>命名空间是用来组织和重用代码的</p>
<p>命名空间就像是一个工具包，类就是一个个工具，都是在命名空间申明的</p>
<p>语法：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">Namespace 空间名</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>举例</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">Namespace MyGame</span><br><span class="line">{</span><br><span class="line">	Class Player</span><br><span class="line">	{</span><br><span class="line">	</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p>命名空间可以同名分开写，相当于同一个命名空间</p>
</li>
<li><p>不同命名空间相互使用需要引用命名空间或指明出处</p>
</li>
</ul>
<p>引用：</p>
<ul>
<li><p>在命名空间上方<code>using system</code>​ 这相当于引用了<code>system</code>​命名空间</p>
</li>
<li><p>如果要用另一个命名空间，则要加<code> using 命名空间名</code>​</p>
</li>
</ul>
<p>调用某一命名空间的类的方法：</p>
<p>在另一个域里使用某个命名空间下的类时，语法如下</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> MyGame;		<span class="comment">//1.引用命名空间</span></span><br><span class="line">	Class MyfirstScript</span><br><span class="line">	{</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">newPlayer</span>()</span></span><br><span class="line">		{</span><br><span class="line">			MyGame.Player = <span class="keyword">new</span> MyGame.Player();	<span class="comment">//2.  命名空间名 . 类名 来使用</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="单例模式（singleton）"><a href="#单例模式（singleton）" class="headerlink" title="单例模式（singleton）"></a>单例模式（singleton）</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhili/p/SingletonPatterm.html">C#设计模式(1)——单例模式 </a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaohanxixi/p/13197362.html" title="发布于 2020-06-27 09:23">C#实现单例模式的几种方法 </a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/willick/p/13399194.html">C#单例模式最佳实践 </a></p>
<p>单例模式的概念：<strong>确保一个类只有一个实例,并提供一个全局访问点。</strong></p>
<p>单例模式的多种实现方式：懒汉模式、饿汉模式</p>
<p>区别：懒汉：类在加载时不会实例化自己的对象，饿汉：类在加载时就实例化自己的对象</p>
<p>单例模式在多线程下涉及到线程同步问题，为此我们要设置双重锁定。</p>
<p>代码示例</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton _instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton Instance</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> _instance;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//懒汉模式，双重锁定的实现方式，解决了线程安全问题并优化了性能。非常经典的写法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 定义一个静态变量来保存类的实例</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个标识确保线程同步</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">object</span> locker = <span class="keyword">new</span> <span class="built_in">object</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义私有构造函数，使外界不能创建该类实例</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>()</span></span><br><span class="line">        {</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>()</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// 当第一个线程运行到这里时，此时会对locker对象 "加锁"，</span></span><br><span class="line">            <span class="comment">// 当第二个线程运行该方法时，首先检测到locker对象为"加锁"状态，该线程就会挂起等待第一个线程解锁</span></span><br><span class="line">            <span class="comment">// lock语句运行完之后（即线程运行完之后）会对该对象"解锁"</span></span><br><span class="line">            <span class="comment">// 双重锁定只需要一句判断就可以了</span></span><br><span class="line">            <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">lock</span> (locker)</span><br><span class="line">                {</span><br><span class="line">                    <span class="comment">// 如果类的实例不存在则创建，否则直接返回</span></span><br><span class="line">                    <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">                    {</span><br><span class="line">                        uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//使用.NET 4 Lazy&lt;T&gt; type 特性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LazySingleton</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Lazy&lt;LazySingleton&gt; _instance =</span><br><span class="line">        <span class="keyword">new</span> Lazy&lt;LazySingleton&gt;(() =&gt; <span class="keyword">new</span> LazySingleton());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton Instance</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">get</span> { <span class="keyword">return</span> _instance.Value; }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//调用示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">var</span> instance = LazySingleton.Instance;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>‍</p>
<p>‍</p>
<h1 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h1><h2 id="字符串常用方法说明"><a href="#字符串常用方法说明" class="headerlink" title="字符串常用方法说明"></a>字符串常用方法说明</h2><table>
<thead>
<tr>
<th>功能类别</th>
<th>方法名/属性</th>
<th>参数说明</th>
<th>示例代码</th>
</tr>
</thead>
<tbody><tr>
<td>获取长度</td>
<td>​<code>Length</code>​</td>
<td>无</td>
<td>​<code>int len = str.Length;</code>​</td>
</tr>
<tr>
<td>字符访问</td>
<td>​<code>[]</code>​（索引器）</td>
<td>​<code>int index</code>​：要访问的字符索引</td>
<td>​<code>char c = str[0];</code>​</td>
</tr>
<tr>
<td>转为字符数组</td>
<td>​<code>ToCharArray()</code>​</td>
<td>无</td>
<td>​<code>char[] arr = str.ToCharArray();</code>​</td>
</tr>
<tr>
<td>查找子串（正向）</td>
<td>​<code>IndexOf(string)</code>​</td>
<td>​<code>string value</code>​：要查找的子串</td>
<td>​<code>int i = str.IndexOf("鸭");</code>​</td>
</tr>
<tr>
<td>查找子串（反向）</td>
<td>​<code>LastIndexOf(string)</code>​</td>
<td>​<code>string value</code>​：要查找的子串</td>
<td>​<code>int i = str.LastIndexOf("达鸭");</code>​</td>
</tr>
<tr>
<td>截取子串</td>
<td>​<code>Substring(int)</code>​</td>
<td>​<code>startIndex</code>​：起始索引</td>
<td>​<code>string s = str.Substring(6);</code>​</td>
</tr>
<tr>
<td>截取子串</td>
<td>​<code>Substring(int, int)</code>​</td>
<td>​<code>startIndex</code>​：起始索引，<code>length</code>​：截取长度</td>
<td>​<code>string s = str.Substring(2, 3);</code>​</td>
</tr>
<tr>
<td>移除子串</td>
<td>​<code>Remove(int)</code>​</td>
<td>​<code>startIndex</code>​：从该位置开始移除到末尾</td>
<td>​<code>string s = str.Remove(2);</code>​</td>
</tr>
<tr>
<td>移除子串</td>
<td>​<code>Remove(int, int)</code>​</td>
<td>​<code>startIndex</code>​，<code>count</code>​：移除多少字符</td>
<td>​<code>string s = str.Remove(2, 1);</code>​</td>
</tr>
<tr>
<td>替换子串</td>
<td>​<code>Replace(old, new)</code>​</td>
<td>​<code>oldValue</code>​：原字符串，<code>newValue</code>​：替换成的新值</td>
<td>​<code>string s = str.Replace("可达鸭", "小猫咪");</code>​</td>
</tr>
<tr>
<td>拼接字符串</td>
<td>​<code>+</code>​</td>
<td>其他字符串</td>
<td>​<code>string s = str + "2333";</code>​</td>
</tr>
<tr>
<td>拼接格式化</td>
<td>​<code>string.Format()</code>​</td>
<td>格式字符串 + 参数</td>
<td>​<code>string s = string.Format("{0}呀", "可达鸭");</code>​</td>
</tr>
<tr>
<td>转为大写</td>
<td>​<code>ToUpper()</code>​</td>
<td>无</td>
<td>​<code>string upper = str.ToUpper();</code>​</td>
</tr>
<tr>
<td>转为小写</td>
<td>​<code>ToLower()</code>​</td>
<td>无</td>
<td>​<code>string lower = str.ToLower();</code>​</td>
</tr>
<tr>
<td>字符串切割</td>
<td>​<code>Split(char[])</code>​</td>
<td>​<code>char[]</code>​：分隔符数组</td>
<td>​<code>string[] arr = str.Split(',');</code>​</td>
</tr>
</tbody></table>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">string</span> str = <span class="string">"可达鸭呀"</span>;</span><br><span class="line">        <span class="comment">// 1. 字符串指定位置获取（索引器）</span></span><br><span class="line">        Console.WriteLine(str[<span class="number">0</span>]);  <span class="comment">// 输出：可</span></span><br><span class="line">        <span class="comment">// 遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; str.Length; i++)</span><br><span class="line">        {</span><br><span class="line">            Console.Write(str[i]);  <span class="comment">// 输出：可达鸭呀</span></span><br><span class="line">        }</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">        <span class="comment">// 转换为 char 数组</span></span><br><span class="line">        <span class="built_in">char</span>[] chars = str.ToCharArray();</span><br><span class="line">        Console.WriteLine(chars[<span class="number">0</span>]);  <span class="comment">// 输出：可</span></span><br><span class="line">        <span class="comment">// 2. 字符串拼接</span></span><br><span class="line">        <span class="built_in">string</span> st = <span class="built_in">string</span>.Format(str + <span class="string">"233333"</span>);</span><br><span class="line">        Console.WriteLine(st);  <span class="comment">// 输出：可达鸭呀233333</span></span><br><span class="line">        <span class="comment">// 3. 查找字符位置</span></span><br><span class="line">        <span class="built_in">int</span> index = str.IndexOf(<span class="string">"鸭"</span>);           <span class="comment">// 正向查找，找不到返回 -1</span></span><br><span class="line">        Console.WriteLine(index);                <span class="comment">// 输出：2</span></span><br><span class="line">        index = str.LastIndexOf(<span class="string">"达鸭"</span>);         <span class="comment">// 反向查找，查找的是“达鸭”的起始索引</span></span><br><span class="line">        Console.WriteLine(index);                <span class="comment">// 输出：1</span></span><br><span class="line">        <span class="comment">// 4. 移除字符</span></span><br><span class="line">        Console.WriteLine(str);                  <span class="comment">// 输出：可达鸭呀（原字符串未改变）</span></span><br><span class="line">        <span class="built_in">string</span> removed1 = str.Remove(<span class="number">2</span>);         <span class="comment">// 移除索引 2 及其后所有字符</span></span><br><span class="line">        Console.WriteLine(removed1);             <span class="comment">// 输出：可达</span></span><br><span class="line">        <span class="built_in">string</span> removed2 = str.Remove(<span class="number">2</span>, <span class="number">1</span>);      <span class="comment">// 从索引 2 移除 1 个字符</span></span><br><span class="line">        Console.WriteLine(removed2);             <span class="comment">// 输出：可达呀</span></span><br><span class="line">        <span class="comment">// 5. 替换字符串</span></span><br><span class="line">        <span class="built_in">string</span> replaced = str.Replace(<span class="string">"可达鸭"</span>, <span class="string">"小猫咪"</span>);</span><br><span class="line">        Console.WriteLine(replaced);             <span class="comment">// 输出：小猫咪呀</span></span><br><span class="line">        <span class="comment">// 6. 字母大小写转换</span></span><br><span class="line">        <span class="built_in">string</span> st4 = <span class="string">"asdawdjwiao"</span>;</span><br><span class="line">        <span class="built_in">string</span> upper = st4.ToUpper();            <span class="comment">// 转大写</span></span><br><span class="line">        Console.WriteLine(upper);                <span class="comment">// 输出：ASDAWDJWIAO</span></span><br><span class="line">        <span class="built_in">string</span> lower = upper.ToLower();          <span class="comment">// 转小写</span></span><br><span class="line">        Console.WriteLine(lower);                <span class="comment">// 输出：asdawdjwiao</span></span><br><span class="line">        <span class="comment">// 7. 字符串截取</span></span><br><span class="line">        str = <span class="string">"我是宫崎英高desu"</span>;</span><br><span class="line">        <span class="built_in">string</span> substr1 = str.Substring(<span class="number">6</span>);       <span class="comment">// 从索引 6 开始截取到结尾</span></span><br><span class="line">        Console.WriteLine(substr1);              <span class="comment">// 输出：desu</span></span><br><span class="line">        <span class="built_in">string</span> substr2 = str.Substring(<span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// 从索引 2 开始截取 3 个字符</span></span><br><span class="line">        Console.WriteLine(substr2);              <span class="comment">// 输出：宫崎英</span></span><br><span class="line">        <span class="comment">// 8. 字符串切割</span></span><br><span class="line">        <span class="built_in">string</span> st6 = <span class="string">"1,2,3,4,5,6,7,8"</span>;</span><br><span class="line">        <span class="built_in">string</span>[] parts = st6.Split(<span class="string">','</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> part <span class="keyword">in</span> parts)</span><br><span class="line">        {</span><br><span class="line">            Console.Write(part);                 <span class="comment">// 输出：12345678</span></span><br><span class="line">        }</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p>‍</p>
<h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><h2 id="什么是StringBuilder​？"><a href="#什么是StringBuilder​？" class="headerlink" title="什么是StringBuilder​？"></a>什么是<code>StringBuilder</code>​？</h2><p>一个字符串经常被修改会很消耗内存空间，stringBuilder用于解决这一问题。</p>
<ul>
<li>​<code>StringBuilder</code>​ 是 <code>System.Text</code>​ 命名空间下的一个公共类。</li>
<li>作用：<strong>用于频繁修改或拼接字符串时，避免创建多个新字符串对象，提高性能并节省内存开销。</strong></li>
</ul>
<h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>可变字符串</td>
<td>修改字符串内容不会生成新的字符串对象</td>
</tr>
<tr>
<td>自动扩容</td>
<td>默认初始容量为<strong>16</strong>，插入内容超出后会自动扩容</td>
</tr>
<tr>
<td>可指定初始容量</td>
<td>可以通过构造函数设置初始容量，避免频繁扩容带来的性能浪费</td>
</tr>
</tbody></table>
<p>使用命名空间：<code>using System.Text;</code>​</p>
<h2 id="构造方式："><a href="#构造方式：" class="headerlink" title="构造方式："></a>构造方式：</h2><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 默认初始容量为16</span></span><br><span class="line">StringBuilder sb1 = <span class="keyword">new</span> StringBuilder(<span class="string">"123123"</span>);</span><br><span class="line"><span class="comment">// 指定初始容量为48</span></span><br><span class="line">StringBuilder sb2 = <span class="keyword">new</span> StringBuilder(<span class="string">"123123"</span>, <span class="number">48</span>);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="属性说明："><a href="#属性说明：" class="headerlink" title="属性说明："></a>属性说明：</h2><table>
<thead>
<tr>
<th>属性/方法</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>​<code>Capacity</code>​</td>
<td>当前 StringBuilder 的容量</td>
<td>​<code>Console.WriteLine(sb1.Capacity);</code>​</td>
</tr>
<tr>
<td>​<code>Length</code>​</td>
<td>实际字符长度</td>
<td>​<code>Console.WriteLine(sb1.Length);</code>​</td>
</tr>
</tbody></table>
<h2 id="举例：-1"><a href="#举例：-1" class="headerlink" title="举例："></a>举例：</h2><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">class</span> <span class="title">Program</span>()</span><br><span class="line">{</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params"><span class="built_in">string</span> arg[]</span>)</span></span><br><span class="line">	{</span><br><span class="line">		System.Text.StringBuilder SB01 = <span class="keyword">new</span> System.Text.StringBuilder(<span class="string">"123123"</span>);</span><br><span class="line">		<span class="comment">//StringBuilder存在容量问题，每次往里面增加时，会自动扩容，默认初始容量为16</span></span><br><span class="line">		System.Text.StringBuilder SB01 = <span class="keyword">new</span> System.Text.StringBuilder(<span class="string">"123123"</span>,<span class="number">48</span>);<span class="comment">//可以指定容量，也可不指定。</span></span><br><span class="line">		Console.WriteLine(SB01.Capacity); <span class="comment">//获取容量</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="StringBuilder的增删查改："><a href="#StringBuilder的增删查改：" class="headerlink" title="StringBuilder的增删查改："></a>StringBuilder的增删查改：</h2><p><strong>增：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在末尾添加字符串</span></span><br><span class="line">sb.Append(<span class="string">"追加内容"</span>);</span><br><span class="line"><span class="comment">// 添加格式化字符串</span></span><br><span class="line">sb.AppendFormat(<span class="string">"{0} + {1}"</span>, <span class="string">"Hello"</span>, <span class="string">"World"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>插入：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 在指定位置插入字符串</span></span><br><span class="line">sb.Insert(<span class="number">2</span>, <span class="string">"插入内容"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>删除：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 从索引 3 开始删除 2 个字符</span></span><br><span class="line">sb.Remove(<span class="number">3</span>, <span class="number">2</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>清空：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 清空 StringBuilder 内容</span></span><br><span class="line">sb.Clear();</span><br></pre></td></tr></tbody></table></figure>

<p><strong>查找：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 输出指定位置字符</span></span><br><span class="line">Console.WriteLine(sb[<span class="number">1</span>]);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>改：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 修改指定索引位置字符</span></span><br><span class="line">sb[<span class="number">0</span>] = <span class="string">'新'</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>替换：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 替换所有 "旧" 字符为 "新"</span></span><br><span class="line">sb.Replace(<span class="string">"旧"</span>, <span class="string">"新"</span>);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<p><strong>重新赋值：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 清空再重新追加内容</span></span><br><span class="line">sb.Clear();</span><br><span class="line">sb.Append(<span class="string">"新的内容"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>判断相等：</strong></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (sb.ToString().Equals(<span class="string">"目标字符串"</span>))</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 执行逻辑</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="推荐使用场景"><a href="#推荐使用场景" class="headerlink" title="推荐使用场景"></a>推荐使用场景</h2><ul>
<li>在循环中频繁拼接字符串时（如日志生成、大批量字符串组合）。</li>
<li>替代 <code>string +=</code>​ 等不高效的字符串拼接方式。</li>
<li>实现动态内容构造，如 HTML、SQL 构建器等。</li>
</ul>
<h1 id="数据结构类"><a href="#数据结构类" class="headerlink" title="数据结构类"></a>数据结构类</h1><h2 id="Arraylist"><a href="#Arraylist" class="headerlink" title="Arraylist"></a>Arraylist</h2><h3 id="ArrayList-的本质"><a href="#ArrayList-的本质" class="headerlink" title="ArrayList 的本质"></a>ArrayList 的本质</h3><p><img src="/../../assets/image5-20231203171812-bk3gk8w.png"></p>
<p>​<code>ArrayList</code>​ 是 C# 提供的 <strong>非泛型集合类</strong>，属于 <code>System.Collections</code>​ 命名空间下的一个 <strong>动态数组</strong>，可以存储 <strong>任意类型的对象（object）</strong> ，容量可以动态扩展。</p>
<ul>
<li>本质上是一个支持自动扩容的 <code>object[]</code>​ 数组。</li>
<li>存储值类型会发生 <strong>装箱</strong>，读取时需要 <strong>拆箱</strong>，性能略低于泛型集合如 <code>List&lt;T&gt;</code>​。</li>
<li>在 .NET 泛型集合 (<code>System.Collections.Generic</code>​) 出现之前常用，现代开发建议使用 <code>List&lt;T&gt;</code>​ 替代。</li>
</ul>
<p>‍</p>
<h3 id="Arraylist引用命名空间与声明语法"><a href="#Arraylist引用命名空间与声明语法" class="headerlink" title="Arraylist引用命名空间与声明语法"></a>Arraylist引用命名空间与声明语法</h3><p>‍</p>
<p><img src="/../../assets/image6-20231203171812-2y47xjt.png"></p>
<p>‍</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//引用命名空间</span></span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个空的 ArrayList</span></span><br><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">// 创建并初始化</span></span><br><span class="line">ArrayList list2 = <span class="keyword">new</span> ArrayList() { <span class="number">1</span>, <span class="string">"hello"</span>, <span class="literal">true</span> };</span><br></pre></td></tr></tbody></table></figure>

<h3 id="ArrayList的增删查改"><a href="#ArrayList的增删查改" class="headerlink" title="ArrayList的增删查改"></a><strong>ArrayList的增删查改</strong></h3><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//添加（Add）</span></span><br><span class="line"><span class="comment">//由于arraylist是object类型，所以可以加任何类型</span></span><br><span class="line">list.Add(<span class="string">"字符串"</span>);</span><br><span class="line">list.Add(<span class="number">123</span>);     <span class="comment">// 装箱操作（int → object）</span></span><br><span class="line">list.Add(<span class="literal">true</span>);</span><br><span class="line">list.AddRange(list2)	<span class="comment">//把list2所有元素添加到list的末尾</span></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">list.Remove(<span class="string">"字符串"</span>);   <span class="comment">// 删除第一个匹配项</span></span><br><span class="line">list.RemoveAt(<span class="number">0</span>);        <span class="comment">// 删除指定索引处元素</span></span><br><span class="line">list.Clear();            <span class="comment">// 清空所有元素</span></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="keyword">var</span> box = list[<span class="number">0</span>];					  <span class="comment">//根据索引下标查找</span></span><br><span class="line"><span class="built_in">bool</span> exists = list.Contains(<span class="string">"字符串"</span>); <span class="comment">// 是否存在</span></span><br><span class="line"><span class="built_in">int</span> index = list.IndexOf(<span class="number">123</span>);        <span class="comment">// 查找索引（找不到返回 -1）</span></span><br><span class="line"><span class="built_in">int</span> index = list.LastIndexOf(<span class="number">123</span>);   <span class="comment">// 查找索引（找不到返回 -1）</span></span><br><span class="line"><span class="comment">//修改</span></span><br><span class="line">list[<span class="number">1</span>] = <span class="string">"新的值"</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>‍</p>
<p><img src="/../../assets/image7-20231203171812-jehtoji.png"></p>
<p><img src="/../../assets/image8-20231203171812-5o83tt0.png" alt="图形用户界面, 文本 描述已自动生成"></p>
<p><img src="/../../assets/image9-20231203171812-l1fmbmc.png"></p>
<p><img src="/../../assets/image10-20231203171812-g4jfcod.png" alt="文本 描述已自动生成"></p>
<p><img src="/../../assets/image11-20231203171812-6deacjc.png" alt="图形用户界面, 网站 描述已自动生成"></p>
<p><img src="/../../assets/image12-20231203171812-rsb0dmv.png" alt="图形用户界面 描述已自动生成"></p>
<p><img src="/../../assets/image13-20231203171812-5q5qx59.png" alt="图形用户界面, 文本 中度可信度描述已自动生成"></p>
<p><img src="/../../assets/image14-20231203171812-mbqioxn.png" alt="图片包含 文本 描述已自动生成"></p>
<p><img src="/../../assets/image15-20231203171812-ldkaqdn.png"></p>
<p><img src="/../../assets/image16-20231203171812-raq6j0b.png" alt="图形用户界面, 文本 描述已自动生成"></p>
<h3 id="插入与遍历"><a href="#插入与遍历" class="headerlink" title="插入与遍历"></a>插入与遍历</h3><p>插入：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.Insert(<span class="number">1</span>, <span class="string">"中间插入"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>第一个参数传索引位置，第二个传插入内容</p>
<p><img src="/../../assets/image17-20231203171812-85crm4w.png" alt="图形用户界面, 文本 中度可信度描述已自动生成"></p>
<p>它和stringBuilder一样会自己扩容。</p>
<p>Count是已存放的长度</p>
<p>Capacity是数组的总长</p>
<p><img src="/../../assets/image18-20231203171812-dt6vcs7.png" alt="文本 描述已自动生成"></p>
<h3 id="迭代器遍历："><a href="#迭代器遍历：" class="headerlink" title="迭代器遍历："></a>迭代器遍历：</h3><p>当你实现了迭代器，便可用此方法遍历</p>
<p><img src="/../../assets/image19-20231203171812-5lwx0x3.png"></p>
<p>Var是类型，item是变量名 collection是进行遍历的变量名，由于array是object类型，所以将var改成object，collection改为array，意思是，将array的内容依次遍历存放到object类型当中。</p>
<p><img src="/../../assets/image20-20231203171812-r3usy2r.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p>
<h3 id="装箱拆箱："><a href="#装箱拆箱：" class="headerlink" title="装箱拆箱："></a>装箱拆箱：</h3><p><img src="/../../assets/image21-20231203171812-7n89ssh.png"></p>
<p><img src="/../../assets/image22-20231203171812-uovkgpx.png"></p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p><img src="/../../assets/image23-20231203171812-3vf1pqj.png"></p>
<p><img src="/../../assets/image24-20231203171812-d0kuwch.png" alt="图形用户界面, 文本 描述已自动生成"></p>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p><img src="/../../assets/image25-20231203171812-bu10olc.png"></p>
<p>只能用push一个个放</p>
<h3 id="取"><a href="#取" class="headerlink" title="取"></a>取</h3><p><img src="/../../assets/image26-20231203171812-22tgxak.png"></p>
<p>用Pop来取</p>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p><img src="/../../assets/image27-20231203171812-qxn35bz.png"></p>
<p>Peek用来查看栈顶的内容但是不会弹出<img src="/../../assets/image28-20231203171812-xt59kia.png" alt="图形用户界面, 文本, 应用程序, 网站 描述已自动生成"></p>
<p>可以查看栈中是否有查找的内容，返回bool类型</p>
<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><p><img src="/../../assets/image29-20231203171812-783d7aw.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>由于栈不提供索引器进行遍历，所以不能用for进行遍历</p>
<p><img src="/../../assets/image30-20231203171812-w5m74h8.png"></p>
<p><img src="/../../assets/image31-20231203171812-k24d5lb.png" alt="文本 描述已自动生成"></p>
<p><img src="/../../assets/image32-20231203171812-mdv7csp.png" alt="图形用户界面, 文本 描述已自动生成"></p>
<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><p><img src="/../../assets/image33-20231203171812-26vce3l.png"></p>
<p><img src="/../../assets/image34-20231203171812-6xvx09k.png" alt="图形用户界面 描述已自动生成"></p>
<h3 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h3><p><img src="/../../assets/image35-20231203171812-6frz594.png"></p>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p><img src="/../../assets/image36-20231203171812-398arcm.png" alt="文本 描述已自动生成"></p>
<h3 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h3><p><img src="/../../assets/image37-20231203171812-ncupopn.png" alt="文本 中度可信度描述已自动生成"></p>
<p><img src="/../../assets/image38-20231203171812-t3wmld4.png" alt="文本 描述已自动生成"></p>
<h3 id="改-1"><a href="#改-1" class="headerlink" title="改"></a>改</h3><p>清空或者一个个出队列</p>
<p><img src="/../../assets/image39-20231203171812-4a8c4wu.png" alt="文本 描述已自动生成"></p>
<h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><p>Foreach遍历</p>
<p><img src="/../../assets/image40-20231203171812-sbxkq60.png" alt="图形用户界面, 文本 描述已自动生成"></p>
<p>转换为object数组遍历</p>
<p><img src="/../../assets/image41-20231203171812-yujwq45.png" alt="文本 描述已自动生成"></p>
<p>循环出队列</p>
<p><img src="/../../assets/image42-20231203171812-zgibwpq.png" alt="图形用户界面, 文本, 应用程序, 网站 描述已自动生成"></p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p><img src="/../../assets/image43-20231203171812-zexq5gx.png"></p>
<p><img src="/../../assets/image44-20231203171812-1r5tpcw.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p>
<p>键不能重复，值可以相同</p>
<h3 id="增-2"><a href="#增-2" class="headerlink" title="增"></a>增</h3><p>第一个参数为键，第二个参数为值</p>
<p><img src="/../../assets/image45-20231203171812-6ntaevp.png"></p>
<h3 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h3><p><img src="/../../assets/image46-20231203171812-gmlw6jz.png" alt="文本 描述已自动生成"></p>
<h3 id="查-2"><a href="#查-2" class="headerlink" title="查"></a>查</h3><p><img src="/../../assets/image47-20231203171812-fp6a910.png"></p>
<p><img src="/../../assets/image48-20231203171812-8ar9qu8.png"></p>
<h3 id="改-2"><a href="#改-2" class="headerlink" title="改"></a>改</h3><p><img src="/../../assets/image49-20231203171812-fk6g0tg.png" alt="文本 中度可信度描述已自动生成"></p>
<h3 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h3><p><img src="/../../assets/image50-20231203171812-gi6qyjy.png"> <img src="/../../assets/image51-20231203171812-xg64w4w.png"></p>
<p><img src="/../../assets/image52-20231203171812-78xohu1.png" alt="图形用户界面, 文本 描述已自动生成"></p>
<p>迭代器遍历：</p>
<p><img src="/../../assets/image53-20231203171812-jngacpn.png" alt="文本 描述已自动生成"></p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><img src="/../../assets/image54-20231203171812-spntofp.png"></p>
<p><img src="/../../assets/image55-20231203171812-jmrh0fy.png"></p>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p><img src="/../../assets/image56-20231203171812-5ocnhwk.png"></p>
<p>使用（实现了类型参数化）</p>
<p><img src="/../../assets/image57-20231203171812-k7hvjaa.png"></p>
<p>使用多个泛型占位符</p>
<p><img src="/../../assets/image58-20231203171812-5r7bs9f.png" alt="文本 描述已自动生成"></p>
<p>初始化时赋予类型</p>
<p><img src="/../../assets/image59-20231203171812-9gh9k6q.png"></p>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p><img src="/../../assets/image60-20231203171812-8gywz52.png" alt="文本 低可信度描述已自动生成"></p>
<p>接口被继承时赋予类型，并必须实现接口的成员</p>
<h3 id="普通类中的泛型方法"><a href="#普通类中的泛型方法" class="headerlink" title="普通类中的泛型方法"></a>普通类中的泛型方法</h3><p><img src="/../../assets/image61-20231203171812-qdsr6ap.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p>
<p><img src="/../../assets/image62-20231203171812-o36eu4p.png" alt="图形用户界面, 文本 描述已自动生成"></p>
<p>Default用于返回类型的默认值</p>
<p><img src="/../../assets/image63-20231203171812-jo1fbwf.png" alt="文本 描述已自动生成"></p>
<p>T用于作为返回值</p>
<p><img src="/../../assets/image64-20231203171812-i9xajdw.png"></p>
<p>使用多个泛型占位符的泛型方法</p>
<p><img src="/../../assets/image65-20231203171812-afwgc88.png" alt="文本 描述已自动生成"></p>
<h3 id="泛型类中的泛型方法"><a href="#泛型类中的泛型方法" class="headerlink" title="泛型类中的泛型方法"></a>泛型类中的泛型方法</h3><p><img src="/../../assets/image66-20231203171812-kb3c45v.png" alt="文本 描述已自动生成"></p>
<p><img src="/../../assets/image71-20231203171812-xxzauz1.png"></p>
<h3 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h3><p><img src="/../../assets/image72-20231203171812-abn5ml4.png" alt="文本 描述已自动生成"></p>
<p>总结</p>
<p><img src="/../../assets/image73-20231203171812-7yoapx9.png" alt="文本 描述已自动生成"></p>
<h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p><img src="/../../assets/image74-20231203171812-btz1zvj.png"></p>
<h3 id="值类型约束"><a href="#值类型约束" class="headerlink" title="值类型约束"></a>值类型约束</h3><p><img src="/../../assets/image75-20231203171812-ycllwwb.png" alt="图片包含 文本 描述已自动生成"></p>
<p><img src="/../../assets/image76-20231203171812-yj9cqq3.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<h3 id="引用类型约束"><a href="#引用类型约束" class="headerlink" title="引用类型约束"></a>引用类型约束</h3><p><img src="/../../assets/image77-20231203171812-rxjd65w.png" alt="文本 描述已自动生成"></p>
<p><img src="/../../assets/image78-20231203171812-7w1448d.png"></p>
<h3 id="存在无参公共构造函数："><a href="#存在无参公共构造函数：" class="headerlink" title="存在无参公共构造函数："></a>存在无参公共构造函数：</h3><p>传入的必须有公共无参构造函数，否则报错。</p>
<p><img src="/../../assets/image79-20231203171812-zmwy2gg.png"></p>
<p><img src="/../../assets/image80-20231203171812-4ktvduc.png" alt="图形用户界面 描述已自动生成"></p>
<p>申明了一个有无参构造函数的类，和一个无参构造函数被顶替掉的类。</p>
<p>有无参构造不会报错</p>
<p><img src="/../../assets/image81-20231203171812-ehmj0lk.png"></p>
<p>无无参构造报错</p>
<p><img src="/../../assets/image82-20231203171812-n0pkrhk.png"></p>
<p>如果构造函数用了private或者protected也会报错，使用抽象类的话，因为抽象类不能实例化，所以不能传抽象类</p>
<p>可以传所有的结构体（值类型），默认都有无参构造</p>
<h3 id="某个类本身或者其派生类"><a href="#某个类本身或者其派生类" class="headerlink" title="某个类本身或者其派生类"></a>某个类本身或者其派生类</h3><p>传入的必须是这个类或者其派生（继承）类</p>
<p>传本身</p>
<p><img src="/../../assets/image83-20231203171812-6n7zv0h.png" alt="图形用户界面, 文本 描述已自动生成"></p>
<p><img src="/../../assets/image84-20231203171812-bjxarg3.png"></p>
<p>传派生类</p>
<p><img src="/../../assets/image85-20231203171812-1fectv6.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p>
<p><img src="/../../assets/image86-20231203171812-79zla9r.png"></p>
<h3 id="接口约束"><a href="#接口约束" class="headerlink" title="接口约束"></a>接口约束</h3><p><img src="/../../assets/image88-20231203171812-x0obgkr.png" alt="文本 中度可信度描述已自动生成"></p>
<p><img src="/../../assets/image90-20231203171812-1he19j9.png" alt="文本 描述已自动生成"></p>
<p>接口不能实例化，但是遵循里氏替换</p>
<p><img src="/../../assets/image91-20231203171812-n4lc8rq.png" alt="图形用户界面 描述已自动生成"></p>
<p>或者直接填接口的继承子类（类或者接口）也是可以的</p>
<p><img src="/../../assets/image92-20231203171812-5cz52d0.png" alt="图形用户界面 描述已自动生成"></p>
<h3 id="另一个泛型本身或者派生类"><a href="#另一个泛型本身或者派生类" class="headerlink" title="另一个泛型本身或者派生类"></a>另一个泛型本身或者派生类</h3><p><img src="/../../assets/image93-20231203171812-dlhua2g.png" alt="图形用户界面, 文本, 聊天或短信 描述已自动生成"></p>
<p>Test4继承了Ifly接口，Ifly接口继承了U</p>
<p><img src="/../../assets/image94-20231203171812-mjc3kje.png"></p>
<h3 id="约束的组合使用"><a href="#约束的组合使用" class="headerlink" title="约束的组合使用"></a>约束的组合使用</h3><p>需要先判断是否能够组合使用</p>
<p><img src="/../../assets/image95-20231203171812-pe220cw.png" alt="图形用户界面, 应用程序 描述已自动生成"></p>
<h3 id="多个泛型分别添加约束"><a href="#多个泛型分别添加约束" class="headerlink" title="多个泛型分别添加约束"></a>多个泛型分别添加约束</h3><p><img src="/../../assets/image96-20231203171812-g6sxh0y.png" alt="文本 描述已自动生成"></p>
<h2 id="泛型数据结构类"><a href="#泛型数据结构类" class="headerlink" title="泛型数据结构类"></a>泛型数据结构类</h2><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p><img src="/../../assets/image97-20231203171812-tfxpnwb.png"> <img src="/../../assets/image98-20231203171812-cu6pzys.png" alt="文本 描述已自动生成"></p>
<h3 id="增-3"><a href="#增-3" class="headerlink" title="增"></a>增</h3><p>和arraylist语法一致</p>
<p><img src="/../../assets/image99-20231203171812-32qjo49.png" alt="文本 描述已自动生成"></p>
<p><img src="/../../assets/image100-20231203171812-rl57oqs.png" alt="图形用户界面, 文本 描述已自动生成"></p>
<h3 id="删-2"><a href="#删-2" class="headerlink" title="删"></a>删</h3><p><img src="/../../assets/image101-20231203171812-3ic7o7s.png"></p>
<h3 id="查-3"><a href="#查-3" class="headerlink" title="查"></a>查</h3><p><img src="/../../assets/image102-20231203171812-pziolh5.png" alt="文本 描述已自动生成"></p>
<h3 id="改-3"><a href="#改-3" class="headerlink" title="改"></a>改</h3><p><img src="/../../assets/image103-20231203171812-edq5b5i.png" alt="图形用户界面, 文本 描述已自动生成"></p>
<h3 id="遍历-3"><a href="#遍历-3" class="headerlink" title="遍历"></a>遍历</h3><p><img src="/../../assets/image104-20231203171812-exjjn38.png"></p>
<h2 id="字典（dictionary）"><a href="#字典（dictionary）" class="headerlink" title="字典（dictionary）"></a>字典（dictionary）</h2><p>可以理解为是一个泛型的哈希表</p>
<p><img src="/../../assets/image105-20231203171812-9nh8kgj.png" alt="文本 低可信度描述已自动生成"></p>
<p>自定义键和值的类型</p>
<p><img src="/../../assets/image106-20231203171812-1uv2lm6.png" alt="图形用户界面, 文本, 应用程序, 网站 描述已自动生成"></p>
<h3 id="增-4"><a href="#增-4" class="headerlink" title="增"></a>增</h3><p>不能出现相同键</p>
<p><img src="/../../assets/image107-20231203171812-ks0hnwt.png" alt="图片包含 文本 描述已自动生成"></p>
<h3 id="删-3"><a href="#删-3" class="headerlink" title="删"></a>删</h3><p><img src="/../../assets/image108-20231203171812-u4yy5uv.png" alt="文本 描述已自动生成"></p>
<h3 id="查-4"><a href="#查-4" class="headerlink" title="查"></a>查</h3><p><img src="/../../assets/image109-20231203171812-flmgks8.png"></p>
<h3 id="改-4"><a href="#改-4" class="headerlink" title="改"></a>改</h3><p><img src="/../../assets/image110-20231203171812-sx8bfss.png" alt="图形用户界面, 文本 描述已自动生成"></p>
<h3 id="遍历-4"><a href="#遍历-4" class="headerlink" title="遍历"></a>遍历</h3><p>‍</p>
<p><img src="/../../assets/image111-20231203171812-gxmu11m.png">​</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>实现单向链表</p>
<p><img src="/../../assets/image112-20231203171812-kkqd4wv.png"></p>
<p>用类封装链表和创建方法</p>
<p>因为类是引用类型，所以可以当作指针来用</p>
<p><img src="/../../assets/image113-20231203171812-a9rx4yh.png"></p>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><img src="/../../assets/image114-20231203171812-lynscx4.png"></p>
<p><img src="/../../assets/image115-20231203171812-x4mxmp5.png"></p>
<h3 id="增-5"><a href="#增-5" class="headerlink" title="增"></a>增</h3><p><img src="/../../assets/image116-20231203171812-k3g15z1.png" alt="文本 描述已自动生成"></p>
<p><img src="/../../assets/image117-20231203171812-8jveern.png"></p>
<h3 id="删-4"><a href="#删-4" class="headerlink" title="删"></a>删</h3><p><img src="/../../assets/image118-20231203171812-ine49e5.png" alt="文本 描述已自动生成"></p>
<h3 id="查-5"><a href="#查-5" class="headerlink" title="查"></a>查</h3><p><img src="/../../assets/image119-20231203171812-725ke41.png"></p>
<p><img src="/../../assets/image120-20231203171812-dw8z8jz.png"></p>
<h3 id="改-5"><a href="#改-5" class="headerlink" title="改"></a>改</h3><p><img src="/../../assets/image121-20231203171812-gjk4d7b.png" alt="文本 描述已自动生成"></p>
<h3 id="遍历-5"><a href="#遍历-5" class="headerlink" title="遍历"></a>遍历</h3><p><img src="/../../assets/image122-20231203171812-8kzkm7g.png" alt="图形用户界面, 文本 描述已自动生成"></p>
<p><img src="/../../assets/image123-20231203171812-gdz767t.png" alt="文本 描述已自动生成"></p>
<h2 id="泛型栈和队列"><a href="#泛型栈和队列" class="headerlink" title="泛型栈和队列"></a>泛型栈和队列</h2><p><img src="/../../assets/image124-20231203171812-h6irddk.png" alt="文本 描述已自动生成"></p>
<p><img src="/../../assets/image125-20231203171812-wgf968f.png" alt="文本 描述已自动生成"></p>
<p>泛型数据集合使用较多</p>
<p>泛型栈和队列</p>
<p><img src="/../../assets/image126-20231203171812-2ximl7u.png" alt="图示 描述已自动生成"></p>
<p>申明</p>
<p><img src="/../../assets/image127-20231203171812-sxql1ld.png"></p>
<p>增删查改遍历和普通的一样</p>
<h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><h2 id="委托的用处和语法"><a href="#委托的用处和语法" class="headerlink" title="委托的用处和语法"></a>委托的用处和语法</h2><p><img src="/../../assets/image128-20231203171812-fqjabe6.png"></p>
<p><img src="/../../assets/image129-20231203171812-0xb4mxb.png" alt="文本 描述已自动生成"></p>
<p><img src="/../../assets/image130-20231203171812-8jzs1q0.png" alt="文本 描述已自动生成"></p>
<p>使用前，我们先定义一个无返回值，无参数的函数</p>
<p><img src="/../../assets/image131-20231203171812-s4r8coh.png"></p>
<p>然后传入函数名，将函数装在委托里，委托的申明和类一样，</p>
<p><img src="/../../assets/image132-20231203171812-c3bgu0y.png"></p>
<p>这样，我们可以<strong>使用委托来调用函数方法</strong></p>
<p>使用方式：</p>
<p><img src="/../../assets/image133-20231203171812-9t9gr8z.png"> 第一种方式</p>
<p><img src="/../../assets/image134-20231203171812-y0idwi3.png"> 第二种方式</p>
<p><img src="/../../assets/image135-20231203171812-47vdyp3.png" alt="文本 描述已自动生成"></p>
<p><img src="/../../assets/image136-20231203171812-xvtva39.png" alt="文本 描述已自动生成"></p>
<p><img src="/../../assets/image137-20231203171812-8dlrlu5.png" alt="文本 描述已自动生成"></p>
<h2 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a><strong>多播委托</strong></h2><p><img src="/../../assets/image138-20231203171812-2jbk3bm.png" alt="文本 描述已自动生成"> <img src="/../../assets/image139-20231203171812-28iwec7.png" alt="文本 描述已自动生成"></p>
<p>此时用委托存储一个Fun函数，再用+=可以实现存储两个ff函数，使用ff（）时，会执行两次Fun函数。</p>
<p>存谁+=谁，或者直接用加号</p>
<p><img src="/../../assets/image140-20231203171812-gzcefms.png"></p>
<p>移除指定元素是移除后被委托的指定元素。使用委托后，函数不会自动移除，可以手动null；</p>
<p>使用系统定义好的委托Action</p>
<p><img src="/../../assets/image141-20231203171812-nzf803f.png" alt="图形用户界面, 文本 描述已自动生成"></p>
<p><img src="/../../assets/image142-20231203171812-qkg5xs7.png" alt="文本 描述已自动生成"></p>
<p><img src="/../../assets/image143-20231203171812-rt88r7f.png" alt="手机屏幕的截图 描述已自动生成"></p>
<p>系统提供的泛型委托： Func&lt;T（指定返回值类型）&gt; 委托名 = 函数名</p>
<p>Func&lt;&gt;<strong>传入多个参数时，最后一个为返回值类型，前面的为传入参数类型</strong></p>
<p>系统提供的<strong>无参无返回值</strong>委托：Action</p>
<p>系统提供的<strong>有参无返回值</strong>委托：Action&lt;T（指定n个参数类型）&gt;</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><img src="/../../assets/image144-20231203171812-6i42neh.png"></p>
<p><img src="/../../assets/image145-20231203171812-o8jnsvk.png"></p>
<p><img src="/../../assets/image146-20231203171812-7t3dheo.png"></p>
<p><img src="/../../assets/image147-20231203171812-74s3k48.png"></p>
<p><img src="/../../assets/image148-20231203171812-ctd28n2.png"></p>
<p><img src="/../../assets/image149-20231203171812-brwdp35.png"></p>
<p><img src="/../../assets/image150-20231203171812-4yvb2dk.png" alt="文本 描述已自动生成"></p>
<p><img src="/../../assets/image151-20231203171812-y2oc9wi.png"></p>
<h4 id="C-中的事件（委托的发布和订阅、事件的发布和订阅、EventHandler类、Windows事件）"><a href="#C-中的事件（委托的发布和订阅、事件的发布和订阅、EventHandler类、Windows事件）" class="headerlink" title="C#中的事件（委托的发布和订阅、事件的发布和订阅、EventHandler类、Windows事件）"></a>C#中的事件（委托的发布和订阅、事件的发布和订阅、EventHandler类、Windows事件）</h4><p><a target="_blank" rel="noopener" href="https://wenchm.blog.csdn.net/article/details/134553445?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~Ctr-1-134553445-blog-80916020.235%5Ev43%5Epc_blog_bottom_relevance_base2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~Ctr-1-134553445-blog-80916020.235%5Ev43%5Epc_blog_bottom_relevance_base2&amp;utm_relevant_index=2">C#中的事件（委托的发布和订阅、事件的发布和订阅、EventHandler类、Windows事件）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/cdaniu/p/15382744.html">C# 事件Event（个人整理）</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/VvxT/archive/2011/01/06/1929216.html">C# 浅谈事件监听及任务处理（监听属性值的改变及定时执行任务）</a></p>
<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><h2 id="匿名函数语法和用处"><a href="#匿名函数语法和用处" class="headerlink" title="匿名函数语法和用处"></a>匿名函数语法和用处</h2><p><img src="/../../assets/image152-20231203171812-i81u0co.png" alt="图片包含 文本 描述已自动生成"></p>
<p><img src="/../../assets/image153-20231203171812-a0c45e8.png" alt="文本 描述已自动生成"></p>
<p>匿名函数不能脱离委托或者事件</p>
<p><img src="/../../assets/image154-20231203171812-v1ixhjf.png"></p>
<p><img src="/../../assets/image155-20231203171812-gohcl9v.png" alt="图形用户界面, 文本, 应用程序 描述已自动生成"></p>
<p>使用匿名函数：</p>
<p>在类里使用的话，就用使用委托，为委托赋值一个匿名函数。因为事件不能在类里声明。</p>
<p><img src="/../../assets/image-20240417214039-pxvm13z.png" alt="image">​</p>
<p><img src="/../../assets/image-20240417234411-jzip4ql.png" alt="image">​</p>
<p><img src="/../../assets/image-20240417235308-2mi7xi7.png" alt="image">​</p>
<p><img src="/../../assets/image-20240418214432-42utlab.png" alt="image">​</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//无参无返回</span></span><br><span class="line">         Action func1 = <span class="built_in">delegate</span> ()</span><br><span class="line">           {</span><br><span class="line"></span><br><span class="line">           };</span><br><span class="line">         <span class="comment">//有参无返回</span></span><br><span class="line">         Action&lt;<span class="built_in">int</span>&gt; func2 = <span class="built_in">delegate</span> (<span class="built_in">int</span> i)</span><br><span class="line">         {</span><br><span class="line">         </span><br><span class="line">         };</span><br><span class="line">         <span class="comment">//有返回值</span></span><br><span class="line">         Func&lt;<span class="built_in">string</span>&gt; func3 = <span class="built_in">delegate</span> () {</span><br><span class="line">             <span class="keyword">return</span> <span class="string">"111"</span>;</span><br><span class="line">         };</span><br><span class="line">         <span class="comment">//有参有返回值</span></span><br><span class="line">         <span class="comment">//&lt;&gt;里只有最后一个参数为返回值，前面的都为传入参数          </span></span><br><span class="line">         Func&lt;<span class="built_in">string</span>, <span class="built_in">int</span>,<span class="built_in">string</span>&gt; fun4 = <span class="built_in">delegate</span> (<span class="built_in">string</span> a,<span class="built_in">int</span> b) {</span><br><span class="line">             <span class="keyword">return</span> <span class="string">"11"</span>;</span><br><span class="line">         };</span><br></pre></td></tr></tbody></table></figure>

<pre><code>一般匿名函数可作为参数传递，没学匿名函数之前，我们是先声明一个函数，再将函数名传递进去作为参数，现在我们可以直接写一个匿名函数直接传参。
</code></pre>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//声明一个测试类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title">Test</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//委托，存储方法</span></span><br><span class="line">            <span class="keyword">public</span> Action action;</span><br><span class="line">			<span class="comment">//函数作为参数的方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dosomething</span>(<span class="params"><span class="built_in">int</span> a,Action action</span>)</span></span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(a);</span><br><span class="line">                <span class="comment">//执行委托里的函数</span></span><br><span class="line">                action();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"><span class="comment">//匿名函数作为参数传入</span></span><br><span class="line"> 			Test test = <span class="keyword">new</span> Test();</span><br><span class="line">            test.Dosomething(<span class="number">10</span>, <span class="built_in">delegate</span> ()</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(<span class="string">"随参数传入的匿名函数逻辑"</span>);</span><br><span class="line">            });</span><br></pre></td></tr></tbody></table></figure>

<pre><code>匿名函数还可以作为返回值返回给委托储存
</code></pre>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test2</span></span><br><span class="line">      {</span><br><span class="line">	<span class="comment">//返回值为函数的方法</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> Action <span class="title">GetFunc</span>()</span></span><br><span class="line">          {</span><br><span class="line">              <span class="keyword">return</span> <span class="built_in">delegate</span> () {</span><br><span class="line">                  <span class="comment">//作为返回值的匿名函数逻辑</span></span><br><span class="line">              };</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line"><span class="comment">//使用方法：</span></span><br><span class="line">Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">Action action = test2.GetFunc();</span><br><span class="line">action();</span><br><span class="line"><span class="comment">//一步到位</span></span><br><span class="line">    Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">          test2.GetFunc()();</span><br></pre></td></tr></tbody></table></figure>

<h2 id="匿名函数缺点："><a href="#匿名函数缺点：" class="headerlink" title="匿名函数缺点："></a>匿名函数缺点：</h2><p>委托可以多播委托，当我们传入多个函数给委托时，传入的匿名函数无法被指定清除，要想清除只能用清空方法</p>
<p><img src="/../../assets/image-20240418221827-irft2py.png" alt="image">​</p>
<p><img src="/../../assets/image-20240418222510-q9rcrtt.png" alt="image">​</p>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><h2 id="回调函数的理解"><a href="#回调函数的理解" class="headerlink" title="回调函数的理解"></a>回调函数的理解</h2><pre><code>字面上的理解，回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。

其实很好理解，回调，回调，就是回头调用的意思。主函数的事先干完，回头再调用传进来的那个函数。

使用回调函数有两种写法，使用委托或者事件。
</code></pre>
<h2 id="回调函数的使用"><a href="#回调函数的使用" class="headerlink" title="回调函数的使用"></a>回调函数的使用</h2><figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//使用委托实现回调函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 定义一个委托</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CallbackDelegate</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法1：执行某个任务并接受回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoWork</span>(<span class="params">CallbackDelegate callback</span>)</span></span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">"执行任务..."</span>);</span><br><span class="line">        <span class="comment">// 模拟任务完成后调用回调函数</span></span><br><span class="line">        callback(<span class="string">"任务完成！"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 定义一个回调函数</span></span><br><span class="line">        CallbackDelegate myCallback = (message) =&gt;</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(<span class="string">$"回调信息: <span class="subst">{message}</span>"</span>);</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">// 调用DoWork，并传递回调函数</span></span><br><span class="line">        DoWork(myCallback);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//使用事件实现回调函数</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 方法2：使用Action作为回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoWork</span>(<span class="params">Action&lt;<span class="built_in">string</span>&gt; callback</span>)</span></span><br><span class="line">    {</span><br><span class="line">        Console.WriteLine(<span class="string">"执行任务..."</span>);</span><br><span class="line">        callback(<span class="string">"任务完成！"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 使用Action传递回调</span></span><br><span class="line">        DoWork((message) =&gt;</span><br><span class="line">        {</span><br><span class="line">            Console.WriteLine(<span class="string">$"回调信息: <span class="subst">{message}</span>"</span>);</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h1 id="Lamda表达式"><a href="#Lamda表达式" class="headerlink" title="Lamda表达式"></a>Lamda表达式</h1><h3 id="什么是lamda表达式"><a href="#什么是lamda表达式" class="headerlink" title="什么是lamda表达式"></a>什么是lamda表达式</h3><p><img src="/../../assets/image-20240418222836-vbcvtox.png" alt="image"></p>
<h3 id="Lamda表达式语法"><a href="#Lamda表达式语法" class="headerlink" title="Lamda表达式语法"></a>Lamda表达式语法</h3><p><img src="/../../assets/image-20240418222930-622w1jx.png" alt="image">​</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p><img src="/../../assets/image-20240418223100-f2vcjba.png" alt="image">​</p>
<p><img src="/../../assets/image-20240418223257-d8t727p.png" alt="image">​</p>
<p><img src="/../../assets/image-20240418223418-dkmnhbr.png" alt="image">​</p>
<p><img src="/../../assets/image-20240418223614-zz88c1c.png" alt="image">、</p>
<p>缺点和匿名函数缺点一样</p>
<p><img src="/../../assets/image-20240418231103-5ufe8z1.png" alt="image">​</p>
<h3 id="闭包（重要）"><a href="#闭包（重要）" class="headerlink" title="闭包（重要）"></a>闭包（重要）</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/eventhorizon/p/9535289.html">	https://www.cnblogs.com/eventhorizon/p/9535289.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/pangjianxin/p/8400155.html">https://www.cnblogs.com/pangjianxin/p/8400155.html	</a>这个讲的比较好</p>
<pre><code>我们把在Lambda表达式(或匿名方法)中所引用的外部变量称为**捕获变量**。而捕获变量的表达式就称为**闭包**。

捕获的变量会在真正**调用委托**时“赋值”，而不是在捕获时“赋值”，即总是使用捕获变量的**最新的值**。
</code></pre>
<p><img src="/../../assets/image-20240418223807-g6892gn.png" alt="image">​</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Test3</span></span><br><span class="line">       {</span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">event</span> Action action;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="title">Test3</span>()</span></span><br><span class="line">           {</span><br><span class="line">               <span class="built_in">int</span> <span class="keyword">value</span> = <span class="number">10</span>;</span><br><span class="line">               <span class="comment">//这里就形成了闭包</span></span><br><span class="line">               <span class="comment">//因为当构造函数执行完毕时，其中申明的临时变量value的生命周期被改变了</span></span><br><span class="line">               <span class="comment">//因为当构造函数执行时，value就被存到事件函数action里，不会被释放</span></span><br><span class="line">               action = () =&gt; {</span><br><span class="line">                   Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line">               };</span><br><span class="line"></span><br><span class="line">               <span class="comment">//由于lamda表达式对临时变量i的捕获，延长了其生命周期</span></span><br><span class="line">               <span class="comment">//所以当for循环执行完时，事件action里存放的i的值都为10，可以用地址来理解</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">               {</span><br><span class="line">                   action += () =&gt;</span><br><span class="line">                   {</span><br><span class="line">                       Console.WriteLine(i);</span><br><span class="line">                   };</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br></pre></td></tr></tbody></table></figure>

<h1 id="List排序（重要）"><a href="#List排序（重要）" class="headerlink" title="List排序（重要）"></a>List排序（重要）</h1><h2 id="List自带排序方法"><a href="#List自带排序方法" class="headerlink" title="List自带排序方法"></a>List自带排序方法</h2><p>这个排序可以进行值类型（int、float）的排序</p>
<p>List之所以可以用Sort（）来进行排序，是因为List继承并实现了接口IComparable，Sort（）调用了C#帮我们实现的值类型比较接口。</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//创建列表对象</span></span><br><span class="line"><span class="comment">//可对int、float、double等值类型进行排序</span></span><br><span class="line">	List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">	list.Add(<span class="number">3</span>);</span><br><span class="line">	list.Add(<span class="number">5</span>);</span><br><span class="line">	list.Add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//自带排序</span></span><br><span class="line">	list.Sort();</span><br><span class="line"><span class="comment">//对float进行排序</span></span><br><span class="line">	List&lt;<span class="built_in">float</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">float</span>&gt;();</span><br><span class="line">    list.Add(<span class="number">1.4f</span>);</span><br><span class="line">    list.Add(<span class="number">1.23f</span>);</span><br><span class="line">    list.Add(<span class="number">2.11f</span>);</span><br><span class="line">    list.Sort();</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="自定义类的排序"><a href="#自定义类的排序" class="headerlink" title="自定义类的排序"></a>自定义类的排序</h2><pre><code>为了可以让自定义的类也可以进行排序， 我们要让自定义的类继承C#的IComparable&lt;&gt;泛型接口，并实现该接口。
</code></pre>
<p>这样使用Sort（）方法可以调用我们实现的接口方法。</p>
<p>‍</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//自定义类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Item</span> :<span class="title">IComparable</span>&lt;<span class="title">Item</span>&gt;	<span class="comment">//继承IComparable接口</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">string</span> name { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">float</span> money { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Item</span>(<span class="params"><span class="built_in">string</span> name,<span class="built_in">float</span> money</span>)</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">this</span>.name = name;</span><br><span class="line">                <span class="keyword">this</span>.money = money;</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">			<span class="comment">//实现接口包含的比较方法：</span></span><br><span class="line">			<span class="comment">//返回值为负数表示在前，为0表示位置不变，为1表示在后</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">CompareTo</span>(<span class="params">Item other</span>)</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.money&gt;other.money)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"><span class="comment">//调用List里的Sort()方法</span></span><br><span class="line">			List&lt;Item&gt; items = <span class="keyword">new</span> List&lt;Item&gt;();</span><br><span class="line"> 			items.Add(<span class="keyword">new</span> Item(<span class="string">"辣条"</span>,<span class="number">2.5f</span>));</span><br><span class="line">            items.Add(<span class="keyword">new</span> Item(<span class="string">"棒棒糖"</span>, <span class="number">1.5f</span>));</span><br><span class="line">            items.Add(<span class="keyword">new</span> Item(<span class="string">"巧克力"</span>,<span class="number">1.0f</span>));</span><br><span class="line">            items.Sort();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; items.Count; i++)</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(items[i].name + items[i].money);</span><br><span class="line">            }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h2 id="通过委托函数进行排序"><a href="#通过委托函数进行排序" class="headerlink" title="通过委托函数进行排序"></a>通过委托函数进行排序</h2><pre><code>List的Sort()方法有个委托重载，这可以让我们使用委托函数来进行排序。这样我们就可以传入函数了，这时我们可以使用匿名函数或者lamda表达式作为参数传入。甚至为了代码简洁，还能用到三目运算符。
</code></pre>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//定义自定义的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ShopItem</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> id;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">ShopItem</span>(<span class="params"><span class="built_in">int</span> id</span>)</span></span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">this</span>.id = id;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"><span class="comment">//使用lamda表达式进行排序</span></span><br><span class="line"> 			List&lt;ShopItem&gt; shopitem = <span class="keyword">new</span> List&lt;ShopItem&gt;();</span><br><span class="line">            shopitem.Add(<span class="keyword">new</span> ShopItem(<span class="number">1</span>));</span><br><span class="line">            shopitem.Add(<span class="keyword">new</span> ShopItem(<span class="number">4</span>));</span><br><span class="line">            shopitem.Add(<span class="keyword">new</span> ShopItem(<span class="number">3</span>));</span><br><span class="line">            shopitem.Add(<span class="keyword">new</span> ShopItem(<span class="number">2</span>));</span><br><span class="line">			<span class="comment">//sort有委托重载，所以可以传入lamda函数</span></span><br><span class="line">            shopitem.Sort((a, b) =&gt;</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (a.id&gt;b.id)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            Console.WriteLine(<span class="string">"**********"</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (ShopItem item <span class="keyword">in</span> shopitem)</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(item.id);</span><br><span class="line">            }</span><br><span class="line">			<span class="comment">//还可以写得更简单（使用三目运算符）：</span></span><br><span class="line">            shopitem.Sort((a, b) =&gt;</span><br><span class="line">            {</span><br><span class="line">				<span class="comment">//使用三目运算符</span></span><br><span class="line">               <span class="keyword">return</span> a.id &gt; b.id ? <span class="number">1</span> :<span class="number">-1</span>;</span><br><span class="line">            });</span><br></pre></td></tr></tbody></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>在实际开发中， 我们会经常用到List 的Sort排序，例如背包物品的排序，商店物品的排序等。
</code></pre>
<p><img src="/../../assets/image-20240419124414-dzq7vqd.png" alt="image"></p>
<p>‍</p>
<h1 id="协变逆变"><a href="#协变逆变" class="headerlink" title="协变逆变"></a>协变逆变</h1><p><img src="/../../assets/image-20240419194109-itx4xr4.png" alt="image">​</p>
<p>作用：</p>
<p><img src="/../../assets/image-20240419194412-x1hjgrq.png" alt="image">​</p>
<pre><code>协变和逆变的使用主要在委托的装载原则上。用out修饰的泛型委托，可以使用父类泛型委托装子类泛型委托。用in修饰的泛型委托，可以用子类泛型委托替代父类泛型委托。根据里氏替换原则，我们认为父类装子类是协和的，而子类装父类则有些违反我们的认知，所以叫协变和逆变。
</code></pre>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//2.结合里氏替换原则理解</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//out修饰T 只能作为返回值</span></span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> T <span class="title">Test_out</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt;()</span>;</span><br><span class="line">    <span class="comment">//In修饰T 只能作为传入参数</span></span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Test_in</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T t</span>)</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Father</span></span><br><span class="line">    {</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Son</span> : <span class="title">Father</span></span><br><span class="line">    {</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//测试：</span></span><br><span class="line">			<span class="comment">//1.协变：父类能替代子类</span></span><br><span class="line">			<span class="comment">//使用子类返回值委托</span></span><br><span class="line">            Test_out&lt;Son&gt; son = () =&gt;</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Son();</span><br><span class="line">            };</span><br><span class="line">			<span class="comment">//父类委托装子类委托</span></span><br><span class="line">			<span class="comment">//如果Test_out委托没有out修饰，就会报错</span></span><br><span class="line">            Test_out&lt;Father&gt; father= son;</span><br><span class="line"><span class="comment">//--------------------------------------</span></span><br><span class="line">			<span class="comment">//2.逆变：父类可以被子类替代</span></span><br><span class="line">			<span class="comment">//使用父类作为传入参数的委托</span></span><br><span class="line">			Test_in&lt;Father&gt; father = (<span class="keyword">value</span>) =&gt;</span><br><span class="line">            {</span><br><span class="line">            };</span><br><span class="line">			<span class="comment">//子类委托装父类委托</span></span><br><span class="line">			Test_in&lt;Son&gt; son = father;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../../assets/image-20240419202401-q550up6.png" alt="image">​</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p><img src="/../../assets/image-20240419202542-7q62e4x.png" alt="image">​</p>
<p><img src="/../../assets/image-20240419202612-vn4duqx.png" alt="image">​</p>
<h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p><img src="/../../assets/image-20240419202750-8kkocqe.png" alt="image">​</p>
<p><img src="/../../assets/image-20240419202848-w8qkfxu.png" alt="image">​</p>
<h2 id="什么是多线程"><a href="#什么是多线程" class="headerlink" title="什么是多线程"></a>什么是多线程</h2><p><img src="/../../assets/image-20240419202935-xwhjajz.png" alt="image"></p>
<p><img src="/../../assets/image-20240419202951-9xvpzm6.png" alt="image">​</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><img src="/../../assets/image-20240419203316-bi83pd5.png" alt="image"></p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//运行标识</span></span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">bool</span> isRuning=<span class="literal">true</span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//1.申明一个线程</span></span><br><span class="line">            <span class="comment">//将想要执行的函数作为参数传入</span></span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(NewThreadFunc);</span><br><span class="line">            <span class="comment">//2.起动线程</span></span><br><span class="line">            t.Start();</span><br><span class="line">            <span class="comment">//3.设置为后台线程</span></span><br><span class="line">            <span class="comment">//如果线程的逻辑为死循环，那么不设置为后台线程，则新开线程在主线程结束后不会结束</span></span><br><span class="line">            t.IsBackground = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//4.关闭释放一个线程</span></span><br><span class="line">            <span class="comment">// 如果是死循环，想要释放有两个方法</span></span><br><span class="line">                <span class="comment">//1.申明static bool isRunning=true;</span></span><br><span class="line">            <span class="comment">//将isRunning作为while的参数，设置isRunning=false，关闭线程</span></span><br><span class="line">            isRuning = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//2.使用线程自带方法(在.net core无法使用该方法)</span></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            {</span><br><span class="line">                t.Abort();</span><br><span class="line">                t = <span class="literal">null</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">catch</span> (Exception)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">throw</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//封装线程执行的逻辑</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewThreadFunc</span>()</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//5.线程休眠</span></span><br><span class="line">            <span class="comment">//毫秒为单位，在哪个线程里写，就让哪个线程休眠几秒</span></span><br><span class="line">            Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="comment">//线程执行的死循环逻辑，可以不是死循环</span></span><br><span class="line">            <span class="keyword">while</span> (isRuning)</span><br><span class="line">            {</span><br><span class="line">                Console.WriteLine(<span class="string">"线程逻辑"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="线程之间的共享数据（重要）​"><a href="#线程之间的共享数据（重要）​" class="headerlink" title="线程之间的共享数据（重要）​"></a>线程之间的共享数据（重要）<img src="/../../assets/image-20240419210629-dj4fgxw.png" alt="image">​</h2><pre><code>lock解决了当多个线程访问同一个内存的东西时，会导致的逻辑执行顺序问题。这是一种解决方案，但并不是最优解，想要更好的性能优化可以了解其他锁。
</code></pre>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//运行标识</span></span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">bool</span> isRuning=<span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//申明一个引用类型，供lock使用</span></span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">object</span> obj;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] <span class="keyword">args</span></span>)</span></span><br><span class="line">        {</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(NewThreadFunc);</span><br><span class="line">            t.Start();</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//使用加锁，参数为引用类型</span></span><br><span class="line">                <span class="comment">//意思是，当obj没被锁的时候，就会锁住obj，执行代码</span></span><br><span class="line">                <span class="comment">//执行完会解锁</span></span><br><span class="line">                <span class="keyword">lock</span> (obj)</span><br><span class="line">                {</span><br><span class="line">                    Console.WriteLine(<span class="string">"hello"</span>);</span><br><span class="line">                }</span><br><span class="line">            </span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//封装线程执行的逻辑</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">NewThreadFunc</span>()</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">while</span> (isRuning)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//使用加锁，参数为引用类型</span></span><br><span class="line">                <span class="comment">//意思是，当obj没被锁的时候，就会锁住obj，执行代码</span></span><br><span class="line">                <span class="comment">//执行完会解锁</span></span><br><span class="line">                <span class="keyword">lock</span> (obj)</span><br><span class="line">                {</span><br><span class="line">                    Console.WriteLine(<span class="string">"线程逻辑"</span>);</span><br><span class="line">                }</span><br><span class="line">            </span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="多线程的意义"><a href="#多线程的意义" class="headerlink" title="多线程的意义"></a>多线程的意义</h2><pre><code>当我们进行一些特别复杂的逻辑时，可能会导致卡顿，所以我们可以开一个线程来进行复杂的运算，从而让主线程可以流程运行。
</code></pre>
<p><img src="/../../assets/image-20240419211732-k2ogczb.png" alt="image"></p>
<p><img src="/../../assets/image-20240419212034-ah7260n.png" alt="image">​</p>
<h1 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h1><p><img src="/../../assets/image-20240419221222-dct5x85.png" alt="image">​</p>
<p><img src="/../../assets/image-20240419221242-pq4rxko.png" alt="image">​</p>
<p><img src="/../../assets/image-20240419221339-2xvu6w4.png" alt="image">​</p>
<p><img src="/../../assets/image-20240419221757-dusnt18.png" alt="image"></p>
<p><img src="/../../assets/image-20240419222055-zafsmoe.png" alt="image">​</p>
<p><img src="/../../assets/image-20240419222218-3las1xt.png" alt="image"></p>
<p><img src="/../../assets/image-20240419222229-f1wp6xd.png" alt="image">​</p>
<p><img src="/../../assets/image-20240419222327-pc6892j.png" alt="image">​</p>
<h1 id="反射和特性"><a href="#反射和特性" class="headerlink" title="反射和特性"></a>反射和特性</h1><h2 id="什么是程序集"><a href="#什么是程序集" class="headerlink" title="什么是程序集"></a>什么是程序集</h2><p><img src="/../../assets/image-20240420085722-vsjz5f6.png" alt="image">​</p>
<p><img src="/../../assets/image-20240420085856-cvsgekl.png" alt="image">​</p>
<p><img src="/../../assets/image-20240420090000-89tu8lq.png" alt="image">​</p>
<p><img src="/../../assets/image-20240420091009-x8k537a.png" alt="image">​</p>
<p><img src="/../../assets/image-20240420091307-sdd7hql.png" alt="image"></p>
<p><img src="/../../assets/image-20240420091617-hqr5izv.png" alt="image">​</p>
<p>‍</p>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p><img src="/../../assets/image-20240420103612-bkiya5b.png" alt="image">​</p>
<p><img src="/../../assets/image-20240420105319-gyj2vvh.png" alt="image">​</p>
<p><img src="/../../assets/image-20240420104605-kjt2ge0.png" alt="image">​</p>
<p><img src="/../../assets/image-20240420104757-uv4eik0.png" alt="image">​</p>
<p><img src="/../../assets/image-20240420105243-dr8j6f4.png" alt="image">​</p>
<p>‍</p>
<p>‍</p>
<p>‍</p>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="什么是LinQ？用来干什么？"><a href="#什么是LinQ？用来干什么？" class="headerlink" title="什么是LinQ？用来干什么？"></a>什么是LinQ？用来干什么？</h2><pre><code>LINQ（Language Integrated Query）是一种C#语言中的**查询技术**，它允许我们在代码中使用**类似SQL的查询语句来操作各种数据源**。这些数据源可以是集合、数组、数据库、XML文档等等。LINQ提供了一种统一的编程模型，使我们能够使用相同的方式来查询和操作不同类型的数据。

比如我们可以用LinQ来操作SQL server数据库。除此之外，我们还可以操作数组、枚举集合、泛型列表等。
</code></pre>
<h2 id="C-中的LINQ语法"><a href="#C-中的LINQ语法" class="headerlink" title="C#中的LINQ语法"></a>C#中的LINQ语法</h2><h3 id="使用-LINQ（Language-Integrated-Query）语法在-C-中进行查询操作"><a href="#使用-LINQ（Language-Integrated-Query）语法在-C-中进行查询操作" class="headerlink" title="使用 LINQ（Language-Integrated Query）语法在 C# 中进行查询操作"></a>使用 LINQ（Language-Integrated Query）语法在 C# 中进行查询操作</h3><p>‍</p>
<p>文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lgj123xj/article/details/134008760">C# Linq基本功 —— 必学的必熟的10个方法</a></p>
<p>‍</p>
<h4 id="1-检索List列表中装载的对象的属性"><a href="#1-检索List列表中装载的对象的属性" class="headerlink" title="1.检索List列表中装载的对象的属性"></a>1.检索List列表中装载的对象的属性</h4><pre><code>我们知道，当我们用List类对象装载了一个类的多个对象时，我们不能通过直接List类对象名点出来他包含的类对象的属性，只能通过Foreach循环来通过索引器来遍历。LINQ中的=&gt;语法可以让我们直接通过List类对象直接对其包含的类对象的属性进行检索。  
</code></pre>
<p>例：</p>
<figure class="highlight c#"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Paper</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span> String PaperName { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line"><span class="comment">//  public List&lt;Question&gt; paper = new List&lt;Question&gt;();</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Content { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Score { <span class="keyword">get</span>; <span class="keyword">set</span>; }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Paper&gt; Papers = <span class="keyword">new</span> List&lt;Paper&gt;();</span><br><span class="line"><span class="comment">//假设Papers中已经添加了多个Paper对象，我们可以通过以下方法来检索Paper属性，筛选出来满足条件的对象。</span></span><br><span class="line">Paper f = Papers.Find(Papers=&gt;Papers.PaperName==“检索内容”);</span><br></pre></td></tr></tbody></table></figure>

<h1 id="C-面试题"><a href="#C-面试题" class="headerlink" title="C#面试题"></a>C#面试题</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/anding/p/5229756.html">.NET面试题解析(00)-开篇来谈谈面试 &amp; 系列文章索引</a></p>
<p>‍</p>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Csharp/">Csharp</a><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a></div><div class="post-share"><div class="social-share" data-image="https://t.alcy.cc/lai?62" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/05/26/Unity/Unity%E4%BD%BF%E7%94%A8Luban+LitJson%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0Excel%E8%BD%ACJson%EF%BC%8CXml%E7%AD%89%E5%B9%B6%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%8F%96%E3%80%82/" title="Unity使用Luban+LitJson插件实现Excel转Json，Xml等并进行读取。"><img class="cover" src="https://t.alcy.cc/xhl?8537" onerror="onerror=null;src='/assets/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Unity使用Luban+LitJson插件实现Excel转Json，Xml等并进行读取。</div></div><div class="info-2"><div class="info-item-1">配置Luban环境并创建Unity项目Luban官方文档  安装dotnet sdk 8.0或更高版本sdk。（根据自己的系统下载对应的sdk。我的是windows所以我用的Windows x64版本）  下载luban_examples项目。（Gitee需要登陆才能下载，如果不想登录可以去Github下载。这里放上Luban的Github链接：https://github.com/focus-creative-games/luban_examples）    下载完成后我们新建一个Unity项目，准备将Luban部署到Unity项目里。 创建好Unity项目后，打开Unity项目目录创建一个  LubanConfig ​ 。然后将我们下载的Luban插件里 Tools/Luban​ 和 MiniTemplate​ 文件夹放进去。   接下来我们打开刚刚放进 LubanConfig/MiniTemplate​...</div></div></div></a><a class="pagination-related" href="/2025/06/01/Japanese/%E6%97%A5%E8%AF%AD%E5%AD%A6%E6%A0%A1%E8%AF%AD%E6%B3%95%E4%BD%93%E7%B3%BB%E4%B8%8E%E6%95%99%E8%82%B2%E8%AF%AD%E6%B3%95%E4%BD%93%E7%B3%BB/" title="（二）日语学校语法体系与教育语法体系"><img class="cover" src="https://t.alcy.cc/moe?8228" onerror="onerror=null;src='/assets/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">（二）日语学校语法体系与教育语法体系</div></div><div class="info-2"><div class="info-item-1">一、单词（単語） （単語是单词的日语原文，为方便读者以后进阶学习，这里涉及到的概念都会给出日语原文，下同。） 单词是把句子进行分解后可以得到的最小的有意义的单位，是句子里可以自由运用的最小单位。 二、句节（文節） 在不影响对句子的意义的理解下，尽可能地把句子划分成最小的段落，这种段落叫做“句节”。  例：太郎と / 二郎が / ボールを/ 投げて/  いる。（五个句节） 三、学校语法的词类划分：（独立词与附属词）详细请看日语里的词类划分 ​ ‍ 四、用语对照 动词形容词分类： ​ 活用形对比： ​ 学校语法的动词活用：未然形，连用形，终止形，连体形，假定形，命令形和推量形。 教育语法的动词活用：ます形、ない形，て形，辞书形，ない形，意向形，命令形，ば形等。 </div></div></div></a></nav><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/assets/icon.jpg" onerror="this.onerror=null;this.src='/assets/friend_404.gif'" alt="avatar"></div><div class="author-info-name">Ayami</div><div class="author-info-description">记录生活，记录技术。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">24</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ayami22"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/ayami22" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:a205525075@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=205525075&amp;website=www.oicqzone.com" target="_blank" title=""><i class="fa-brands fa-qq"></i></a><a class="social-icon" href="https://space.bilibili.com/313552137" target="_blank" title=""><i class="fa-brands fa-bilibili"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到Ayami的博客。 这里会整理存放一些我的学习笔记。 由于使用的Vercel Twikoo，需要魔法才能显示评论区进行评论。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C%EF%BC%9A"><span class="toc-number">1.</span> <span class="toc-text">学习手册：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.</span> <span class="toc-text">枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E6%9E%9A%E4%B8%BE%E7%9A%84%E7%94%B3%E6%98%8E"><span class="toc-number">2.1.</span> <span class="toc-text">（1）枚举的申明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E6%9E%9A%E4%B8%BE%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%B3%E6%98%8E%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">（2）枚举变量的申明初始化和使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%BD%AC%E6%8D%A2%EF%BC%88%E6%98%BE%E9%9A%90%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">变量的类型及转换（显隐转换）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.0.1.</span> <span class="toc-text">变量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.0.2.</span> <span class="toc-text">括号转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Parse%E6%B3%95-%EF%BC%88%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%9B%B8%E5%BA%94%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">3.0.3.</span> <span class="toc-text">Parse法 （把字符串类型转换为相应的类型）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Convert%E6%B3%95%EF%BC%88%E6%9B%B4%E5%87%86%E7%A1%AE%E5%9C%B0%E5%B0%86%E5%90%84%E4%B8%AA%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E8%BF%9B%E8%A1%8C%E8%BD%AC%E6%8D%A2%EF%BC%89"><span class="toc-number">3.0.4.</span> <span class="toc-text">Convert法（更准确地将各个类型之间进行转换）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B1%BB%E5%9E%8B%E8%BD%ACstring"><span class="toc-number">3.0.5.</span> <span class="toc-text">其他类型转string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E6%95%B0%E7%BB%84%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.0.6.</span> <span class="toc-text">数组与数组之间的转换</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7"><span class="toc-number">4.</span> <span class="toc-text">异常捕获</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%EF%BC%88%E9%9D%9E%E6%89%93%E5%8D%B0%E6%8B%BC%E6%8E%A5%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">字符串拼接（非打印拼接）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%94%A8%EF%BC%8B%E5%8F%B7%E6%8B%BC%E6%8E%A5"><span class="toc-number">5.0.1.</span> <span class="toc-text">1.字符串用＋号拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%A0%E4%BD%8D%E6%8B%BC%E6%8E%A5"><span class="toc-number">5.0.2.</span> <span class="toc-text">2.字符串占位拼接</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.</span> <span class="toc-text">位运算符和三目运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.0.1.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.0.2.</span> <span class="toc-text">三目运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">7.</span> <span class="toc-text">C#中的数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">7.1.</span> <span class="toc-text">一维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">7.2.</span> <span class="toc-text">二维数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%EF%BC%88%E7%9B%B8%E5%BD%93%E4%BA%8Ec%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%92%8C%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">值和引用（相当于c语言中的指针和值类型）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8Bstring"><span class="toc-number">9.</span> <span class="toc-text">特殊的引用类型string</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">10.</span> <span class="toc-text">深拷贝和浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E8%AF%A6%E8%A7%A3"><span class="toc-number">10.1.</span> <span class="toc-text">深拷贝和浅拷贝详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E6%88%96%E6%95%B0%E6%8D%AE%E9%9B%86%E5%90%88%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">10.2.</span> <span class="toc-text">C#实现自定义对象或数据集合的深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">10.2.1.</span> <span class="toc-text">1.使用序列化和反序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8Newtonsoft-Json"><span class="toc-number">10.2.2.</span> <span class="toc-text">2.使用Newtonsoft.Json</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref%E5%92%8Cout%EF%BC%88%E7%94%A8%E4%BA%8E%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82%E7%9A%84%E4%BC%A0%E9%80%92%EF%BC%89"><span class="toc-number">10.2.3.</span> <span class="toc-text">ref和out（用于函数形参和实参的传递）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E5%92%8C%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%EF%BC%9A"><span class="toc-number">10.2.4.</span> <span class="toc-text">变长和参数默认值：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0%EF%BC%88%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%EF%BC%89"><span class="toc-number">10.2.4.1.</span> <span class="toc-text">变长参数（可变参数）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC%EF%BC%88%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0%EF%BC%89"><span class="toc-number">10.2.4.2.</span> <span class="toc-text">参数默认值（可选参数）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">10.2.5.</span> <span class="toc-text">函数重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.6.</span> <span class="toc-text">递归函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">11.</span> <span class="toc-text">C#结构体</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">12.1.</span> <span class="toc-text">冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4"><span class="toc-number">12.1.1.</span> <span class="toc-text">算法步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">12.1.2.</span> <span class="toc-text">原理说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">12.1.3.</span> <span class="toc-text">循环结构说明：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E5%B1%82%E5%BE%AA%E7%8E%AF%EF%BC%9A%E6%8E%A7%E5%88%B6%E2%80%9C%E8%BD%AE%E6%95%B0%E2%80%9D"><span class="toc-number">12.1.3.1.</span> <span class="toc-text">外层循环：控制“轮数”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%B1%82%E5%BE%AA%E7%8E%AF%EF%BC%9A%E6%AF%8F%E8%BD%AE%E4%B8%AD%E7%9A%84%E2%80%9C%E4%B8%A4%E4%B8%A4%E6%AF%94%E8%BE%83%E2%80%9D"><span class="toc-number">12.1.3.2.</span> <span class="toc-text">内层循环：每轮中的“两两比较”</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%AE%9E%E7%8E%B0%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="toc-number">12.1.4.</span> <span class="toc-text">C#实现冒泡排序：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">12.1.5.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">12.2.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">12.2.1.</span> <span class="toc-text">什么是选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">12.2.2.</span> <span class="toc-text">算法步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.2.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-1"><span class="toc-number">12.2.4.</span> <span class="toc-text">优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="toc-number">13.</span> <span class="toc-text">面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%EF%BC%88%E7%B1%BB%EF%BC%89%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.1.</span> <span class="toc-text">类和（类）对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB"><span class="toc-number">13.1.1.</span> <span class="toc-text">什么是类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">13.1.2.</span> <span class="toc-text">类的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%A3%B0%E6%98%8E%E5%AE%9E%E4%BE%8B"><span class="toc-number">13.1.3.</span> <span class="toc-text">类声明实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E7%B1%BB%EF%BC%89%E5%AF%B9%E8%B1%A1"><span class="toc-number">13.1.4.</span> <span class="toc-text">（类）对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%B3%E6%98%8E%EF%BC%9A"><span class="toc-number">13.1.5.</span> <span class="toc-text">对象的申明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">13.1.6.</span> <span class="toc-text">实例化对象：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">13.2.</span> <span class="toc-text">成员变量和访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%9A"><span class="toc-number">13.2.1.</span> <span class="toc-text">C#访问修饰符：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E9%87%8C%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%9A"><span class="toc-number">13.2.2.</span> <span class="toc-text">类里的成员变量：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89%EF%BC%9A"><span class="toc-number">13.3.</span> <span class="toc-text">成员方法（函数）：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E5%88%9D%E5%A7%8B%E5%8C%96%E8%B0%83%E7%94%A8%EF%BC%89%E3%80%81%E6%9E%90%E6%9E%84%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">13.4.</span> <span class="toc-text">构造函数（初始化调用）、析构、垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">13.4.1.</span> <span class="toc-text">构造函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%90%E6%9E%84"><span class="toc-number">13.4.2.</span> <span class="toc-text">析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%88Garbage-collector%EF%BC%89"><span class="toc-number">13.4.3.</span> <span class="toc-text">垃圾回收机制（Garbage collector）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7%EF%BC%88%E5%8C%85%E8%A3%B9%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%89"><span class="toc-number">13.5.</span> <span class="toc-text">成员属性（包裹成员变量）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">13.6.</span> <span class="toc-text">自动属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%99%A8"><span class="toc-number">13.7.</span> <span class="toc-text">索引器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%EF%BC%9A"><span class="toc-number">13.7.1.</span> <span class="toc-text">语法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F%E4%B8%80%E7%B4%A2%E5%BC%95%E5%99%A8%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="toc-number">13.7.2.</span> <span class="toc-text">声明方式一索引器使用举例：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F%E4%BA%8C%E7%B4%A2%E5%BC%95%E5%99%A8%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="toc-number">13.7.3.</span> <span class="toc-text">声明方式二索引器举例：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">13.8.</span> <span class="toc-text">静态成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E5%92%8C-static-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.8.1.</span> <span class="toc-text">const 和 static 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%B8%8D%E5%AE%89%E5%85%A8%E7%A4%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">13.8.2.</span> <span class="toc-text">静态成员实现单例模式（不安全示例）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">13.8.3.</span> <span class="toc-text">线程安全的单例实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8-lock%E2%80%8B-%E5%8A%A0%E9%94%81%EF%BC%88%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%89"><span class="toc-number">13.8.3.1.</span> <span class="toc-text">方法一：使用 lock​ 加锁（懒汉式，线程安全）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">13.8.3.2.</span> <span class="toc-text">方法二：静态构造函数（饿汉式，线程安全，推荐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E4%BD%BF%E7%94%A8-Lazy%E2%80%8B%EF%BC%88%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E7%8E%B0%E4%BB%A3%E6%8E%A8%E8%8D%90%E6%96%B9%E5%BC%8F%EF%BC%89"><span class="toc-number">13.8.3.3.</span> <span class="toc-text">方法三：使用 Lazy&lt;T&gt;​（懒汉式，线程安全，现代推荐方式）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">13.9.</span> <span class="toc-text">静态类和静态构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%EF%BC%88static-class%E2%80%8B%EF%BC%89"><span class="toc-number">13.9.1.</span> <span class="toc-text">静态类（static class​）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%88static-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E2%80%8B%EF%BC%89"><span class="toc-number">13.9.2.</span> <span class="toc-text">静态构造函数（static 构造函数​）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">13.10.</span> <span class="toc-text">拓展方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">13.11.</span> <span class="toc-text">运算符重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">13.12.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">13.12.1.</span> <span class="toc-text">类的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">13.12.2.</span> <span class="toc-text">继承构造函数：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6%EF%BC%88object%EF%BC%89-%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="toc-number">14.</span> <span class="toc-text">万物之父（object）,装箱和拆箱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E8%A3%85%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-number">14.0.1.</span> <span class="toc-text">Object装引用类型：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="toc-number">14.0.1.1.</span> <span class="toc-text">装箱和拆箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">14.0.1.2.</span> <span class="toc-text">装箱的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%86%E7%AE%B1%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">14.0.1.3.</span> <span class="toc-text">拆箱的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9-2"><span class="toc-number">14.0.1.4.</span> <span class="toc-text">优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="toc-number">14.0.1.5.</span> <span class="toc-text">装类类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B"><span class="toc-number">14.0.1.6.</span> <span class="toc-text">装字符串类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">14.0.1.7.</span> <span class="toc-text">装数组类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A3%85%E5%80%BC%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-number">14.0.1.8.</span> <span class="toc-text">装值类型：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E7%B1%BB"><span class="toc-number">14.0.2.</span> <span class="toc-text">密封类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%80%81vob"><span class="toc-number">15.</span> <span class="toc-text">多态vob</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81%EF%BC%88Polymorphism%EF%BC%89%EF%BC%9F"><span class="toc-number">15.0.1.</span> <span class="toc-text">什么是多态（Polymorphism）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0%EF%BC%9AV-O-B"><span class="toc-number">15.0.2.</span> <span class="toc-text">多态的三要素：V.O.B</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">15.0.3.</span> <span class="toc-text">多态的目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%88%E5%90%83%E9%A5%AD%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%A4%9A%E6%80%81%EF%BC%89"><span class="toc-number">15.0.4.</span> <span class="toc-text">示例说明（吃饭行为的多态）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">15.0.5.</span> <span class="toc-text">原理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A"><span class="toc-number">15.0.6.</span> <span class="toc-text">举例：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%88abstract%E2%80%8B%EF%BC%89"><span class="toc-number">16.</span> <span class="toc-text">C# 抽象类与抽象方法（abstract​）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">16.1.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%9F"><span class="toc-number">16.1.1.</span> <span class="toc-text">什么是抽象类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">16.1.2.</span> <span class="toc-text">抽象方法的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%9A%E5%8A%A8%E7%89%A9%E7%B1%BB"><span class="toc-number">16.1.3.</span> <span class="toc-text">示例说明：动物类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93"><span class="toc-number">16.1.4.</span> <span class="toc-text">抽象类使用规则总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%BE%E4%BE%8B"><span class="toc-number">16.1.5.</span> <span class="toc-text">使用场景举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E8%B4%B4%E5%A3%AB"><span class="toc-number">16.1.6.</span> <span class="toc-text">小贴士</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">16.2.</span> <span class="toc-text">抽象方法（函数）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">16.2.1.</span> <span class="toc-text">什么是抽象方法？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-number">16.2.2.</span> <span class="toc-text">抽象方法的定义格式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">16.2.3.</span> <span class="toc-text">示例代码：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B8%8E%E6%99%AE%E9%80%9A%E8%99%9A%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">16.2.4.</span> <span class="toc-text">抽象方法与普通虚方法的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">16.2.5.</span> <span class="toc-text">抽象方法的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B"><span class="toc-number">16.2.6.</span> <span class="toc-text">使用场景示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">16.2.7.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">17.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-number">17.1.</span> <span class="toc-text">什么是接口？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-number">17.2.</span> <span class="toc-text">举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">17.3.</span> <span class="toc-text">显示实现接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E8%AF%B4%E6%98%8E"><span class="toc-number">17.3.1.</span> <span class="toc-text">场景说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F%E7%A4%BA%E4%BE%8B"><span class="toc-number">17.3.2.</span> <span class="toc-text">语法格式示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">17.3.3.</span> <span class="toc-text">调用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">17.3.4.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">17.3.5.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">17.3.6.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E5%87%BD%E6%95%B0"><span class="toc-number">18.</span> <span class="toc-text">密封函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">19.</span> <span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88singleton%EF%BC%89"><span class="toc-number">20.</span> <span class="toc-text">单例模式（singleton）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">21.</span> <span class="toc-text">字符串常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%B4%E6%98%8E"><span class="toc-number">21.1.</span> <span class="toc-text">字符串常用方法说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">21.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#StringBuilder"><span class="toc-number">22.</span> <span class="toc-text">StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFStringBuilder%E2%80%8B%EF%BC%9F"><span class="toc-number">22.1.</span> <span class="toc-text">什么是StringBuilder​？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">22.2.</span> <span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">22.3.</span> <span class="toc-text">构造方式：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">22.4.</span> <span class="toc-text">属性说明：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A-1"><span class="toc-number">22.5.</span> <span class="toc-text">举例：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuilder%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9%EF%BC%9A"><span class="toc-number">22.6.</span> <span class="toc-text">StringBuilder的增删查改：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">22.7.</span> <span class="toc-text">推荐使用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB"><span class="toc-number">23.</span> <span class="toc-text">数据结构类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Arraylist"><span class="toc-number">23.1.</span> <span class="toc-text">Arraylist</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">23.1.1.</span> <span class="toc-text">ArrayList 的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arraylist%E5%BC%95%E7%94%A8%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%A3%B0%E6%98%8E%E8%AF%AD%E6%B3%95"><span class="toc-number">23.1.2.</span> <span class="toc-text">Arraylist引用命名空间与声明语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9"><span class="toc-number">23.1.3.</span> <span class="toc-text">ArrayList的增删查改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E4%B8%8E%E9%81%8D%E5%8E%86"><span class="toc-number">23.1.4.</span> <span class="toc-text">插入与遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="toc-number">23.1.5.</span> <span class="toc-text">迭代器遍历：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1%EF%BC%9A"><span class="toc-number">23.1.6.</span> <span class="toc-text">装箱拆箱：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stack"><span class="toc-number">23.2.</span> <span class="toc-text">Stack</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E"><span class="toc-number">23.2.1.</span> <span class="toc-text">增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96"><span class="toc-number">23.2.2.</span> <span class="toc-text">取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5"><span class="toc-number">23.2.3.</span> <span class="toc-text">查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9"><span class="toc-number">23.2.4.</span> <span class="toc-text">改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">23.2.5.</span> <span class="toc-text">遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Queue"><span class="toc-number">23.3.</span> <span class="toc-text">Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E-1"><span class="toc-number">23.3.1.</span> <span class="toc-text">增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0"><span class="toc-number">23.3.2.</span> <span class="toc-text">删</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5-1"><span class="toc-number">23.3.3.</span> <span class="toc-text">查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9-1"><span class="toc-number">23.3.4.</span> <span class="toc-text">改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-1"><span class="toc-number">23.3.5.</span> <span class="toc-text">遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">23.4.</span> <span class="toc-text">哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E-2"><span class="toc-number">23.4.1.</span> <span class="toc-text">增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0-1"><span class="toc-number">23.4.2.</span> <span class="toc-text">删</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5-2"><span class="toc-number">23.4.3.</span> <span class="toc-text">查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9-2"><span class="toc-number">23.4.4.</span> <span class="toc-text">改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-2"><span class="toc-number">23.4.5.</span> <span class="toc-text">遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">23.5.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">23.5.1.</span> <span class="toc-text">泛型类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">23.5.2.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">23.5.3.</span> <span class="toc-text">普通类中的泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">23.5.4.</span> <span class="toc-text">泛型类中的泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">23.5.5.</span> <span class="toc-text">泛型的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">23.6.</span> <span class="toc-text">泛型约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">23.6.1.</span> <span class="toc-text">值类型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">23.6.2.</span> <span class="toc-text">引用类型约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E6%97%A0%E5%8F%82%E5%85%AC%E5%85%B1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">23.6.3.</span> <span class="toc-text">存在无参公共构造函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%90%E4%B8%AA%E7%B1%BB%E6%9C%AC%E8%BA%AB%E6%88%96%E8%80%85%E5%85%B6%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">23.6.4.</span> <span class="toc-text">某个类本身或者其派生类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BA%A6%E6%9D%9F"><span class="toc-number">23.6.5.</span> <span class="toc-text">接口约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%B3%9B%E5%9E%8B%E6%9C%AC%E8%BA%AB%E6%88%96%E8%80%85%E6%B4%BE%E7%94%9F%E7%B1%BB"><span class="toc-number">23.6.6.</span> <span class="toc-text">另一个泛型本身或者派生类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E7%9A%84%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">23.6.7.</span> <span class="toc-text">约束的组合使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E6%B3%9B%E5%9E%8B%E5%88%86%E5%88%AB%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F"><span class="toc-number">23.6.8.</span> <span class="toc-text">多个泛型分别添加约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB"><span class="toc-number">23.7.</span> <span class="toc-text">泛型数据结构类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">23.8.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E-3"><span class="toc-number">23.8.1.</span> <span class="toc-text">增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0-2"><span class="toc-number">23.8.2.</span> <span class="toc-text">删</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5-3"><span class="toc-number">23.8.3.</span> <span class="toc-text">查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9-3"><span class="toc-number">23.8.4.</span> <span class="toc-text">改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-3"><span class="toc-number">23.8.5.</span> <span class="toc-text">遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%EF%BC%88dictionary%EF%BC%89"><span class="toc-number">23.9.</span> <span class="toc-text">字典（dictionary）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E-4"><span class="toc-number">23.9.1.</span> <span class="toc-text">增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0-3"><span class="toc-number">23.9.2.</span> <span class="toc-text">删</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5-4"><span class="toc-number">23.9.3.</span> <span class="toc-text">查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9-4"><span class="toc-number">23.9.4.</span> <span class="toc-text">改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-4"><span class="toc-number">23.9.5.</span> <span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">23.9.6.</span> <span class="toc-text">链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList"><span class="toc-number">23.10.</span> <span class="toc-text">LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E-5"><span class="toc-number">23.10.1.</span> <span class="toc-text">增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0-4"><span class="toc-number">23.10.2.</span> <span class="toc-text">删</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5-5"><span class="toc-number">23.10.3.</span> <span class="toc-text">查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9-5"><span class="toc-number">23.10.4.</span> <span class="toc-text">改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86-5"><span class="toc-number">23.10.5.</span> <span class="toc-text">遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">23.11.</span> <span class="toc-text">泛型栈和队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A7%94%E6%89%98"><span class="toc-number">24.</span> <span class="toc-text">委托</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E7%9A%84%E7%94%A8%E5%A4%84%E5%92%8C%E8%AF%AD%E6%B3%95"><span class="toc-number">24.1.</span> <span class="toc-text">委托的用处和语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%92%AD%E5%A7%94%E6%89%98"><span class="toc-number">24.2.</span> <span class="toc-text">多播委托</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">25.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%EF%BC%88%E5%A7%94%E6%89%98%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85%E3%80%81%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85%E3%80%81EventHandler%E7%B1%BB%E3%80%81Windows%E4%BA%8B%E4%BB%B6%EF%BC%89"><span class="toc-number">25.0.0.1.</span> <span class="toc-text">C#中的事件（委托的发布和订阅、事件的发布和订阅、EventHandler类、Windows事件）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">26.</span> <span class="toc-text">匿名函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E8%AF%AD%E6%B3%95%E5%92%8C%E7%94%A8%E5%A4%84"><span class="toc-number">26.1.</span> <span class="toc-text">匿名函数语法和用处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">26.2.</span> <span class="toc-text">匿名函数缺点：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">27.</span> <span class="toc-text">回调函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">27.1.</span> <span class="toc-text">回调函数的理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">27.2.</span> <span class="toc-text">回调函数的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">28.</span> <span class="toc-text">Lamda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFlamda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">28.0.1.</span> <span class="toc-text">什么是lamda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95"><span class="toc-number">28.0.2.</span> <span class="toc-text">Lamda表达式语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">28.0.3.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">28.0.4.</span> <span class="toc-text">闭包（重要）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#List%E6%8E%92%E5%BA%8F%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">29.</span> <span class="toc-text">List排序（重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E8%87%AA%E5%B8%A6%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95"><span class="toc-number">29.1.</span> <span class="toc-text">List自带排序方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="toc-number">29.2.</span> <span class="toc-text">自定义类的排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%A7%94%E6%89%98%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">29.3.</span> <span class="toc-text">通过委托函数进行排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">29.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98%E9%80%86%E5%8F%98"><span class="toc-number">30.</span> <span class="toc-text">协变逆变</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">31.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B"><span class="toc-number">31.1.</span> <span class="toc-text">什么是进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B"><span class="toc-number">31.2.</span> <span class="toc-text">什么是线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">31.3.</span> <span class="toc-text">什么是多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">31.4.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89%E2%80%8B"><span class="toc-number">31.5.</span> <span class="toc-text">线程之间的共享数据（重要）​</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">31.6.</span> <span class="toc-text">多线程的意义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-number">32.</span> <span class="toc-text">预处理指令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%92%8C%E7%89%B9%E6%80%A7"><span class="toc-number">33.</span> <span class="toc-text">反射和特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E9%9B%86"><span class="toc-number">33.1.</span> <span class="toc-text">什么是程序集</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">34.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6"><span class="toc-number">35.</span> <span class="toc-text">进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFLinQ%EF%BC%9F%E7%94%A8%E6%9D%A5%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">35.1.</span> <span class="toc-text">什么是LinQ？用来干什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84LINQ%E8%AF%AD%E6%B3%95"><span class="toc-number">35.2.</span> <span class="toc-text">C#中的LINQ语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-LINQ%EF%BC%88Language-Integrated-Query%EF%BC%89%E8%AF%AD%E6%B3%95%E5%9C%A8-C-%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">35.2.1.</span> <span class="toc-text">使用 LINQ（Language-Integrated Query）语法在 C# 中进行查询操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A3%80%E7%B4%A2List%E5%88%97%E8%A1%A8%E4%B8%AD%E8%A3%85%E8%BD%BD%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">35.2.1.1.</span> <span class="toc-text">1.检索List列表中装载的对象的属性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">36.</span> <span class="toc-text">C#面试题</span></a></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/02/WebApplication/axios/" title="axios的创建实例"><img src="https://t.alcy.cc/moez?3115" onerror="this.onerror=null;this.src='/assets/404.jpg'" alt="axios的创建实例"></a><div class="content"><a class="title" href="/2025/06/02/WebApplication/axios/" title="axios的创建实例">axios的创建实例</a><time datetime="2025-06-01T18:27:06.000Z" title="发表于 2025-06-02 02:27:06">2025-06-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/02/WebApplication/CSS%E5%B8%83%E5%B1%80%E6%89%8B%E5%86%8C/" title="CSS布局手册"><img src="https://t.alcy.cc/ycy?6424" onerror="this.onerror=null;this.src='/assets/404.jpg'" alt="CSS布局手册"></a><div class="content"><a class="title" href="/2025/06/02/WebApplication/CSS%E5%B8%83%E5%B1%80%E6%89%8B%E5%86%8C/" title="CSS布局手册">CSS布局手册</a><time datetime="2025-06-01T18:22:20.000Z" title="发表于 2025-06-02 02:22:20">2025-06-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/02/WebApplication/JavaScript/" title="Javascript笔记"><img src="https://t.alcy.cc/moe?9342" onerror="this.onerror=null;this.src='/assets/404.jpg'" alt="Javascript笔记"></a><div class="content"><a class="title" href="/2025/06/02/WebApplication/JavaScript/" title="Javascript笔记">Javascript笔记</a><time datetime="2025-06-01T18:14:48.000Z" title="发表于 2025-06-02 02:14:48">2025-06-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/02/WebApplication/AJAX/" title="AJAX笔记"><img src="https://t.alcy.cc/mp?4245" onerror="this.onerror=null;this.src='/assets/404.jpg'" alt="AJAX笔记"></a><div class="content"><a class="title" href="/2025/06/02/WebApplication/AJAX/" title="AJAX笔记">AJAX笔记</a><time datetime="2025-06-01T18:13:38.000Z" title="发表于 2025-06-02 02:13:38">2025-06-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/01/Japanese/%E6%97%A5%E8%AF%AD%E5%AD%A6%E6%A0%A1%E8%AF%AD%E6%B3%95%E4%BD%93%E7%B3%BB%E4%B8%8E%E6%95%99%E8%82%B2%E8%AF%AD%E6%B3%95%E4%BD%93%E7%B3%BB/" title="（二）日语学校语法体系与教育语法体系"><img src="https://t.alcy.cc/moe?8228" onerror="this.onerror=null;this.src='/assets/404.jpg'" alt="（二）日语学校语法体系与教育语法体系"></a><div class="content"><a class="title" href="/2025/06/01/Japanese/%E6%97%A5%E8%AF%AD%E5%AD%A6%E6%A0%A1%E8%AF%AD%E6%B3%95%E4%BD%93%E7%B3%BB%E4%B8%8E%E6%95%99%E8%82%B2%E8%AF%AD%E6%B3%95%E4%BD%93%E7%B3%BB/" title="（二）日语学校语法体系与教育语法体系">（二）日语学校语法体系与教育语法体系</a><time datetime="2025-06-01T04:21:48.000Z" title="发表于 2025-06-01 12:21:48">2025-06-01</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent;"><div id="footer-wrap"><div class="copyright">©2019 - 2025 By Ayami</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-vercel-phi-nine.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://twikoo-vercel-phi-nine.vercel.app/',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><div class="aplayer no-destroy" data-id="13519966293" data-server="netease" data-type="playlist" data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" data-lrc-type="0"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>